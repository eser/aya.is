// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: mailbox.sql

package storage

import (
	"context"
	"database/sql"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const addMailboxParticipant = `-- name: AddMailboxParticipant :exec

INSERT INTO "mailbox_participant" (
  id, conversation_id, profile_id, joined_at
) VALUES (
  $1,
  $2,
  $3,
  NOW()
)
`

type AddMailboxParticipantParams struct {
	ID             string `db:"id" json:"id"`
	ConversationID string `db:"conversation_id" json:"conversation_id"`
	ProfileID      string `db:"profile_id" json:"profile_id"`
}

// ============================================================
// Participants
// ============================================================
//
//	INSERT INTO "mailbox_participant" (
//	  id, conversation_id, profile_id, joined_at
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  NOW()
//	)
func (q *Queries) AddMailboxParticipant(ctx context.Context, arg AddMailboxParticipantParams) error {
	_, err := q.db.ExecContext(ctx, addMailboxParticipant, arg.ID, arg.ConversationID, arg.ProfileID)
	return err
}

const addMailboxReaction = `-- name: AddMailboxReaction :exec

INSERT INTO "mailbox_reaction" (id, envelope_id, profile_id, emoji, created_at)
VALUES ($1, $2, $3, $4, NOW())
ON CONFLICT (envelope_id, profile_id, emoji) DO NOTHING
`

type AddMailboxReactionParams struct {
	ID         string `db:"id" json:"id"`
	EnvelopeID string `db:"envelope_id" json:"envelope_id"`
	ProfileID  string `db:"profile_id" json:"profile_id"`
	Emoji      string `db:"emoji" json:"emoji"`
}

// ============================================================
// Reactions
// ============================================================
//
//	INSERT INTO "mailbox_reaction" (id, envelope_id, profile_id, emoji, created_at)
//	VALUES ($1, $2, $3, $4, NOW())
//	ON CONFLICT (envelope_id, profile_id, emoji) DO NOTHING
func (q *Queries) AddMailboxReaction(ctx context.Context, arg AddMailboxReactionParams) error {
	_, err := q.db.ExecContext(ctx, addMailboxReaction,
		arg.ID,
		arg.EnvelopeID,
		arg.ProfileID,
		arg.Emoji,
	)
	return err
}

const countPendingMailboxEnvelopes = `-- name: CountPendingMailboxEnvelopes :one
SELECT COUNT(*)::INT AS count
FROM "mailbox_envelope"
WHERE target_profile_id = $1
  AND status = 'pending'
  AND deleted_at IS NULL
`

type CountPendingMailboxEnvelopesParams struct {
	TargetProfileID string `db:"target_profile_id" json:"target_profile_id"`
}

// CountPendingMailboxEnvelopes
//
//	SELECT COUNT(*)::INT AS count
//	FROM "mailbox_envelope"
//	WHERE target_profile_id = $1
//	  AND status = 'pending'
//	  AND deleted_at IS NULL
func (q *Queries) CountPendingMailboxEnvelopes(ctx context.Context, arg CountPendingMailboxEnvelopesParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, countPendingMailboxEnvelopes, arg.TargetProfileID)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const countUnreadConversations = `-- name: CountUnreadConversations :one

SELECT COUNT(DISTINCT mc.id)::INT AS count
FROM "mailbox_conversation" mc
  INNER JOIN "mailbox_participant" mp
    ON mp.conversation_id = mc.id
    AND mp.profile_id = $1
    AND mp.left_at IS NULL
    AND mp.is_archived = FALSE
WHERE EXISTS (
  SELECT 1 FROM "mailbox_envelope" me
  WHERE me.conversation_id = mc.id
    AND me.deleted_at IS NULL
    AND (mp.last_read_at IS NULL OR me.created_at > mp.last_read_at)
)
`

type CountUnreadConversationsParams struct {
	ProfileID string `db:"profile_id" json:"profile_id"`
}

// ============================================================
// Aggregate counts
// ============================================================
//
//	SELECT COUNT(DISTINCT mc.id)::INT AS count
//	FROM "mailbox_conversation" mc
//	  INNER JOIN "mailbox_participant" mp
//	    ON mp.conversation_id = mc.id
//	    AND mp.profile_id = $1
//	    AND mp.left_at IS NULL
//	    AND mp.is_archived = FALSE
//	WHERE EXISTS (
//	  SELECT 1 FROM "mailbox_envelope" me
//	  WHERE me.conversation_id = mc.id
//	    AND me.deleted_at IS NULL
//	    AND (mp.last_read_at IS NULL OR me.created_at > mp.last_read_at)
//	)
func (q *Queries) CountUnreadConversations(ctx context.Context, arg CountUnreadConversationsParams) (int32, error) {
	row := q.db.QueryRowContext(ctx, countUnreadConversations, arg.ProfileID)
	var count int32
	err := row.Scan(&count)
	return count, err
}

const createMailboxConversation = `-- name: CreateMailboxConversation :exec

INSERT INTO "mailbox_conversation" (
  id, kind, title, created_by_profile_id, created_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  NOW()
)
`

type CreateMailboxConversationParams struct {
	ID                 string         `db:"id" json:"id"`
	Kind               string         `db:"kind" json:"kind"`
	Title              sql.NullString `db:"title" json:"title"`
	CreatedByProfileID sql.NullString `db:"created_by_profile_id" json:"created_by_profile_id"`
}

// ============================================================
// Conversations
// ============================================================
//
//	INSERT INTO "mailbox_conversation" (
//	  id, kind, title, created_by_profile_id, created_at
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  NOW()
//	)
func (q *Queries) CreateMailboxConversation(ctx context.Context, arg CreateMailboxConversationParams) error {
	_, err := q.db.ExecContext(ctx, createMailboxConversation,
		arg.ID,
		arg.Kind,
		arg.Title,
		arg.CreatedByProfileID,
	)
	return err
}

const createMailboxEnvelope = `-- name: CreateMailboxEnvelope :exec

INSERT INTO "mailbox_envelope" (
  id, conversation_id, target_profile_id, sender_profile_id, sender_user_id,
  kind, status, message, properties, reply_to_id, created_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  'pending',
  $7,
  $8,
  $9,
  NOW()
)
`

type CreateMailboxEnvelopeParams struct {
	ID              string                `db:"id" json:"id"`
	ConversationID  string                `db:"conversation_id" json:"conversation_id"`
	TargetProfileID string                `db:"target_profile_id" json:"target_profile_id"`
	SenderProfileID sql.NullString        `db:"sender_profile_id" json:"sender_profile_id"`
	SenderUserID    sql.NullString        `db:"sender_user_id" json:"sender_user_id"`
	Kind            string                `db:"kind" json:"kind"`
	Message         sql.NullString        `db:"message" json:"message"`
	Properties      pqtype.NullRawMessage `db:"properties" json:"properties"`
	ReplyToID       sql.NullString        `db:"reply_to_id" json:"reply_to_id"`
}

// ============================================================
// Envelopes (messages)
// ============================================================
//
//	INSERT INTO "mailbox_envelope" (
//	  id, conversation_id, target_profile_id, sender_profile_id, sender_user_id,
//	  kind, status, message, properties, reply_to_id, created_at
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5,
//	  $6,
//	  'pending',
//	  $7,
//	  $8,
//	  $9,
//	  NOW()
//	)
func (q *Queries) CreateMailboxEnvelope(ctx context.Context, arg CreateMailboxEnvelopeParams) error {
	_, err := q.db.ExecContext(ctx, createMailboxEnvelope,
		arg.ID,
		arg.ConversationID,
		arg.TargetProfileID,
		arg.SenderProfileID,
		arg.SenderUserID,
		arg.Kind,
		arg.Message,
		arg.Properties,
		arg.ReplyToID,
	)
	return err
}

const findDirectConversation = `-- name: FindDirectConversation :one
SELECT mc.id, mc.kind, mc.title, mc.created_by_profile_id, mc.created_at, mc.updated_at
FROM "mailbox_conversation" mc
WHERE mc.kind = 'direct'
  AND EXISTS (
    SELECT 1 FROM "mailbox_participant" mp
    WHERE mp.conversation_id = mc.id
      AND mp.profile_id = $1
      AND mp.left_at IS NULL
  )
  AND EXISTS (
    SELECT 1 FROM "mailbox_participant" mp
    WHERE mp.conversation_id = mc.id
      AND mp.profile_id = $2
      AND mp.left_at IS NULL
  )
  AND (
    SELECT COUNT(*) FROM "mailbox_participant" mp
    WHERE mp.conversation_id = mc.id AND mp.left_at IS NULL
  ) = 2
LIMIT 1
`

type FindDirectConversationParams struct {
	ProfileA string `db:"profile_a" json:"profile_a"`
	ProfileB string `db:"profile_b" json:"profile_b"`
}

// FindDirectConversation
//
//	SELECT mc.id, mc.kind, mc.title, mc.created_by_profile_id, mc.created_at, mc.updated_at
//	FROM "mailbox_conversation" mc
//	WHERE mc.kind = 'direct'
//	  AND EXISTS (
//	    SELECT 1 FROM "mailbox_participant" mp
//	    WHERE mp.conversation_id = mc.id
//	      AND mp.profile_id = $1
//	      AND mp.left_at IS NULL
//	  )
//	  AND EXISTS (
//	    SELECT 1 FROM "mailbox_participant" mp
//	    WHERE mp.conversation_id = mc.id
//	      AND mp.profile_id = $2
//	      AND mp.left_at IS NULL
//	  )
//	  AND (
//	    SELECT COUNT(*) FROM "mailbox_participant" mp
//	    WHERE mp.conversation_id = mc.id AND mp.left_at IS NULL
//	  ) = 2
//	LIMIT 1
func (q *Queries) FindDirectConversation(ctx context.Context, arg FindDirectConversationParams) (*MailboxConversation, error) {
	row := q.db.QueryRowContext(ctx, findDirectConversation, arg.ProfileA, arg.ProfileB)
	var i MailboxConversation
	err := row.Scan(
		&i.ID,
		&i.Kind,
		&i.Title,
		&i.CreatedByProfileID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getMailboxConversationByID = `-- name: GetMailboxConversationByID :one
SELECT id, kind, title, created_by_profile_id, created_at, updated_at
FROM "mailbox_conversation"
WHERE id = $1
`

type GetMailboxConversationByIDParams struct {
	ID string `db:"id" json:"id"`
}

// GetMailboxConversationByID
//
//	SELECT id, kind, title, created_by_profile_id, created_at, updated_at
//	FROM "mailbox_conversation"
//	WHERE id = $1
func (q *Queries) GetMailboxConversationByID(ctx context.Context, arg GetMailboxConversationByIDParams) (*MailboxConversation, error) {
	row := q.db.QueryRowContext(ctx, getMailboxConversationByID, arg.ID)
	var i MailboxConversation
	err := row.Scan(
		&i.ID,
		&i.Kind,
		&i.Title,
		&i.CreatedByProfileID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getMailboxEnvelopeByID = `-- name: GetMailboxEnvelopeByID :one
SELECT id, target_profile_id, sender_profile_id, sender_user_id, kind, status, message, properties, accepted_at, rejected_at, revoked_at, redeemed_at, created_at, updated_at, deleted_at, conversation_id, reply_to_id
FROM "mailbox_envelope"
WHERE id = $1
  AND deleted_at IS NULL
`

type GetMailboxEnvelopeByIDParams struct {
	ID string `db:"id" json:"id"`
}

// GetMailboxEnvelopeByID
//
//	SELECT id, target_profile_id, sender_profile_id, sender_user_id, kind, status, message, properties, accepted_at, rejected_at, revoked_at, redeemed_at, created_at, updated_at, deleted_at, conversation_id, reply_to_id
//	FROM "mailbox_envelope"
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) GetMailboxEnvelopeByID(ctx context.Context, arg GetMailboxEnvelopeByIDParams) (*MailboxEnvelope, error) {
	row := q.db.QueryRowContext(ctx, getMailboxEnvelopeByID, arg.ID)
	var i MailboxEnvelope
	err := row.Scan(
		&i.ID,
		&i.TargetProfileID,
		&i.SenderProfileID,
		&i.SenderUserID,
		&i.Kind,
		&i.Status,
		&i.Message,
		&i.Properties,
		&i.AcceptedAt,
		&i.RejectedAt,
		&i.RevokedAt,
		&i.RedeemedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ConversationID,
		&i.ReplyToID,
	)
	return &i, err
}

const getMailboxParticipant = `-- name: GetMailboxParticipant :one
SELECT
  mp.id, mp.conversation_id, mp.profile_id, mp.last_read_at, mp.is_archived, mp.joined_at, mp.left_at,
  p.slug AS profile_slug,
  COALESCE(pt.title, '') AS profile_title,
  p.profile_picture_uri AS profile_picture_uri,
  p.kind AS profile_kind
FROM "mailbox_participant" mp
  INNER JOIN "profile" p ON p.id = mp.profile_id AND p.deleted_at IS NULL
  LEFT JOIN "profile_tx" pt ON pt.profile_id = p.id AND pt.locale_code = p.default_locale
WHERE mp.conversation_id = $1
  AND mp.profile_id = $2
  AND mp.left_at IS NULL
`

type GetMailboxParticipantParams struct {
	ConversationID string `db:"conversation_id" json:"conversation_id"`
	ProfileID      string `db:"profile_id" json:"profile_id"`
}

type GetMailboxParticipantRow struct {
	ID                string         `db:"id" json:"id"`
	ConversationID    string         `db:"conversation_id" json:"conversation_id"`
	ProfileID         string         `db:"profile_id" json:"profile_id"`
	LastReadAt        sql.NullTime   `db:"last_read_at" json:"last_read_at"`
	IsArchived        bool           `db:"is_archived" json:"is_archived"`
	JoinedAt          time.Time      `db:"joined_at" json:"joined_at"`
	LeftAt            sql.NullTime   `db:"left_at" json:"left_at"`
	ProfileSlug       string         `db:"profile_slug" json:"profile_slug"`
	ProfileTitle      string         `db:"profile_title" json:"profile_title"`
	ProfilePictureURI sql.NullString `db:"profile_picture_uri" json:"profile_picture_uri"`
	ProfileKind       string         `db:"profile_kind" json:"profile_kind"`
}

// GetMailboxParticipant
//
//	SELECT
//	  mp.id, mp.conversation_id, mp.profile_id, mp.last_read_at, mp.is_archived, mp.joined_at, mp.left_at,
//	  p.slug AS profile_slug,
//	  COALESCE(pt.title, '') AS profile_title,
//	  p.profile_picture_uri AS profile_picture_uri,
//	  p.kind AS profile_kind
//	FROM "mailbox_participant" mp
//	  INNER JOIN "profile" p ON p.id = mp.profile_id AND p.deleted_at IS NULL
//	  LEFT JOIN "profile_tx" pt ON pt.profile_id = p.id AND pt.locale_code = p.default_locale
//	WHERE mp.conversation_id = $1
//	  AND mp.profile_id = $2
//	  AND mp.left_at IS NULL
func (q *Queries) GetMailboxParticipant(ctx context.Context, arg GetMailboxParticipantParams) (*GetMailboxParticipantRow, error) {
	row := q.db.QueryRowContext(ctx, getMailboxParticipant, arg.ConversationID, arg.ProfileID)
	var i GetMailboxParticipantRow
	err := row.Scan(
		&i.ID,
		&i.ConversationID,
		&i.ProfileID,
		&i.LastReadAt,
		&i.IsArchived,
		&i.JoinedAt,
		&i.LeftAt,
		&i.ProfileSlug,
		&i.ProfileTitle,
		&i.ProfilePictureURI,
		&i.ProfileKind,
	)
	return &i, err
}

const listAcceptedMailboxInvitations = `-- name: ListAcceptedMailboxInvitations :many
SELECT
  me.id, me.target_profile_id, me.sender_profile_id, me.sender_user_id, me.kind, me.status, me.message, me.properties, me.accepted_at, me.rejected_at, me.revoked_at, me.redeemed_at, me.created_at, me.updated_at, me.deleted_at, me.conversation_id, me.reply_to_id,
  sp.slug AS sender_profile_slug,
  COALESCE(spt.title, '') AS sender_profile_title,
  sp.profile_picture_uri AS sender_profile_picture_uri,
  sp.kind AS sender_profile_kind
FROM "mailbox_envelope" me
  LEFT JOIN "profile" sp ON sp.id = me.sender_profile_id AND sp.deleted_at IS NULL
  LEFT JOIN "profile_tx" spt ON spt.profile_id = sp.id AND spt.locale_code = sp.default_locale
WHERE me.target_profile_id = $1
  AND me.kind = 'invitation'
  AND me.status = 'accepted'
  AND me.deleted_at IS NULL
  AND ($2::TEXT IS NULL
       OR me.properties->>'invitation_kind' = $2)
ORDER BY me.created_at DESC
`

type ListAcceptedMailboxInvitationsParams struct {
	TargetProfileID string         `db:"target_profile_id" json:"target_profile_id"`
	InvitationKind  sql.NullString `db:"invitation_kind" json:"invitation_kind"`
}

type ListAcceptedMailboxInvitationsRow struct {
	ID                      string                `db:"id" json:"id"`
	TargetProfileID         string                `db:"target_profile_id" json:"target_profile_id"`
	SenderProfileID         sql.NullString        `db:"sender_profile_id" json:"sender_profile_id"`
	SenderUserID            sql.NullString        `db:"sender_user_id" json:"sender_user_id"`
	Kind                    string                `db:"kind" json:"kind"`
	Status                  string                `db:"status" json:"status"`
	Message                 sql.NullString        `db:"message" json:"message"`
	Properties              pqtype.NullRawMessage `db:"properties" json:"properties"`
	AcceptedAt              sql.NullTime          `db:"accepted_at" json:"accepted_at"`
	RejectedAt              sql.NullTime          `db:"rejected_at" json:"rejected_at"`
	RevokedAt               sql.NullTime          `db:"revoked_at" json:"revoked_at"`
	RedeemedAt              sql.NullTime          `db:"redeemed_at" json:"redeemed_at"`
	CreatedAt               time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt               sql.NullTime          `db:"updated_at" json:"updated_at"`
	DeletedAt               sql.NullTime          `db:"deleted_at" json:"deleted_at"`
	ConversationID          string                `db:"conversation_id" json:"conversation_id"`
	ReplyToID               sql.NullString        `db:"reply_to_id" json:"reply_to_id"`
	SenderProfileSlug       sql.NullString        `db:"sender_profile_slug" json:"sender_profile_slug"`
	SenderProfileTitle      string                `db:"sender_profile_title" json:"sender_profile_title"`
	SenderProfilePictureURI sql.NullString        `db:"sender_profile_picture_uri" json:"sender_profile_picture_uri"`
	SenderProfileKind       sql.NullString        `db:"sender_profile_kind" json:"sender_profile_kind"`
}

// ListAcceptedMailboxInvitations
//
//	SELECT
//	  me.id, me.target_profile_id, me.sender_profile_id, me.sender_user_id, me.kind, me.status, me.message, me.properties, me.accepted_at, me.rejected_at, me.revoked_at, me.redeemed_at, me.created_at, me.updated_at, me.deleted_at, me.conversation_id, me.reply_to_id,
//	  sp.slug AS sender_profile_slug,
//	  COALESCE(spt.title, '') AS sender_profile_title,
//	  sp.profile_picture_uri AS sender_profile_picture_uri,
//	  sp.kind AS sender_profile_kind
//	FROM "mailbox_envelope" me
//	  LEFT JOIN "profile" sp ON sp.id = me.sender_profile_id AND sp.deleted_at IS NULL
//	  LEFT JOIN "profile_tx" spt ON spt.profile_id = sp.id AND spt.locale_code = sp.default_locale
//	WHERE me.target_profile_id = $1
//	  AND me.kind = 'invitation'
//	  AND me.status = 'accepted'
//	  AND me.deleted_at IS NULL
//	  AND ($2::TEXT IS NULL
//	       OR me.properties->>'invitation_kind' = $2)
//	ORDER BY me.created_at DESC
func (q *Queries) ListAcceptedMailboxInvitations(ctx context.Context, arg ListAcceptedMailboxInvitationsParams) ([]*ListAcceptedMailboxInvitationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listAcceptedMailboxInvitations, arg.TargetProfileID, arg.InvitationKind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListAcceptedMailboxInvitationsRow{}
	for rows.Next() {
		var i ListAcceptedMailboxInvitationsRow
		if err := rows.Scan(
			&i.ID,
			&i.TargetProfileID,
			&i.SenderProfileID,
			&i.SenderUserID,
			&i.Kind,
			&i.Status,
			&i.Message,
			&i.Properties,
			&i.AcceptedAt,
			&i.RejectedAt,
			&i.RevokedAt,
			&i.RedeemedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ConversationID,
			&i.ReplyToID,
			&i.SenderProfileSlug,
			&i.SenderProfileTitle,
			&i.SenderProfilePictureURI,
			&i.SenderProfileKind,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listConversationsForProfile = `-- name: ListConversationsForProfile :many
SELECT
  mc.id,
  mc.kind,
  mc.title,
  mc.created_by_profile_id,
  mc.created_at,
  mc.updated_at,
  mp.last_read_at,
  mp.is_archived,
  (
    SELECT me.message FROM "mailbox_envelope" me
    WHERE me.conversation_id = mc.id AND me.deleted_at IS NULL
    ORDER BY me.created_at DESC LIMIT 1
  ) AS last_envelope_message,
  (
    SELECT me.kind FROM "mailbox_envelope" me
    WHERE me.conversation_id = mc.id AND me.deleted_at IS NULL
    ORDER BY me.created_at DESC LIMIT 1
  ) AS last_envelope_kind,
  (
    SELECT me.created_at FROM "mailbox_envelope" me
    WHERE me.conversation_id = mc.id AND me.deleted_at IS NULL
    ORDER BY me.created_at DESC LIMIT 1
  ) AS last_envelope_at,
  (
    SELECT me.sender_profile_id FROM "mailbox_envelope" me
    WHERE me.conversation_id = mc.id AND me.deleted_at IS NULL
    ORDER BY me.created_at DESC LIMIT 1
  ) AS last_envelope_sender_profile_id,
  (
    SELECT COUNT(*)::INT FROM "mailbox_envelope" me
    WHERE me.conversation_id = mc.id
      AND me.deleted_at IS NULL
      AND (mp.last_read_at IS NULL OR me.created_at > mp.last_read_at)
  ) AS unread_count
FROM "mailbox_conversation" mc
  INNER JOIN "mailbox_participant" mp
    ON mp.conversation_id = mc.id
    AND mp.profile_id = $1
    AND mp.left_at IS NULL
WHERE ($2::BOOLEAN = TRUE OR mp.is_archived = FALSE)
ORDER BY last_envelope_at DESC NULLS LAST
LIMIT $3
`

type ListConversationsForProfileParams struct {
	ProfileID       string `db:"profile_id" json:"profile_id"`
	IncludeArchived bool   `db:"include_archived" json:"include_archived"`
	LimitCount      int32  `db:"limit_count" json:"limit_count"`
}

type ListConversationsForProfileRow struct {
	ID                          string         `db:"id" json:"id"`
	Kind                        string         `db:"kind" json:"kind"`
	Title                       sql.NullString `db:"title" json:"title"`
	CreatedByProfileID          sql.NullString `db:"created_by_profile_id" json:"created_by_profile_id"`
	CreatedAt                   time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt                   sql.NullTime   `db:"updated_at" json:"updated_at"`
	LastReadAt                  sql.NullTime   `db:"last_read_at" json:"last_read_at"`
	IsArchived                  bool           `db:"is_archived" json:"is_archived"`
	LastEnvelopeMessage         sql.NullString `db:"last_envelope_message" json:"last_envelope_message"`
	LastEnvelopeKind            string         `db:"last_envelope_kind" json:"last_envelope_kind"`
	LastEnvelopeAt              time.Time      `db:"last_envelope_at" json:"last_envelope_at"`
	LastEnvelopeSenderProfileID sql.NullString `db:"last_envelope_sender_profile_id" json:"last_envelope_sender_profile_id"`
	UnreadCount                 int32          `db:"unread_count" json:"unread_count"`
}

// ListConversationsForProfile
//
//	SELECT
//	  mc.id,
//	  mc.kind,
//	  mc.title,
//	  mc.created_by_profile_id,
//	  mc.created_at,
//	  mc.updated_at,
//	  mp.last_read_at,
//	  mp.is_archived,
//	  (
//	    SELECT me.message FROM "mailbox_envelope" me
//	    WHERE me.conversation_id = mc.id AND me.deleted_at IS NULL
//	    ORDER BY me.created_at DESC LIMIT 1
//	  ) AS last_envelope_message,
//	  (
//	    SELECT me.kind FROM "mailbox_envelope" me
//	    WHERE me.conversation_id = mc.id AND me.deleted_at IS NULL
//	    ORDER BY me.created_at DESC LIMIT 1
//	  ) AS last_envelope_kind,
//	  (
//	    SELECT me.created_at FROM "mailbox_envelope" me
//	    WHERE me.conversation_id = mc.id AND me.deleted_at IS NULL
//	    ORDER BY me.created_at DESC LIMIT 1
//	  ) AS last_envelope_at,
//	  (
//	    SELECT me.sender_profile_id FROM "mailbox_envelope" me
//	    WHERE me.conversation_id = mc.id AND me.deleted_at IS NULL
//	    ORDER BY me.created_at DESC LIMIT 1
//	  ) AS last_envelope_sender_profile_id,
//	  (
//	    SELECT COUNT(*)::INT FROM "mailbox_envelope" me
//	    WHERE me.conversation_id = mc.id
//	      AND me.deleted_at IS NULL
//	      AND (mp.last_read_at IS NULL OR me.created_at > mp.last_read_at)
//	  ) AS unread_count
//	FROM "mailbox_conversation" mc
//	  INNER JOIN "mailbox_participant" mp
//	    ON mp.conversation_id = mc.id
//	    AND mp.profile_id = $1
//	    AND mp.left_at IS NULL
//	WHERE ($2::BOOLEAN = TRUE OR mp.is_archived = FALSE)
//	ORDER BY last_envelope_at DESC NULLS LAST
//	LIMIT $3
func (q *Queries) ListConversationsForProfile(ctx context.Context, arg ListConversationsForProfileParams) ([]*ListConversationsForProfileRow, error) {
	rows, err := q.db.QueryContext(ctx, listConversationsForProfile, arg.ProfileID, arg.IncludeArchived, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListConversationsForProfileRow{}
	for rows.Next() {
		var i ListConversationsForProfileRow
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.Title,
			&i.CreatedByProfileID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastReadAt,
			&i.IsArchived,
			&i.LastEnvelopeMessage,
			&i.LastEnvelopeKind,
			&i.LastEnvelopeAt,
			&i.LastEnvelopeSenderProfileID,
			&i.UnreadCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listEnvelopesByConversation = `-- name: ListEnvelopesByConversation :many
SELECT
  me.id, me.target_profile_id, me.sender_profile_id, me.sender_user_id, me.kind, me.status, me.message, me.properties, me.accepted_at, me.rejected_at, me.revoked_at, me.redeemed_at, me.created_at, me.updated_at, me.deleted_at, me.conversation_id, me.reply_to_id,
  sp.slug AS sender_profile_slug,
  COALESCE(spt.title, '') AS sender_profile_title,
  sp.profile_picture_uri AS sender_profile_picture_uri,
  sp.kind AS sender_profile_kind
FROM "mailbox_envelope" me
  LEFT JOIN "profile" sp ON sp.id = me.sender_profile_id AND sp.deleted_at IS NULL
  LEFT JOIN "profile_tx" spt ON spt.profile_id = sp.id AND spt.locale_code = sp.default_locale
WHERE me.conversation_id = $1
  AND me.deleted_at IS NULL
ORDER BY me.created_at ASC
LIMIT $2
`

type ListEnvelopesByConversationParams struct {
	ConversationID string `db:"conversation_id" json:"conversation_id"`
	LimitCount     int32  `db:"limit_count" json:"limit_count"`
}

type ListEnvelopesByConversationRow struct {
	ID                      string                `db:"id" json:"id"`
	TargetProfileID         string                `db:"target_profile_id" json:"target_profile_id"`
	SenderProfileID         sql.NullString        `db:"sender_profile_id" json:"sender_profile_id"`
	SenderUserID            sql.NullString        `db:"sender_user_id" json:"sender_user_id"`
	Kind                    string                `db:"kind" json:"kind"`
	Status                  string                `db:"status" json:"status"`
	Message                 sql.NullString        `db:"message" json:"message"`
	Properties              pqtype.NullRawMessage `db:"properties" json:"properties"`
	AcceptedAt              sql.NullTime          `db:"accepted_at" json:"accepted_at"`
	RejectedAt              sql.NullTime          `db:"rejected_at" json:"rejected_at"`
	RevokedAt               sql.NullTime          `db:"revoked_at" json:"revoked_at"`
	RedeemedAt              sql.NullTime          `db:"redeemed_at" json:"redeemed_at"`
	CreatedAt               time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt               sql.NullTime          `db:"updated_at" json:"updated_at"`
	DeletedAt               sql.NullTime          `db:"deleted_at" json:"deleted_at"`
	ConversationID          string                `db:"conversation_id" json:"conversation_id"`
	ReplyToID               sql.NullString        `db:"reply_to_id" json:"reply_to_id"`
	SenderProfileSlug       sql.NullString        `db:"sender_profile_slug" json:"sender_profile_slug"`
	SenderProfileTitle      string                `db:"sender_profile_title" json:"sender_profile_title"`
	SenderProfilePictureURI sql.NullString        `db:"sender_profile_picture_uri" json:"sender_profile_picture_uri"`
	SenderProfileKind       sql.NullString        `db:"sender_profile_kind" json:"sender_profile_kind"`
}

// ListEnvelopesByConversation
//
//	SELECT
//	  me.id, me.target_profile_id, me.sender_profile_id, me.sender_user_id, me.kind, me.status, me.message, me.properties, me.accepted_at, me.rejected_at, me.revoked_at, me.redeemed_at, me.created_at, me.updated_at, me.deleted_at, me.conversation_id, me.reply_to_id,
//	  sp.slug AS sender_profile_slug,
//	  COALESCE(spt.title, '') AS sender_profile_title,
//	  sp.profile_picture_uri AS sender_profile_picture_uri,
//	  sp.kind AS sender_profile_kind
//	FROM "mailbox_envelope" me
//	  LEFT JOIN "profile" sp ON sp.id = me.sender_profile_id AND sp.deleted_at IS NULL
//	  LEFT JOIN "profile_tx" spt ON spt.profile_id = sp.id AND spt.locale_code = sp.default_locale
//	WHERE me.conversation_id = $1
//	  AND me.deleted_at IS NULL
//	ORDER BY me.created_at ASC
//	LIMIT $2
func (q *Queries) ListEnvelopesByConversation(ctx context.Context, arg ListEnvelopesByConversationParams) ([]*ListEnvelopesByConversationRow, error) {
	rows, err := q.db.QueryContext(ctx, listEnvelopesByConversation, arg.ConversationID, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListEnvelopesByConversationRow{}
	for rows.Next() {
		var i ListEnvelopesByConversationRow
		if err := rows.Scan(
			&i.ID,
			&i.TargetProfileID,
			&i.SenderProfileID,
			&i.SenderUserID,
			&i.Kind,
			&i.Status,
			&i.Message,
			&i.Properties,
			&i.AcceptedAt,
			&i.RejectedAt,
			&i.RevokedAt,
			&i.RedeemedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ConversationID,
			&i.ReplyToID,
			&i.SenderProfileSlug,
			&i.SenderProfileTitle,
			&i.SenderProfilePictureURI,
			&i.SenderProfileKind,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMailboxEnvelopesByTargetProfileID = `-- name: ListMailboxEnvelopesByTargetProfileID :many
SELECT
  me.id, me.target_profile_id, me.sender_profile_id, me.sender_user_id, me.kind, me.status, me.message, me.properties, me.accepted_at, me.rejected_at, me.revoked_at, me.redeemed_at, me.created_at, me.updated_at, me.deleted_at, me.conversation_id, me.reply_to_id,
  sp.slug AS sender_profile_slug,
  COALESCE(spt.title, '') AS sender_profile_title,
  sp.profile_picture_uri AS sender_profile_picture_uri,
  sp.kind AS sender_profile_kind
FROM "mailbox_envelope" me
  LEFT JOIN "profile" sp ON sp.id = me.sender_profile_id AND sp.deleted_at IS NULL
  LEFT JOIN "profile_tx" spt ON spt.profile_id = sp.id AND spt.locale_code = sp.default_locale
WHERE me.target_profile_id = $1
  AND me.deleted_at IS NULL
  AND ($2::TEXT IS NULL OR me.status = $2)
ORDER BY me.created_at DESC
LIMIT $3
`

type ListMailboxEnvelopesByTargetProfileIDParams struct {
	TargetProfileID string         `db:"target_profile_id" json:"target_profile_id"`
	StatusFilter    sql.NullString `db:"status_filter" json:"status_filter"`
	LimitCount      int32          `db:"limit_count" json:"limit_count"`
}

type ListMailboxEnvelopesByTargetProfileIDRow struct {
	ID                      string                `db:"id" json:"id"`
	TargetProfileID         string                `db:"target_profile_id" json:"target_profile_id"`
	SenderProfileID         sql.NullString        `db:"sender_profile_id" json:"sender_profile_id"`
	SenderUserID            sql.NullString        `db:"sender_user_id" json:"sender_user_id"`
	Kind                    string                `db:"kind" json:"kind"`
	Status                  string                `db:"status" json:"status"`
	Message                 sql.NullString        `db:"message" json:"message"`
	Properties              pqtype.NullRawMessage `db:"properties" json:"properties"`
	AcceptedAt              sql.NullTime          `db:"accepted_at" json:"accepted_at"`
	RejectedAt              sql.NullTime          `db:"rejected_at" json:"rejected_at"`
	RevokedAt               sql.NullTime          `db:"revoked_at" json:"revoked_at"`
	RedeemedAt              sql.NullTime          `db:"redeemed_at" json:"redeemed_at"`
	CreatedAt               time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt               sql.NullTime          `db:"updated_at" json:"updated_at"`
	DeletedAt               sql.NullTime          `db:"deleted_at" json:"deleted_at"`
	ConversationID          string                `db:"conversation_id" json:"conversation_id"`
	ReplyToID               sql.NullString        `db:"reply_to_id" json:"reply_to_id"`
	SenderProfileSlug       sql.NullString        `db:"sender_profile_slug" json:"sender_profile_slug"`
	SenderProfileTitle      string                `db:"sender_profile_title" json:"sender_profile_title"`
	SenderProfilePictureURI sql.NullString        `db:"sender_profile_picture_uri" json:"sender_profile_picture_uri"`
	SenderProfileKind       sql.NullString        `db:"sender_profile_kind" json:"sender_profile_kind"`
}

// ListMailboxEnvelopesByTargetProfileID
//
//	SELECT
//	  me.id, me.target_profile_id, me.sender_profile_id, me.sender_user_id, me.kind, me.status, me.message, me.properties, me.accepted_at, me.rejected_at, me.revoked_at, me.redeemed_at, me.created_at, me.updated_at, me.deleted_at, me.conversation_id, me.reply_to_id,
//	  sp.slug AS sender_profile_slug,
//	  COALESCE(spt.title, '') AS sender_profile_title,
//	  sp.profile_picture_uri AS sender_profile_picture_uri,
//	  sp.kind AS sender_profile_kind
//	FROM "mailbox_envelope" me
//	  LEFT JOIN "profile" sp ON sp.id = me.sender_profile_id AND sp.deleted_at IS NULL
//	  LEFT JOIN "profile_tx" spt ON spt.profile_id = sp.id AND spt.locale_code = sp.default_locale
//	WHERE me.target_profile_id = $1
//	  AND me.deleted_at IS NULL
//	  AND ($2::TEXT IS NULL OR me.status = $2)
//	ORDER BY me.created_at DESC
//	LIMIT $3
func (q *Queries) ListMailboxEnvelopesByTargetProfileID(ctx context.Context, arg ListMailboxEnvelopesByTargetProfileIDParams) ([]*ListMailboxEnvelopesByTargetProfileIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listMailboxEnvelopesByTargetProfileID, arg.TargetProfileID, arg.StatusFilter, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMailboxEnvelopesByTargetProfileIDRow{}
	for rows.Next() {
		var i ListMailboxEnvelopesByTargetProfileIDRow
		if err := rows.Scan(
			&i.ID,
			&i.TargetProfileID,
			&i.SenderProfileID,
			&i.SenderUserID,
			&i.Kind,
			&i.Status,
			&i.Message,
			&i.Properties,
			&i.AcceptedAt,
			&i.RejectedAt,
			&i.RevokedAt,
			&i.RedeemedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ConversationID,
			&i.ReplyToID,
			&i.SenderProfileSlug,
			&i.SenderProfileTitle,
			&i.SenderProfilePictureURI,
			&i.SenderProfileKind,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMailboxParticipants = `-- name: ListMailboxParticipants :many
SELECT
  mp.id, mp.conversation_id, mp.profile_id, mp.last_read_at, mp.is_archived, mp.joined_at, mp.left_at,
  p.slug AS profile_slug,
  COALESCE(pt.title, '') AS profile_title,
  p.profile_picture_uri AS profile_picture_uri,
  p.kind AS profile_kind
FROM "mailbox_participant" mp
  INNER JOIN "profile" p ON p.id = mp.profile_id AND p.deleted_at IS NULL
  LEFT JOIN "profile_tx" pt ON pt.profile_id = p.id AND pt.locale_code = p.default_locale
WHERE mp.conversation_id = $1
  AND mp.left_at IS NULL
ORDER BY mp.joined_at, mp.id
`

type ListMailboxParticipantsParams struct {
	ConversationID string `db:"conversation_id" json:"conversation_id"`
}

type ListMailboxParticipantsRow struct {
	ID                string         `db:"id" json:"id"`
	ConversationID    string         `db:"conversation_id" json:"conversation_id"`
	ProfileID         string         `db:"profile_id" json:"profile_id"`
	LastReadAt        sql.NullTime   `db:"last_read_at" json:"last_read_at"`
	IsArchived        bool           `db:"is_archived" json:"is_archived"`
	JoinedAt          time.Time      `db:"joined_at" json:"joined_at"`
	LeftAt            sql.NullTime   `db:"left_at" json:"left_at"`
	ProfileSlug       string         `db:"profile_slug" json:"profile_slug"`
	ProfileTitle      string         `db:"profile_title" json:"profile_title"`
	ProfilePictureURI sql.NullString `db:"profile_picture_uri" json:"profile_picture_uri"`
	ProfileKind       string         `db:"profile_kind" json:"profile_kind"`
}

// ListMailboxParticipants
//
//	SELECT
//	  mp.id, mp.conversation_id, mp.profile_id, mp.last_read_at, mp.is_archived, mp.joined_at, mp.left_at,
//	  p.slug AS profile_slug,
//	  COALESCE(pt.title, '') AS profile_title,
//	  p.profile_picture_uri AS profile_picture_uri,
//	  p.kind AS profile_kind
//	FROM "mailbox_participant" mp
//	  INNER JOIN "profile" p ON p.id = mp.profile_id AND p.deleted_at IS NULL
//	  LEFT JOIN "profile_tx" pt ON pt.profile_id = p.id AND pt.locale_code = p.default_locale
//	WHERE mp.conversation_id = $1
//	  AND mp.left_at IS NULL
//	ORDER BY mp.joined_at, mp.id
func (q *Queries) ListMailboxParticipants(ctx context.Context, arg ListMailboxParticipantsParams) ([]*ListMailboxParticipantsRow, error) {
	rows, err := q.db.QueryContext(ctx, listMailboxParticipants, arg.ConversationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListMailboxParticipantsRow{}
	for rows.Next() {
		var i ListMailboxParticipantsRow
		if err := rows.Scan(
			&i.ID,
			&i.ConversationID,
			&i.ProfileID,
			&i.LastReadAt,
			&i.IsArchived,
			&i.JoinedAt,
			&i.LeftAt,
			&i.ProfileSlug,
			&i.ProfileTitle,
			&i.ProfilePictureURI,
			&i.ProfileKind,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listReactionsByEnvelope = `-- name: ListReactionsByEnvelope :many
SELECT
  mr.id, mr.envelope_id, mr.profile_id, mr.emoji, mr.created_at,
  p.slug AS profile_slug,
  COALESCE(pt.title, '') AS profile_title
FROM "mailbox_reaction" mr
  INNER JOIN "profile" p ON p.id = mr.profile_id AND p.deleted_at IS NULL
  LEFT JOIN "profile_tx" pt ON pt.profile_id = p.id AND pt.locale_code = p.default_locale
WHERE mr.envelope_id = $1
ORDER BY mr.created_at
`

type ListReactionsByEnvelopeParams struct {
	EnvelopeID string `db:"envelope_id" json:"envelope_id"`
}

type ListReactionsByEnvelopeRow struct {
	ID           string    `db:"id" json:"id"`
	EnvelopeID   string    `db:"envelope_id" json:"envelope_id"`
	ProfileID    string    `db:"profile_id" json:"profile_id"`
	Emoji        string    `db:"emoji" json:"emoji"`
	CreatedAt    time.Time `db:"created_at" json:"created_at"`
	ProfileSlug  string    `db:"profile_slug" json:"profile_slug"`
	ProfileTitle string    `db:"profile_title" json:"profile_title"`
}

// ListReactionsByEnvelope
//
//	SELECT
//	  mr.id, mr.envelope_id, mr.profile_id, mr.emoji, mr.created_at,
//	  p.slug AS profile_slug,
//	  COALESCE(pt.title, '') AS profile_title
//	FROM "mailbox_reaction" mr
//	  INNER JOIN "profile" p ON p.id = mr.profile_id AND p.deleted_at IS NULL
//	  LEFT JOIN "profile_tx" pt ON pt.profile_id = p.id AND pt.locale_code = p.default_locale
//	WHERE mr.envelope_id = $1
//	ORDER BY mr.created_at
func (q *Queries) ListReactionsByEnvelope(ctx context.Context, arg ListReactionsByEnvelopeParams) ([]*ListReactionsByEnvelopeRow, error) {
	rows, err := q.db.QueryContext(ctx, listReactionsByEnvelope, arg.EnvelopeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListReactionsByEnvelopeRow{}
	for rows.Next() {
		var i ListReactionsByEnvelopeRow
		if err := rows.Scan(
			&i.ID,
			&i.EnvelopeID,
			&i.ProfileID,
			&i.Emoji,
			&i.CreatedAt,
			&i.ProfileSlug,
			&i.ProfileTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeMailboxReaction = `-- name: RemoveMailboxReaction :execrows
DELETE FROM "mailbox_reaction"
WHERE envelope_id = $1
  AND profile_id = $2
  AND emoji = $3
`

type RemoveMailboxReactionParams struct {
	EnvelopeID string `db:"envelope_id" json:"envelope_id"`
	ProfileID  string `db:"profile_id" json:"profile_id"`
	Emoji      string `db:"emoji" json:"emoji"`
}

// RemoveMailboxReaction
//
//	DELETE FROM "mailbox_reaction"
//	WHERE envelope_id = $1
//	  AND profile_id = $2
//	  AND emoji = $3
func (q *Queries) RemoveMailboxReaction(ctx context.Context, arg RemoveMailboxReactionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeMailboxReaction, arg.EnvelopeID, arg.ProfileID, arg.Emoji)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setParticipantArchived = `-- name: SetParticipantArchived :exec
UPDATE "mailbox_participant"
SET is_archived = $1
WHERE conversation_id = $2
  AND profile_id = $3
  AND left_at IS NULL
`

type SetParticipantArchivedParams struct {
	IsArchived     bool   `db:"is_archived" json:"is_archived"`
	ConversationID string `db:"conversation_id" json:"conversation_id"`
	ProfileID      string `db:"profile_id" json:"profile_id"`
}

// SetParticipantArchived
//
//	UPDATE "mailbox_participant"
//	SET is_archived = $1
//	WHERE conversation_id = $2
//	  AND profile_id = $3
//	  AND left_at IS NULL
func (q *Queries) SetParticipantArchived(ctx context.Context, arg SetParticipantArchivedParams) error {
	_, err := q.db.ExecContext(ctx, setParticipantArchived, arg.IsArchived, arg.ConversationID, arg.ProfileID)
	return err
}

const updateConversationTimestamp = `-- name: UpdateConversationTimestamp :exec
UPDATE "mailbox_conversation"
SET updated_at = NOW()
WHERE id = $1
`

type UpdateConversationTimestampParams struct {
	ID string `db:"id" json:"id"`
}

// UpdateConversationTimestamp
//
//	UPDATE "mailbox_conversation"
//	SET updated_at = NOW()
//	WHERE id = $1
func (q *Queries) UpdateConversationTimestamp(ctx context.Context, arg UpdateConversationTimestampParams) error {
	_, err := q.db.ExecContext(ctx, updateConversationTimestamp, arg.ID)
	return err
}

const updateMailboxEnvelopeProperties = `-- name: UpdateMailboxEnvelopeProperties :exec
UPDATE "mailbox_envelope"
SET properties = $1,
    updated_at = NOW()
WHERE id = $2
  AND deleted_at IS NULL
`

type UpdateMailboxEnvelopePropertiesParams struct {
	Properties pqtype.NullRawMessage `db:"properties" json:"properties"`
	ID         string                `db:"id" json:"id"`
}

// UpdateMailboxEnvelopeProperties
//
//	UPDATE "mailbox_envelope"
//	SET properties = $1,
//	    updated_at = NOW()
//	WHERE id = $2
//	  AND deleted_at IS NULL
func (q *Queries) UpdateMailboxEnvelopeProperties(ctx context.Context, arg UpdateMailboxEnvelopePropertiesParams) error {
	_, err := q.db.ExecContext(ctx, updateMailboxEnvelopeProperties, arg.Properties, arg.ID)
	return err
}

const updateMailboxEnvelopeStatusToAccepted = `-- name: UpdateMailboxEnvelopeStatusToAccepted :execrows
UPDATE "mailbox_envelope"
SET status = 'accepted',
    accepted_at = $1,
    updated_at = $1
WHERE id = $2
  AND status = 'pending'
  AND deleted_at IS NULL
`

type UpdateMailboxEnvelopeStatusToAcceptedParams struct {
	Now sql.NullTime `db:"now" json:"now"`
	ID  string       `db:"id" json:"id"`
}

// UpdateMailboxEnvelopeStatusToAccepted
//
//	UPDATE "mailbox_envelope"
//	SET status = 'accepted',
//	    accepted_at = $1,
//	    updated_at = $1
//	WHERE id = $2
//	  AND status = 'pending'
//	  AND deleted_at IS NULL
func (q *Queries) UpdateMailboxEnvelopeStatusToAccepted(ctx context.Context, arg UpdateMailboxEnvelopeStatusToAcceptedParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateMailboxEnvelopeStatusToAccepted, arg.Now, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateMailboxEnvelopeStatusToRedeemed = `-- name: UpdateMailboxEnvelopeStatusToRedeemed :execrows
UPDATE "mailbox_envelope"
SET status = 'redeemed',
    redeemed_at = $1,
    updated_at = $1
WHERE id = $2
  AND status = 'accepted'
  AND deleted_at IS NULL
`

type UpdateMailboxEnvelopeStatusToRedeemedParams struct {
	Now sql.NullTime `db:"now" json:"now"`
	ID  string       `db:"id" json:"id"`
}

// UpdateMailboxEnvelopeStatusToRedeemed
//
//	UPDATE "mailbox_envelope"
//	SET status = 'redeemed',
//	    redeemed_at = $1,
//	    updated_at = $1
//	WHERE id = $2
//	  AND status = 'accepted'
//	  AND deleted_at IS NULL
func (q *Queries) UpdateMailboxEnvelopeStatusToRedeemed(ctx context.Context, arg UpdateMailboxEnvelopeStatusToRedeemedParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateMailboxEnvelopeStatusToRedeemed, arg.Now, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateMailboxEnvelopeStatusToRejected = `-- name: UpdateMailboxEnvelopeStatusToRejected :execrows
UPDATE "mailbox_envelope"
SET status = 'rejected',
    rejected_at = $1,
    updated_at = $1
WHERE id = $2
  AND status = 'pending'
  AND deleted_at IS NULL
`

type UpdateMailboxEnvelopeStatusToRejectedParams struct {
	Now sql.NullTime `db:"now" json:"now"`
	ID  string       `db:"id" json:"id"`
}

// UpdateMailboxEnvelopeStatusToRejected
//
//	UPDATE "mailbox_envelope"
//	SET status = 'rejected',
//	    rejected_at = $1,
//	    updated_at = $1
//	WHERE id = $2
//	  AND status = 'pending'
//	  AND deleted_at IS NULL
func (q *Queries) UpdateMailboxEnvelopeStatusToRejected(ctx context.Context, arg UpdateMailboxEnvelopeStatusToRejectedParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateMailboxEnvelopeStatusToRejected, arg.Now, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateMailboxEnvelopeStatusToRevoked = `-- name: UpdateMailboxEnvelopeStatusToRevoked :execrows
UPDATE "mailbox_envelope"
SET status = 'revoked',
    revoked_at = $1,
    updated_at = $1
WHERE id = $2
  AND status = 'pending'
  AND deleted_at IS NULL
`

type UpdateMailboxEnvelopeStatusToRevokedParams struct {
	Now sql.NullTime `db:"now" json:"now"`
	ID  string       `db:"id" json:"id"`
}

// UpdateMailboxEnvelopeStatusToRevoked
//
//	UPDATE "mailbox_envelope"
//	SET status = 'revoked',
//	    revoked_at = $1,
//	    updated_at = $1
//	WHERE id = $2
//	  AND status = 'pending'
//	  AND deleted_at IS NULL
func (q *Queries) UpdateMailboxEnvelopeStatusToRevoked(ctx context.Context, arg UpdateMailboxEnvelopeStatusToRevokedParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateMailboxEnvelopeStatusToRevoked, arg.Now, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateParticipantReadCursor = `-- name: UpdateParticipantReadCursor :exec
UPDATE "mailbox_participant"
SET last_read_at = NOW()
WHERE conversation_id = $1
  AND profile_id = $2
  AND left_at IS NULL
`

type UpdateParticipantReadCursorParams struct {
	ConversationID string `db:"conversation_id" json:"conversation_id"`
	ProfileID      string `db:"profile_id" json:"profile_id"`
}

// UpdateParticipantReadCursor
//
//	UPDATE "mailbox_participant"
//	SET last_read_at = NOW()
//	WHERE conversation_id = $1
//	  AND profile_id = $2
//	  AND left_at IS NULL
func (q *Queries) UpdateParticipantReadCursor(ctx context.Context, arg UpdateParticipantReadCursorParams) error {
	_, err := q.db.ExecContext(ctx, updateParticipantReadCursor, arg.ConversationID, arg.ProfileID)
	return err
}
