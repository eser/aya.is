// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: story_interactions.sql

package storage

import (
	"context"
	"database/sql"
	"time"
)

const countStoryInteractionsByKind = `-- name: CountStoryInteractionsByKind :many
SELECT kind, COUNT(*) as count
FROM "story_interaction"
WHERE story_id = $1
  AND deleted_at IS NULL
GROUP BY kind
`

type CountStoryInteractionsByKindParams struct {
	StoryID string `db:"story_id" json:"story_id"`
}

type CountStoryInteractionsByKindRow struct {
	Kind  string `db:"kind" json:"kind"`
	Count int64  `db:"count" json:"count"`
}

// Returns interaction counts grouped by kind for a story.
//
//	SELECT kind, COUNT(*) as count
//	FROM "story_interaction"
//	WHERE story_id = $1
//	  AND deleted_at IS NULL
//	GROUP BY kind
func (q *Queries) CountStoryInteractionsByKind(ctx context.Context, arg CountStoryInteractionsByKindParams) ([]*CountStoryInteractionsByKindRow, error) {
	rows, err := q.db.QueryContext(ctx, countStoryInteractionsByKind, arg.StoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*CountStoryInteractionsByKindRow{}
	for rows.Next() {
		var i CountStoryInteractionsByKindRow
		if err := rows.Scan(&i.Kind, &i.Count); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStoryInteraction = `-- name: GetStoryInteraction :one
SELECT id, story_id, profile_id, kind, created_at, updated_at, deleted_at FROM "story_interaction"
WHERE story_id = $1
  AND profile_id = $2
  AND kind = $3
  AND deleted_at IS NULL
LIMIT 1
`

type GetStoryInteractionParams struct {
	StoryID   string `db:"story_id" json:"story_id"`
	ProfileID string `db:"profile_id" json:"profile_id"`
	Kind      string `db:"kind" json:"kind"`
}

// GetStoryInteraction
//
//	SELECT id, story_id, profile_id, kind, created_at, updated_at, deleted_at FROM "story_interaction"
//	WHERE story_id = $1
//	  AND profile_id = $2
//	  AND kind = $3
//	  AND deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetStoryInteraction(ctx context.Context, arg GetStoryInteractionParams) (*StoryInteraction, error) {
	row := q.db.QueryRowContext(ctx, getStoryInteraction, arg.StoryID, arg.ProfileID, arg.Kind)
	var i StoryInteraction
	err := row.Scan(
		&i.ID,
		&i.StoryID,
		&i.ProfileID,
		&i.Kind,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const listStoryInteractions = `-- name: ListStoryInteractions :many
SELECT
  si.id,
  si.story_id,
  si.profile_id,
  si.kind,
  si.created_at,
  p.slug as profile_slug,
  pt.title as profile_title,
  p.profile_picture_uri,
  p.kind as profile_kind
FROM "story_interaction" si
  INNER JOIN "profile" p ON p.id = si.profile_id
    AND p.deleted_at IS NULL
  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
    AND pt.locale_code = (
      SELECT ptx.locale_code FROM "profile_tx" ptx
      WHERE ptx.profile_id = p.id
      ORDER BY CASE WHEN ptx.locale_code = $1 THEN 0 ELSE 1 END
      LIMIT 1
    )
WHERE si.story_id = $2
  AND si.deleted_at IS NULL
  AND ($3::TEXT IS NULL OR si.kind = $3::TEXT)
ORDER BY si.created_at
`

type ListStoryInteractionsParams struct {
	LocaleCode string         `db:"locale_code" json:"locale_code"`
	StoryID    string         `db:"story_id" json:"story_id"`
	FilterKind sql.NullString `db:"filter_kind" json:"filter_kind"`
}

type ListStoryInteractionsRow struct {
	ID                string         `db:"id" json:"id"`
	StoryID           string         `db:"story_id" json:"story_id"`
	ProfileID         string         `db:"profile_id" json:"profile_id"`
	Kind              string         `db:"kind" json:"kind"`
	CreatedAt         time.Time      `db:"created_at" json:"created_at"`
	ProfileSlug       string         `db:"profile_slug" json:"profile_slug"`
	ProfileTitle      string         `db:"profile_title" json:"profile_title"`
	ProfilePictureURI sql.NullString `db:"profile_picture_uri" json:"profile_picture_uri"`
	ProfileKind       string         `db:"profile_kind" json:"profile_kind"`
}

// Lists interactions on a story with profile info, optionally filtered by kind.
//
//	SELECT
//	  si.id,
//	  si.story_id,
//	  si.profile_id,
//	  si.kind,
//	  si.created_at,
//	  p.slug as profile_slug,
//	  pt.title as profile_title,
//	  p.profile_picture_uri,
//	  p.kind as profile_kind
//	FROM "story_interaction" si
//	  INNER JOIN "profile" p ON p.id = si.profile_id
//	    AND p.deleted_at IS NULL
//	  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
//	    AND pt.locale_code = (
//	      SELECT ptx.locale_code FROM "profile_tx" ptx
//	      WHERE ptx.profile_id = p.id
//	      ORDER BY CASE WHEN ptx.locale_code = $1 THEN 0 ELSE 1 END
//	      LIMIT 1
//	    )
//	WHERE si.story_id = $2
//	  AND si.deleted_at IS NULL
//	  AND ($3::TEXT IS NULL OR si.kind = $3::TEXT)
//	ORDER BY si.created_at
func (q *Queries) ListStoryInteractions(ctx context.Context, arg ListStoryInteractionsParams) ([]*ListStoryInteractionsRow, error) {
	rows, err := q.db.QueryContext(ctx, listStoryInteractions, arg.LocaleCode, arg.StoryID, arg.FilterKind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListStoryInteractionsRow{}
	for rows.Next() {
		var i ListStoryInteractionsRow
		if err := rows.Scan(
			&i.ID,
			&i.StoryID,
			&i.ProfileID,
			&i.Kind,
			&i.CreatedAt,
			&i.ProfileSlug,
			&i.ProfileTitle,
			&i.ProfilePictureURI,
			&i.ProfileKind,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStoryInteractionsForProfile = `-- name: ListStoryInteractionsForProfile :many
SELECT id, story_id, profile_id, kind, created_at, updated_at, deleted_at FROM "story_interaction"
WHERE story_id = $1
  AND profile_id = $2
  AND deleted_at IS NULL
ORDER BY created_at
`

type ListStoryInteractionsForProfileParams struct {
	StoryID   string `db:"story_id" json:"story_id"`
	ProfileID string `db:"profile_id" json:"profile_id"`
}

// Returns all active interactions a profile has on a specific story.
//
//	SELECT id, story_id, profile_id, kind, created_at, updated_at, deleted_at FROM "story_interaction"
//	WHERE story_id = $1
//	  AND profile_id = $2
//	  AND deleted_at IS NULL
//	ORDER BY created_at
func (q *Queries) ListStoryInteractionsForProfile(ctx context.Context, arg ListStoryInteractionsForProfileParams) ([]*StoryInteraction, error) {
	rows, err := q.db.QueryContext(ctx, listStoryInteractionsForProfile, arg.StoryID, arg.ProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*StoryInteraction{}
	for rows.Next() {
		var i StoryInteraction
		if err := rows.Scan(
			&i.ID,
			&i.StoryID,
			&i.ProfileID,
			&i.Kind,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeStoryInteraction = `-- name: RemoveStoryInteraction :execrows
UPDATE "story_interaction"
SET deleted_at = NOW()
WHERE story_id = $1
  AND profile_id = $2
  AND kind = $3
  AND deleted_at IS NULL
`

type RemoveStoryInteractionParams struct {
	StoryID   string `db:"story_id" json:"story_id"`
	ProfileID string `db:"profile_id" json:"profile_id"`
	Kind      string `db:"kind" json:"kind"`
}

// RemoveStoryInteraction
//
//	UPDATE "story_interaction"
//	SET deleted_at = NOW()
//	WHERE story_id = $1
//	  AND profile_id = $2
//	  AND kind = $3
//	  AND deleted_at IS NULL
func (q *Queries) RemoveStoryInteraction(ctx context.Context, arg RemoveStoryInteractionParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeStoryInteraction, arg.StoryID, arg.ProfileID, arg.Kind)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const removeStoryInteractionsByKinds = `-- name: RemoveStoryInteractionsByKinds :execrows
UPDATE "story_interaction"
SET deleted_at = NOW()
WHERE story_id = $1
  AND profile_id = $2
  AND kind = ANY(string_to_array($3, ','))
  AND deleted_at IS NULL
`

type RemoveStoryInteractionsByKindsParams struct {
	StoryID   string `db:"story_id" json:"story_id"`
	ProfileID string `db:"profile_id" json:"profile_id"`
	Kinds     string `db:"kinds" json:"kinds"`
}

// Removes all interactions matching any of the given kinds for a user on a story.
// Used to enforce mutual exclusivity for RSVP kinds.
//
//	UPDATE "story_interaction"
//	SET deleted_at = NOW()
//	WHERE story_id = $1
//	  AND profile_id = $2
//	  AND kind = ANY(string_to_array($3, ','))
//	  AND deleted_at IS NULL
func (q *Queries) RemoveStoryInteractionsByKinds(ctx context.Context, arg RemoveStoryInteractionsByKindsParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeStoryInteractionsByKinds, arg.StoryID, arg.ProfileID, arg.Kinds)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const upsertStoryInteraction = `-- name: UpsertStoryInteraction :one
INSERT INTO "story_interaction" (
  id, story_id, profile_id, kind, created_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  NOW()
) ON CONFLICT (story_id, profile_id, kind)
DO UPDATE SET updated_at = NOW()
RETURNING id, story_id, profile_id, kind, created_at, updated_at, deleted_at
`

type UpsertStoryInteractionParams struct {
	ID        string `db:"id" json:"id"`
	StoryID   string `db:"story_id" json:"story_id"`
	ProfileID string `db:"profile_id" json:"profile_id"`
	Kind      string `db:"kind" json:"kind"`
}

// UpsertStoryInteraction
//
//	INSERT INTO "story_interaction" (
//	  id, story_id, profile_id, kind, created_at
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  NOW()
//	) ON CONFLICT (story_id, profile_id, kind)
//	DO UPDATE SET updated_at = NOW()
//	RETURNING id, story_id, profile_id, kind, created_at, updated_at, deleted_at
func (q *Queries) UpsertStoryInteraction(ctx context.Context, arg UpsertStoryInteractionParams) (*StoryInteraction, error) {
	row := q.db.QueryRowContext(ctx, upsertStoryInteraction,
		arg.ID,
		arg.StoryID,
		arg.ProfileID,
		arg.Kind,
	)
	var i StoryInteraction
	err := row.Scan(
		&i.ID,
		&i.StoryID,
		&i.ProfileID,
		&i.Kind,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
