// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: story_summaries.sql

package storage

import (
	"context"
	"database/sql"
)

const getUnsummarizedPublishedStories = `-- name: GetUnsummarizedPublishedStories :many
SELECT
  st.story_id,
  RTRIM(st.locale_code) AS locale_code,
  st.title,
  st.summary,
  st.content
FROM "story_tx" st
WHERE (st.summary_ai IS NULL OR st.summary_ai = '')
  AND EXISTS (
    SELECT 1 FROM "story_publication" sp
    WHERE sp.story_id = st.story_id
      AND sp.published_at IS NOT NULL
      AND sp.deleted_at IS NULL
  )
  AND EXISTS (
    SELECT 1 FROM "story" s
    WHERE s.id = st.story_id
      AND s.deleted_at IS NULL
  )
ORDER BY st.story_id, st.locale_code
LIMIT $1
`

type GetUnsummarizedPublishedStoriesParams struct {
	MaxItems int32 `db:"max_items" json:"max_items"`
}

type GetUnsummarizedPublishedStoriesRow struct {
	StoryID    string `db:"story_id" json:"story_id"`
	LocaleCode string `db:"locale_code" json:"locale_code"`
	Title      string `db:"title" json:"title"`
	Summary    string `db:"summary" json:"summary"`
	Content    string `db:"content" json:"content"`
}

// Returns published story translations that have no AI summary yet.
//
//	SELECT
//	  st.story_id,
//	  RTRIM(st.locale_code) AS locale_code,
//	  st.title,
//	  st.summary,
//	  st.content
//	FROM "story_tx" st
//	WHERE (st.summary_ai IS NULL OR st.summary_ai = '')
//	  AND EXISTS (
//	    SELECT 1 FROM "story_publication" sp
//	    WHERE sp.story_id = st.story_id
//	      AND sp.published_at IS NOT NULL
//	      AND sp.deleted_at IS NULL
//	  )
//	  AND EXISTS (
//	    SELECT 1 FROM "story" s
//	    WHERE s.id = st.story_id
//	      AND s.deleted_at IS NULL
//	  )
//	ORDER BY st.story_id, st.locale_code
//	LIMIT $1
func (q *Queries) GetUnsummarizedPublishedStories(ctx context.Context, arg GetUnsummarizedPublishedStoriesParams) ([]*GetUnsummarizedPublishedStoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, getUnsummarizedPublishedStories, arg.MaxItems)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetUnsummarizedPublishedStoriesRow{}
	for rows.Next() {
		var i GetUnsummarizedPublishedStoriesRow
		if err := rows.Scan(
			&i.StoryID,
			&i.LocaleCode,
			&i.Title,
			&i.Summary,
			&i.Content,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertStorySummaryAI = `-- name: UpsertStorySummaryAI :exec
UPDATE "story_tx"
SET summary_ai = $1
WHERE story_id = $2
  AND locale_code = $3
`

type UpsertStorySummaryAIParams struct {
	SummaryAi  sql.NullString `db:"summary_ai" json:"summary_ai"`
	StoryID    string         `db:"story_id" json:"story_id"`
	LocaleCode string         `db:"locale_code" json:"locale_code"`
}

// Updates the AI-generated summary for a specific story translation.
//
//	UPDATE "story_tx"
//	SET summary_ai = $1
//	WHERE story_id = $2
//	  AND locale_code = $3
func (q *Queries) UpsertStorySummaryAI(ctx context.Context, arg UpsertStorySummaryAIParams) error {
	_, err := q.db.ExecContext(ctx, upsertStorySummaryAI, arg.SummaryAi, arg.StoryID, arg.LocaleCode)
	return err
}
