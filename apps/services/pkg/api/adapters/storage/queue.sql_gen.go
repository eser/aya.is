// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queue.sql

package storage

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const claimNextQueueItem = `-- name: ClaimNextQueueItem :one
WITH claimable AS (
  SELECT id FROM "queue"
  WHERE (
    (status = 'pending' AND visible_at <= NOW())
    OR (status = 'processing' AND visible_at <= NOW())
  )
  AND retry_count <= max_retries
  ORDER BY visible_at ASC
  LIMIT 1
  FOR UPDATE SKIP LOCKED
)
UPDATE "queue"
SET
  status = 'processing',
  started_at = NOW(),
  visible_at = NOW() + visibility_timeout_secs * INTERVAL '1 second',
  retry_count = retry_count + 1,
  worker_id = $1,
  updated_at = NOW()
FROM claimable
WHERE "queue".id = claimable.id
RETURNING queue.id, queue.type, queue.payload, queue.status, queue.retry_count, queue.max_retries, queue.visible_at, queue.visibility_timeout_secs, queue.started_at, queue.completed_at, queue.failed_at, queue.created_at, queue.updated_at, queue.error_message, queue.worker_id
`

type ClaimNextQueueItemParams struct {
	WorkerID sql.NullString `db:"worker_id" json:"worker_id"`
}

// CTE-based claim: atomically selects + locks + updates.
// Picks up both pending items that are due AND stale processing items
// past their visibility timeout (crash recovery built into the claim).
// Increments retry_count at claim time for crash safety.
//
//	WITH claimable AS (
//	  SELECT id FROM "queue"
//	  WHERE (
//	    (status = 'pending' AND visible_at <= NOW())
//	    OR (status = 'processing' AND visible_at <= NOW())
//	  )
//	  AND retry_count <= max_retries
//	  ORDER BY visible_at ASC
//	  LIMIT 1
//	  FOR UPDATE SKIP LOCKED
//	)
//	UPDATE "queue"
//	SET
//	  status = 'processing',
//	  started_at = NOW(),
//	  visible_at = NOW() + visibility_timeout_secs * INTERVAL '1 second',
//	  retry_count = retry_count + 1,
//	  worker_id = $1,
//	  updated_at = NOW()
//	FROM claimable
//	WHERE "queue".id = claimable.id
//	RETURNING queue.id, queue.type, queue.payload, queue.status, queue.retry_count, queue.max_retries, queue.visible_at, queue.visibility_timeout_secs, queue.started_at, queue.completed_at, queue.failed_at, queue.created_at, queue.updated_at, queue.error_message, queue.worker_id
func (q *Queries) ClaimNextQueueItem(ctx context.Context, arg ClaimNextQueueItemParams) (*Queue, error) {
	row := q.db.QueryRowContext(ctx, claimNextQueueItem, arg.WorkerID)
	var i Queue
	err := row.Scan(
		&i.ID,
		&i.Type,
		&i.Payload,
		&i.Status,
		&i.RetryCount,
		&i.MaxRetries,
		&i.VisibleAt,
		&i.VisibilityTimeoutSecs,
		&i.StartedAt,
		&i.CompletedAt,
		&i.FailedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ErrorMessage,
		&i.WorkerID,
	)
	return &i, err
}

const completeQueueItem = `-- name: CompleteQueueItem :execrows
UPDATE "queue"
SET
  status = 'completed',
  completed_at = NOW(),
  updated_at = NOW()
WHERE id = $1
  AND status = 'processing'
  AND worker_id = $2
`

type CompleteQueueItemParams struct {
	ID       string         `db:"id" json:"id"`
	WorkerID sql.NullString `db:"worker_id" json:"worker_id"`
}

// Worker ID check prevents a timed-out worker from completing
// a job that was already re-claimed by another worker.
//
//	UPDATE "queue"
//	SET
//	  status = 'completed',
//	  completed_at = NOW(),
//	  updated_at = NOW()
//	WHERE id = $1
//	  AND status = 'processing'
//	  AND worker_id = $2
func (q *Queries) CompleteQueueItem(ctx context.Context, arg CompleteQueueItemParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, completeQueueItem, arg.ID, arg.WorkerID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const enqueueQueueItem = `-- name: EnqueueQueueItem :exec
INSERT INTO "queue" (
  id, type, payload, status, max_retries,
  visibility_timeout_secs, visible_at, created_at
) VALUES (
  $1,
  $2,
  $3,
  'pending',
  $4,
  $5,
  $6,
  NOW()
)
`

type EnqueueQueueItemParams struct {
	ID                    string          `db:"id" json:"id"`
	Type                  string          `db:"type" json:"type"`
	Payload               json.RawMessage `db:"payload" json:"payload"`
	MaxRetries            int32           `db:"max_retries" json:"max_retries"`
	VisibilityTimeoutSecs int32           `db:"visibility_timeout_secs" json:"visibility_timeout_secs"`
	VisibleAt             time.Time       `db:"visible_at" json:"visible_at"`
}

// EnqueueQueueItem
//
//	INSERT INTO "queue" (
//	  id, type, payload, status, max_retries,
//	  visibility_timeout_secs, visible_at, created_at
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  'pending',
//	  $4,
//	  $5,
//	  $6,
//	  NOW()
//	)
func (q *Queries) EnqueueQueueItem(ctx context.Context, arg EnqueueQueueItemParams) error {
	_, err := q.db.ExecContext(ctx, enqueueQueueItem,
		arg.ID,
		arg.Type,
		arg.Payload,
		arg.MaxRetries,
		arg.VisibilityTimeoutSecs,
		arg.VisibleAt,
	)
	return err
}

const failQueueItem = `-- name: FailQueueItem :execrows
UPDATE "queue"
SET
  status = CASE
    WHEN retry_count >= max_retries THEN 'dead'
    ELSE 'pending'
  END,
  error_message = $1,
  failed_at = NOW(),
  visible_at = CASE
    WHEN retry_count >= max_retries THEN visible_at
    ELSE NOW() + $2::INTEGER * INTERVAL '1 second'
  END,
  worker_id = NULL,
  updated_at = NOW()
WHERE id = $3
  AND status = 'processing'
  AND worker_id = $4
`

type FailQueueItemParams struct {
	ErrorMessage   sql.NullString `db:"error_message" json:"error_message"`
	BackoffSeconds int32          `db:"backoff_seconds" json:"backoff_seconds"`
	ID             string         `db:"id" json:"id"`
	WorkerID       sql.NullString `db:"worker_id" json:"worker_id"`
}

// On failure: if retries exhausted -> dead, otherwise -> pending with backoff.
// Worker ID check prevents stale workers from interfering.
//
//	UPDATE "queue"
//	SET
//	  status = CASE
//	    WHEN retry_count >= max_retries THEN 'dead'
//	    ELSE 'pending'
//	  END,
//	  error_message = $1,
//	  failed_at = NOW(),
//	  visible_at = CASE
//	    WHEN retry_count >= max_retries THEN visible_at
//	    ELSE NOW() + $2::INTEGER * INTERVAL '1 second'
//	  END,
//	  worker_id = NULL,
//	  updated_at = NOW()
//	WHERE id = $3
//	  AND status = 'processing'
//	  AND worker_id = $4
func (q *Queries) FailQueueItem(ctx context.Context, arg FailQueueItemParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, failQueueItem,
		arg.ErrorMessage,
		arg.BackoffSeconds,
		arg.ID,
		arg.WorkerID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const listQueueItemsByType = `-- name: ListQueueItemsByType :many
SELECT id, type, payload, status, retry_count, max_retries, visible_at, visibility_timeout_secs, started_at, completed_at, failed_at, created_at, updated_at, error_message, worker_id
FROM "queue"
WHERE type = $1
ORDER BY created_at DESC
LIMIT $2
`

type ListQueueItemsByTypeParams struct {
	Type       string `db:"type" json:"type"`
	LimitCount int32  `db:"limit_count" json:"limit_count"`
}

// ListQueueItemsByType
//
//	SELECT id, type, payload, status, retry_count, max_retries, visible_at, visibility_timeout_secs, started_at, completed_at, failed_at, created_at, updated_at, error_message, worker_id
//	FROM "queue"
//	WHERE type = $1
//	ORDER BY created_at DESC
//	LIMIT $2
func (q *Queries) ListQueueItemsByType(ctx context.Context, arg ListQueueItemsByTypeParams) ([]*Queue, error) {
	rows, err := q.db.QueryContext(ctx, listQueueItemsByType, arg.Type, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*Queue{}
	for rows.Next() {
		var i Queue
		if err := rows.Scan(
			&i.ID,
			&i.Type,
			&i.Payload,
			&i.Status,
			&i.RetryCount,
			&i.MaxRetries,
			&i.VisibleAt,
			&i.VisibilityTimeoutSecs,
			&i.StartedAt,
			&i.CompletedAt,
			&i.FailedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ErrorMessage,
			&i.WorkerID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
