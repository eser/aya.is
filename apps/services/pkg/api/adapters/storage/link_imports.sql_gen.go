// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: link_imports.sql

package storage

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const createLinkImport = `-- name: CreateLinkImport :exec
INSERT INTO "profile_link_import" (id, profile_link_id, remote_id, properties, created_at)
VALUES ($1, $2, $3, $4, NOW())
`

type CreateLinkImportParams struct {
	ID            string                `db:"id" json:"id"`
	ProfileLinkID string                `db:"profile_link_id" json:"profile_link_id"`
	RemoteID      sql.NullString        `db:"remote_id" json:"remote_id"`
	Properties    pqtype.NullRawMessage `db:"properties" json:"properties"`
}

// CreateLinkImport
//
//	INSERT INTO "profile_link_import" (id, profile_link_id, remote_id, properties, created_at)
//	VALUES ($1, $2, $3, $4, NOW())
func (q *Queries) CreateLinkImport(ctx context.Context, arg CreateLinkImportParams) error {
	_, err := q.db.ExecContext(ctx, createLinkImport,
		arg.ID,
		arg.ProfileLinkID,
		arg.RemoteID,
		arg.Properties,
	)
	return err
}

const getLatestImportByLinkID = `-- name: GetLatestImportByLinkID :one
SELECT id, profile_link_id, remote_id, properties, created_at, updated_at, deleted_at
FROM "profile_link_import"
WHERE profile_link_id = $1
  AND deleted_at IS NULL
ORDER BY created_at DESC
LIMIT 1
`

type GetLatestImportByLinkIDParams struct {
	ProfileLinkID string `db:"profile_link_id" json:"profile_link_id"`
}

// GetLatestImportByLinkID
//
//	SELECT id, profile_link_id, remote_id, properties, created_at, updated_at, deleted_at
//	FROM "profile_link_import"
//	WHERE profile_link_id = $1
//	  AND deleted_at IS NULL
//	ORDER BY created_at DESC
//	LIMIT 1
func (q *Queries) GetLatestImportByLinkID(ctx context.Context, arg GetLatestImportByLinkIDParams) (*ProfileLinkImport, error) {
	row := q.db.QueryRowContext(ctx, getLatestImportByLinkID, arg.ProfileLinkID)
	var i ProfileLinkImport
	err := row.Scan(
		&i.ID,
		&i.ProfileLinkID,
		&i.RemoteID,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getLinkImportByRemoteID = `-- name: GetLinkImportByRemoteID :one
SELECT id, profile_link_id, remote_id, properties, created_at, updated_at, deleted_at
FROM "profile_link_import"
WHERE profile_link_id = $1
  AND remote_id = $2
LIMIT 1
`

type GetLinkImportByRemoteIDParams struct {
	ProfileLinkID string         `db:"profile_link_id" json:"profile_link_id"`
	RemoteID      sql.NullString `db:"remote_id" json:"remote_id"`
}

// GetLinkImportByRemoteID
//
//	SELECT id, profile_link_id, remote_id, properties, created_at, updated_at, deleted_at
//	FROM "profile_link_import"
//	WHERE profile_link_id = $1
//	  AND remote_id = $2
//	LIMIT 1
func (q *Queries) GetLinkImportByRemoteID(ctx context.Context, arg GetLinkImportByRemoteIDParams) (*ProfileLinkImport, error) {
	row := q.db.QueryRowContext(ctx, getLinkImportByRemoteID, arg.ProfileLinkID, arg.RemoteID)
	var i ProfileLinkImport
	err := row.Scan(
		&i.ID,
		&i.ProfileLinkID,
		&i.RemoteID,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const listImportsWithExistingStories = `-- name: ListImportsWithExistingStories :many
SELECT
  pli.id,
  pli.profile_link_id,
  pli.remote_id,
  pli.properties,
  pli.created_at,
  pl.profile_id,
  COALESCE(NULLIF(TRIM(p.default_locale), ''), 'en')::TEXT AS profile_default_locale,
  s.id AS story_id,
  sp.id AS publication_id
FROM "profile_link_import" pli
  INNER JOIN "profile_link" pl ON pl.id = pli.profile_link_id
  INNER JOIN "profile" p ON p.id = pl.profile_id
  INNER JOIN "story" s ON s.author_profile_id = pl.profile_id
    AND s.is_managed = TRUE
    AND s.properties->>'remote_id' = pli.remote_id
    AND s.deleted_at IS NULL
  LEFT JOIN "story_publication" sp ON sp.story_id = s.id
    AND sp.profile_id = pl.profile_id
    AND sp.deleted_at IS NULL
WHERE pl.kind = $1
  AND pl.is_managed = TRUE
  AND pli.deleted_at IS NULL
  AND pli.remote_id IS NOT NULL
ORDER BY pli.created_at ASC
LIMIT $2
`

type ListImportsWithExistingStoriesParams struct {
	Kind       string `db:"kind" json:"kind"`
	LimitCount int32  `db:"limit_count" json:"limit_count"`
}

type ListImportsWithExistingStoriesRow struct {
	ID                   string                `db:"id" json:"id"`
	ProfileLinkID        string                `db:"profile_link_id" json:"profile_link_id"`
	RemoteID             sql.NullString        `db:"remote_id" json:"remote_id"`
	Properties           pqtype.NullRawMessage `db:"properties" json:"properties"`
	CreatedAt            time.Time             `db:"created_at" json:"created_at"`
	ProfileID            string                `db:"profile_id" json:"profile_id"`
	ProfileDefaultLocale string                `db:"profile_default_locale" json:"profile_default_locale"`
	StoryID              string                `db:"story_id" json:"story_id"`
	PublicationID        sql.NullString        `db:"publication_id" json:"publication_id"`
}

// Returns imports that have matching managed stories (for reconciliation during full sync).
//
//	SELECT
//	  pli.id,
//	  pli.profile_link_id,
//	  pli.remote_id,
//	  pli.properties,
//	  pli.created_at,
//	  pl.profile_id,
//	  COALESCE(NULLIF(TRIM(p.default_locale), ''), 'en')::TEXT AS profile_default_locale,
//	  s.id AS story_id,
//	  sp.id AS publication_id
//	FROM "profile_link_import" pli
//	  INNER JOIN "profile_link" pl ON pl.id = pli.profile_link_id
//	  INNER JOIN "profile" p ON p.id = pl.profile_id
//	  INNER JOIN "story" s ON s.author_profile_id = pl.profile_id
//	    AND s.is_managed = TRUE
//	    AND s.properties->>'remote_id' = pli.remote_id
//	    AND s.deleted_at IS NULL
//	  LEFT JOIN "story_publication" sp ON sp.story_id = s.id
//	    AND sp.profile_id = pl.profile_id
//	    AND sp.deleted_at IS NULL
//	WHERE pl.kind = $1
//	  AND pl.is_managed = TRUE
//	  AND pli.deleted_at IS NULL
//	  AND pli.remote_id IS NOT NULL
//	ORDER BY pli.created_at ASC
//	LIMIT $2
func (q *Queries) ListImportsWithExistingStories(ctx context.Context, arg ListImportsWithExistingStoriesParams) ([]*ListImportsWithExistingStoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, listImportsWithExistingStories, arg.Kind, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListImportsWithExistingStoriesRow{}
	for rows.Next() {
		var i ListImportsWithExistingStoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileLinkID,
			&i.RemoteID,
			&i.Properties,
			&i.CreatedAt,
			&i.ProfileID,
			&i.ProfileDefaultLocale,
			&i.StoryID,
			&i.PublicationID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLinkImportsForStoryCreation = `-- name: ListLinkImportsForStoryCreation :many
SELECT
  pli.id,
  pli.profile_link_id,
  pli.remote_id,
  pli.properties,
  pli.created_at,
  pl.profile_id,
  COALESCE(NULLIF(TRIM(p.default_locale), ''), 'en')::TEXT AS profile_default_locale
FROM "profile_link_import" pli
  INNER JOIN "profile_link" pl ON pl.id = pli.profile_link_id
  INNER JOIN "profile" p ON p.id = pl.profile_id
WHERE pl.kind = $1
  AND pl.is_managed = TRUE
  AND pli.deleted_at IS NULL
  AND pli.remote_id IS NOT NULL
  AND NOT EXISTS (
    SELECT 1 FROM "story" s
    WHERE s.author_profile_id = pl.profile_id
      AND s.is_managed = TRUE
      AND s.properties->>'remote_id' = pli.remote_id
      AND s.deleted_at IS NULL
  )
ORDER BY pli.created_at ASC
LIMIT $2
`

type ListLinkImportsForStoryCreationParams struct {
	Kind       string `db:"kind" json:"kind"`
	LimitCount int32  `db:"limit_count" json:"limit_count"`
}

type ListLinkImportsForStoryCreationRow struct {
	ID                   string                `db:"id" json:"id"`
	ProfileLinkID        string                `db:"profile_link_id" json:"profile_link_id"`
	RemoteID             sql.NullString        `db:"remote_id" json:"remote_id"`
	Properties           pqtype.NullRawMessage `db:"properties" json:"properties"`
	CreatedAt            time.Time             `db:"created_at" json:"created_at"`
	ProfileID            string                `db:"profile_id" json:"profile_id"`
	ProfileDefaultLocale string                `db:"profile_default_locale" json:"profile_default_locale"`
}

// ListLinkImportsForStoryCreation
//
//	SELECT
//	  pli.id,
//	  pli.profile_link_id,
//	  pli.remote_id,
//	  pli.properties,
//	  pli.created_at,
//	  pl.profile_id,
//	  COALESCE(NULLIF(TRIM(p.default_locale), ''), 'en')::TEXT AS profile_default_locale
//	FROM "profile_link_import" pli
//	  INNER JOIN "profile_link" pl ON pl.id = pli.profile_link_id
//	  INNER JOIN "profile" p ON p.id = pl.profile_id
//	WHERE pl.kind = $1
//	  AND pl.is_managed = TRUE
//	  AND pli.deleted_at IS NULL
//	  AND pli.remote_id IS NOT NULL
//	  AND NOT EXISTS (
//	    SELECT 1 FROM "story" s
//	    WHERE s.author_profile_id = pl.profile_id
//	      AND s.is_managed = TRUE
//	      AND s.properties->>'remote_id' = pli.remote_id
//	      AND s.deleted_at IS NULL
//	  )
//	ORDER BY pli.created_at ASC
//	LIMIT $2
func (q *Queries) ListLinkImportsForStoryCreation(ctx context.Context, arg ListLinkImportsForStoryCreationParams) ([]*ListLinkImportsForStoryCreationRow, error) {
	rows, err := q.db.QueryContext(ctx, listLinkImportsForStoryCreation, arg.Kind, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListLinkImportsForStoryCreationRow{}
	for rows.Next() {
		var i ListLinkImportsForStoryCreationRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileLinkID,
			&i.RemoteID,
			&i.Properties,
			&i.CreatedAt,
			&i.ProfileID,
			&i.ProfileDefaultLocale,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listManagedLinksForKind = `-- name: ListManagedLinksForKind :many
SELECT
  pl.id,
  pl.profile_id,
  pl.kind,
  pl.remote_id,
  pl.auth_access_token,
  pl.auth_access_token_expires_at,
  pl.auth_refresh_token
FROM "profile_link" pl
  INNER JOIN "profile" p ON p.id = pl.profile_id
    AND p.deleted_at IS NULL
WHERE pl.kind = $1
  AND pl.is_managed = TRUE
  AND pl.auth_access_token IS NOT NULL
  AND pl.deleted_at IS NULL
ORDER BY pl.updated_at ASC NULLS FIRST
LIMIT $2
`

type ListManagedLinksForKindParams struct {
	Kind       string `db:"kind" json:"kind"`
	LimitCount int32  `db:"limit_count" json:"limit_count"`
}

type ListManagedLinksForKindRow struct {
	ID                       string         `db:"id" json:"id"`
	ProfileID                string         `db:"profile_id" json:"profile_id"`
	Kind                     string         `db:"kind" json:"kind"`
	RemoteID                 sql.NullString `db:"remote_id" json:"remote_id"`
	AuthAccessToken          sql.NullString `db:"auth_access_token" json:"auth_access_token"`
	AuthAccessTokenExpiresAt sql.NullTime   `db:"auth_access_token_expires_at" json:"auth_access_token_expires_at"`
	AuthRefreshToken         sql.NullString `db:"auth_refresh_token" json:"auth_refresh_token"`
}

// ListManagedLinksForKind
//
//	SELECT
//	  pl.id,
//	  pl.profile_id,
//	  pl.kind,
//	  pl.remote_id,
//	  pl.auth_access_token,
//	  pl.auth_access_token_expires_at,
//	  pl.auth_refresh_token
//	FROM "profile_link" pl
//	  INNER JOIN "profile" p ON p.id = pl.profile_id
//	    AND p.deleted_at IS NULL
//	WHERE pl.kind = $1
//	  AND pl.is_managed = TRUE
//	  AND pl.auth_access_token IS NOT NULL
//	  AND pl.deleted_at IS NULL
//	ORDER BY pl.updated_at ASC NULLS FIRST
//	LIMIT $2
func (q *Queries) ListManagedLinksForKind(ctx context.Context, arg ListManagedLinksForKindParams) ([]*ListManagedLinksForKindRow, error) {
	rows, err := q.db.QueryContext(ctx, listManagedLinksForKind, arg.Kind, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListManagedLinksForKindRow{}
	for rows.Next() {
		var i ListManagedLinksForKindRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Kind,
			&i.RemoteID,
			&i.AuthAccessToken,
			&i.AuthAccessTokenExpiresAt,
			&i.AuthRefreshToken,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markLinkImportsDeletedExcept = `-- name: MarkLinkImportsDeletedExcept :execrows
UPDATE "profile_link_import"
SET deleted_at = NOW()
WHERE profile_link_id = $1
  AND deleted_at IS NULL
  AND remote_id IS NOT NULL
  AND remote_id != ALL($2::TEXT[])
`

type MarkLinkImportsDeletedExceptParams struct {
	ProfileLinkID   string   `db:"profile_link_id" json:"profile_link_id"`
	ActiveRemoteIds []string `db:"active_remote_ids" json:"active_remote_ids"`
}

// MarkLinkImportsDeletedExcept
//
//	UPDATE "profile_link_import"
//	SET deleted_at = NOW()
//	WHERE profile_link_id = $1
//	  AND deleted_at IS NULL
//	  AND remote_id IS NOT NULL
//	  AND remote_id != ALL($2::TEXT[])
func (q *Queries) MarkLinkImportsDeletedExcept(ctx context.Context, arg MarkLinkImportsDeletedExceptParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, markLinkImportsDeletedExcept, arg.ProfileLinkID, pq.Array(arg.ActiveRemoteIds))
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateLinkImport = `-- name: UpdateLinkImport :execrows
UPDATE "profile_link_import"
SET
  properties = $1,
  updated_at = NOW(),
  deleted_at = NULL
WHERE id = $2
`

type UpdateLinkImportParams struct {
	Properties pqtype.NullRawMessage `db:"properties" json:"properties"`
	ID         string                `db:"id" json:"id"`
}

// UpdateLinkImport
//
//	UPDATE "profile_link_import"
//	SET
//	  properties = $1,
//	  updated_at = NOW(),
//	  deleted_at = NULL
//	WHERE id = $2
func (q *Queries) UpdateLinkImport(ctx context.Context, arg UpdateLinkImportParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateLinkImport, arg.Properties, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateProfileLinkTokens = `-- name: UpdateProfileLinkTokens :execrows
UPDATE "profile_link"
SET
  auth_access_token = $1,
  auth_access_token_expires_at = $2,
  auth_refresh_token = $3,
  updated_at = NOW()
WHERE id = $4
  AND deleted_at IS NULL
`

type UpdateProfileLinkTokensParams struct {
	AuthAccessToken          sql.NullString `db:"auth_access_token" json:"auth_access_token"`
	AuthAccessTokenExpiresAt sql.NullTime   `db:"auth_access_token_expires_at" json:"auth_access_token_expires_at"`
	AuthRefreshToken         sql.NullString `db:"auth_refresh_token" json:"auth_refresh_token"`
	ID                       string         `db:"id" json:"id"`
}

// UpdateProfileLinkTokens
//
//	UPDATE "profile_link"
//	SET
//	  auth_access_token = $1,
//	  auth_access_token_expires_at = $2,
//	  auth_refresh_token = $3,
//	  updated_at = NOW()
//	WHERE id = $4
//	  AND deleted_at IS NULL
func (q *Queries) UpdateProfileLinkTokens(ctx context.Context, arg UpdateProfileLinkTokensParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProfileLinkTokens,
		arg.AuthAccessToken,
		arg.AuthAccessTokenExpiresAt,
		arg.AuthRefreshToken,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
