// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: profiles.sql

package storage

import (
	"context"
	"database/sql"
	"time"

	"github.com/lib/pq"
	"github.com/sqlc-dev/pqtype"
)

const checkPageSlugExistsIncludingDeleted = `-- name: CheckPageSlugExistsIncludingDeleted :one
SELECT EXISTS(
  SELECT 1 FROM "profile_page"
  WHERE profile_id = $1
    AND slug = $2
) AS exists
`

type CheckPageSlugExistsIncludingDeletedParams struct {
	ProfileID string `db:"profile_id" json:"profile_id"`
	PageSlug  string `db:"page_slug" json:"page_slug"`
}

// CheckPageSlugExistsIncludingDeleted
//
//	SELECT EXISTS(
//	  SELECT 1 FROM "profile_page"
//	  WHERE profile_id = $1
//	    AND slug = $2
//	) AS exists
func (q *Queries) CheckPageSlugExistsIncludingDeleted(ctx context.Context, arg CheckPageSlugExistsIncludingDeletedParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkPageSlugExistsIncludingDeleted, arg.ProfileID, arg.PageSlug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkProfileSlugExists = `-- name: CheckProfileSlugExists :one
SELECT EXISTS(
  SELECT 1 FROM "profile"
  WHERE slug = $1
    AND deleted_at IS NULL
) AS exists
`

type CheckProfileSlugExistsParams struct {
	Slug string `db:"slug" json:"slug"`
}

// CheckProfileSlugExists
//
//	SELECT EXISTS(
//	  SELECT 1 FROM "profile"
//	  WHERE slug = $1
//	    AND deleted_at IS NULL
//	) AS exists
func (q *Queries) CheckProfileSlugExists(ctx context.Context, arg CheckProfileSlugExistsParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkProfileSlugExists, arg.Slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const checkProfileSlugExistsIncludingDeleted = `-- name: CheckProfileSlugExistsIncludingDeleted :one
SELECT EXISTS(
  SELECT 1 FROM "profile"
  WHERE slug = $1
) AS exists
`

type CheckProfileSlugExistsIncludingDeletedParams struct {
	Slug string `db:"slug" json:"slug"`
}

// CheckProfileSlugExistsIncludingDeleted
//
//	SELECT EXISTS(
//	  SELECT 1 FROM "profile"
//	  WHERE slug = $1
//	) AS exists
func (q *Queries) CheckProfileSlugExistsIncludingDeleted(ctx context.Context, arg CheckProfileSlugExistsIncludingDeletedParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkProfileSlugExistsIncludingDeleted, arg.Slug)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const countAllProfilesForAdmin = `-- name: CountAllProfilesForAdmin :one
SELECT COUNT(*) as count
FROM "profile" p
WHERE p.deleted_at IS NULL
  AND ($1::TEXT IS NULL OR p.kind = ANY(string_to_array($1::TEXT, ',')))
`

type CountAllProfilesForAdminParams struct {
	FilterKind sql.NullString `db:"filter_kind" json:"filter_kind"`
}

// CountAllProfilesForAdmin
//
//	SELECT COUNT(*) as count
//	FROM "profile" p
//	WHERE p.deleted_at IS NULL
//	  AND ($1::TEXT IS NULL OR p.kind = ANY(string_to_array($1::TEXT, ',')))
func (q *Queries) CountAllProfilesForAdmin(ctx context.Context, arg CountAllProfilesForAdminParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countAllProfilesForAdmin, arg.FilterKind)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countProfileOwners = `-- name: CountProfileOwners :one
SELECT COUNT(*) as owner_count
FROM "profile_membership" pm
WHERE pm.profile_id = $1
  AND pm.kind = 'owner'
  AND pm.deleted_at IS NULL
  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
`

type CountProfileOwnersParams struct {
	ProfileID string `db:"profile_id" json:"profile_id"`
}

// CountProfileOwners
//
//	SELECT COUNT(*) as owner_count
//	FROM "profile_membership" pm
//	WHERE pm.profile_id = $1
//	  AND pm.kind = 'owner'
//	  AND pm.deleted_at IS NULL
//	  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
func (q *Queries) CountProfileOwners(ctx context.Context, arg CountProfileOwnersParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countProfileOwners, arg.ProfileID)
	var owner_count int64
	err := row.Scan(&owner_count)
	return owner_count, err
}

const createCustomDomain = `-- name: CreateCustomDomain :exec
INSERT INTO "profile_custom_domain" (id, profile_id, domain, default_locale)
VALUES ($1, $2, $3, $4)
`

type CreateCustomDomainParams struct {
	ID            string         `db:"id" json:"id"`
	ProfileID     string         `db:"profile_id" json:"profile_id"`
	Domain        string         `db:"domain" json:"domain"`
	DefaultLocale sql.NullString `db:"default_locale" json:"default_locale"`
}

// CreateCustomDomain
//
//	INSERT INTO "profile_custom_domain" (id, profile_id, domain, default_locale)
//	VALUES ($1, $2, $3, $4)
func (q *Queries) CreateCustomDomain(ctx context.Context, arg CreateCustomDomainParams) error {
	_, err := q.db.ExecContext(ctx, createCustomDomain,
		arg.ID,
		arg.ProfileID,
		arg.Domain,
		arg.DefaultLocale,
	)
	return err
}

const createProfile = `-- name: CreateProfile :exec
INSERT INTO "profile" (id, slug, kind, default_locale, profile_picture_uri, pronouns, properties, approved_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
`

type CreateProfileParams struct {
	ID                string                `db:"id" json:"id"`
	Slug              string                `db:"slug" json:"slug"`
	Kind              string                `db:"kind" json:"kind"`
	DefaultLocale     string                `db:"default_locale" json:"default_locale"`
	ProfilePictureURI sql.NullString        `db:"profile_picture_uri" json:"profile_picture_uri"`
	Pronouns          sql.NullString        `db:"pronouns" json:"pronouns"`
	Properties        pqtype.NullRawMessage `db:"properties" json:"properties"`
}

// CreateProfile
//
//	INSERT INTO "profile" (id, slug, kind, default_locale, profile_picture_uri, pronouns, properties, approved_at)
//	VALUES ($1, $2, $3, $4, $5, $6, $7, NOW())
func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) error {
	_, err := q.db.ExecContext(ctx, createProfile,
		arg.ID,
		arg.Slug,
		arg.Kind,
		arg.DefaultLocale,
		arg.ProfilePictureURI,
		arg.Pronouns,
		arg.Properties,
	)
	return err
}

const createProfileLink = `-- name: CreateProfileLink :one
INSERT INTO "profile_link" (
  id,
  kind,
  profile_id,
  "order",
  is_managed,
  is_verified,
  is_featured,
  visibility,
  remote_id,
  public_id,
  uri,
  auth_provider,
  auth_access_token_scope,
  auth_access_token,
  auth_access_token_expires_at,
  auth_refresh_token,
  auth_refresh_token_expires_at,
  created_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12,
  $13,
  $14,
  $15,
  $16,
  $17,
  NOW()
) RETURNING id, profile_id, kind, "order", is_managed, is_verified, remote_id, public_id, uri, auth_provider, auth_access_token_scope, auth_access_token, auth_access_token_expires_at, auth_refresh_token, auth_refresh_token_expires_at, properties, created_at, updated_at, deleted_at, visibility, is_featured
`

type CreateProfileLinkParams struct {
	ID                        string         `db:"id" json:"id"`
	Kind                      string         `db:"kind" json:"kind"`
	ProfileID                 string         `db:"profile_id" json:"profile_id"`
	LinkOrder                 int32          `db:"link_order" json:"link_order"`
	IsManaged                 bool           `db:"is_managed" json:"is_managed"`
	IsVerified                bool           `db:"is_verified" json:"is_verified"`
	IsFeatured                bool           `db:"is_featured" json:"is_featured"`
	Visibility                string         `db:"visibility" json:"visibility"`
	RemoteID                  sql.NullString `db:"remote_id" json:"remote_id"`
	PublicID                  sql.NullString `db:"public_id" json:"public_id"`
	URI                       sql.NullString `db:"uri" json:"uri"`
	AuthProvider              sql.NullString `db:"auth_provider" json:"auth_provider"`
	AuthAccessTokenScope      sql.NullString `db:"auth_access_token_scope" json:"auth_access_token_scope"`
	AuthAccessToken           sql.NullString `db:"auth_access_token" json:"auth_access_token"`
	AuthAccessTokenExpiresAt  sql.NullTime   `db:"auth_access_token_expires_at" json:"auth_access_token_expires_at"`
	AuthRefreshToken          sql.NullString `db:"auth_refresh_token" json:"auth_refresh_token"`
	AuthRefreshTokenExpiresAt sql.NullTime   `db:"auth_refresh_token_expires_at" json:"auth_refresh_token_expires_at"`
}

// CreateProfileLink
//
//	INSERT INTO "profile_link" (
//	  id,
//	  kind,
//	  profile_id,
//	  "order",
//	  is_managed,
//	  is_verified,
//	  is_featured,
//	  visibility,
//	  remote_id,
//	  public_id,
//	  uri,
//	  auth_provider,
//	  auth_access_token_scope,
//	  auth_access_token,
//	  auth_access_token_expires_at,
//	  auth_refresh_token,
//	  auth_refresh_token_expires_at,
//	  created_at
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5,
//	  $6,
//	  $7,
//	  $8,
//	  $9,
//	  $10,
//	  $11,
//	  $12,
//	  $13,
//	  $14,
//	  $15,
//	  $16,
//	  $17,
//	  NOW()
//	) RETURNING id, profile_id, kind, "order", is_managed, is_verified, remote_id, public_id, uri, auth_provider, auth_access_token_scope, auth_access_token, auth_access_token_expires_at, auth_refresh_token, auth_refresh_token_expires_at, properties, created_at, updated_at, deleted_at, visibility, is_featured
func (q *Queries) CreateProfileLink(ctx context.Context, arg CreateProfileLinkParams) (*ProfileLink, error) {
	row := q.db.QueryRowContext(ctx, createProfileLink,
		arg.ID,
		arg.Kind,
		arg.ProfileID,
		arg.LinkOrder,
		arg.IsManaged,
		arg.IsVerified,
		arg.IsFeatured,
		arg.Visibility,
		arg.RemoteID,
		arg.PublicID,
		arg.URI,
		arg.AuthProvider,
		arg.AuthAccessTokenScope,
		arg.AuthAccessToken,
		arg.AuthAccessTokenExpiresAt,
		arg.AuthRefreshToken,
		arg.AuthRefreshTokenExpiresAt,
	)
	var i ProfileLink
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Kind,
		&i.Order,
		&i.IsManaged,
		&i.IsVerified,
		&i.RemoteID,
		&i.PublicID,
		&i.URI,
		&i.AuthProvider,
		&i.AuthAccessTokenScope,
		&i.AuthAccessToken,
		&i.AuthAccessTokenExpiresAt,
		&i.AuthRefreshToken,
		&i.AuthRefreshTokenExpiresAt,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Visibility,
		&i.IsFeatured,
	)
	return &i, err
}

const createProfileLinkTx = `-- name: CreateProfileLinkTx :exec
INSERT INTO "profile_link_tx" (
  profile_link_id,
  locale_code,
  title,
  icon,
  "group",
  description
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6
)
`

type CreateProfileLinkTxParams struct {
	ProfileLinkID string         `db:"profile_link_id" json:"profile_link_id"`
	LocaleCode    string         `db:"locale_code" json:"locale_code"`
	Title         string         `db:"title" json:"title"`
	Icon          sql.NullString `db:"icon" json:"icon"`
	LinkGroup     sql.NullString `db:"link_group" json:"link_group"`
	Description   sql.NullString `db:"description" json:"description"`
}

// CreateProfileLinkTx
//
//	INSERT INTO "profile_link_tx" (
//	  profile_link_id,
//	  locale_code,
//	  title,
//	  icon,
//	  "group",
//	  description
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5,
//	  $6
//	)
func (q *Queries) CreateProfileLinkTx(ctx context.Context, arg CreateProfileLinkTxParams) error {
	_, err := q.db.ExecContext(ctx, createProfileLinkTx,
		arg.ProfileLinkID,
		arg.LocaleCode,
		arg.Title,
		arg.Icon,
		arg.LinkGroup,
		arg.Description,
	)
	return err
}

const createProfileMembership = `-- name: CreateProfileMembership :exec
INSERT INTO "profile_membership" (
  "id",
  "profile_id",
  "member_profile_id",
  "kind",
  "properties",
  "started_at"
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  NOW()
)
`

type CreateProfileMembershipParams struct {
	ID              string                `db:"id" json:"id"`
	ProfileID       string                `db:"profile_id" json:"profile_id"`
	MemberProfileID sql.NullString        `db:"member_profile_id" json:"member_profile_id"`
	Kind            string                `db:"kind" json:"kind"`
	Properties      pqtype.NullRawMessage `db:"properties" json:"properties"`
}

// CreateProfileMembership
//
//	INSERT INTO "profile_membership" (
//	  "id",
//	  "profile_id",
//	  "member_profile_id",
//	  "kind",
//	  "properties",
//	  "started_at"
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5,
//	  NOW()
//	)
func (q *Queries) CreateProfileMembership(ctx context.Context, arg CreateProfileMembershipParams) error {
	_, err := q.db.ExecContext(ctx, createProfileMembership,
		arg.ID,
		arg.ProfileID,
		arg.MemberProfileID,
		arg.Kind,
		arg.Properties,
	)
	return err
}

const createProfilePage = `-- name: CreateProfilePage :one
INSERT INTO "profile_page" (
  id,
  slug,
  profile_id,
  "order",
  cover_picture_uri,
  published_at,
  created_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  NOW()
) RETURNING id, profile_id, slug, "order", cover_picture_uri, published_at, created_at, updated_at, deleted_at
`

type CreateProfilePageParams struct {
	ID              string         `db:"id" json:"id"`
	Slug            string         `db:"slug" json:"slug"`
	ProfileID       string         `db:"profile_id" json:"profile_id"`
	PageOrder       int32          `db:"page_order" json:"page_order"`
	CoverPictureURI sql.NullString `db:"cover_picture_uri" json:"cover_picture_uri"`
	PublishedAt     sql.NullTime   `db:"published_at" json:"published_at"`
}

// CreateProfilePage
//
//	INSERT INTO "profile_page" (
//	  id,
//	  slug,
//	  profile_id,
//	  "order",
//	  cover_picture_uri,
//	  published_at,
//	  created_at
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5,
//	  $6,
//	  NOW()
//	) RETURNING id, profile_id, slug, "order", cover_picture_uri, published_at, created_at, updated_at, deleted_at
func (q *Queries) CreateProfilePage(ctx context.Context, arg CreateProfilePageParams) (*ProfilePage, error) {
	row := q.db.QueryRowContext(ctx, createProfilePage,
		arg.ID,
		arg.Slug,
		arg.ProfileID,
		arg.PageOrder,
		arg.CoverPictureURI,
		arg.PublishedAt,
	)
	var i ProfilePage
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Slug,
		&i.Order,
		&i.CoverPictureURI,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const createProfilePageTx = `-- name: CreateProfilePageTx :exec
INSERT INTO "profile_page_tx" (
  profile_page_id,
  locale_code,
  title,
  summary,
  content
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
`

type CreateProfilePageTxParams struct {
	ProfilePageID string `db:"profile_page_id" json:"profile_page_id"`
	LocaleCode    string `db:"locale_code" json:"locale_code"`
	Title         string `db:"title" json:"title"`
	Summary       string `db:"summary" json:"summary"`
	Content       string `db:"content" json:"content"`
}

// CreateProfilePageTx
//
//	INSERT INTO "profile_page_tx" (
//	  profile_page_id,
//	  locale_code,
//	  title,
//	  summary,
//	  content
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5
//	)
func (q *Queries) CreateProfilePageTx(ctx context.Context, arg CreateProfilePageTxParams) error {
	_, err := q.db.ExecContext(ctx, createProfilePageTx,
		arg.ProfilePageID,
		arg.LocaleCode,
		arg.Title,
		arg.Summary,
		arg.Content,
	)
	return err
}

const createProfileResource = `-- name: CreateProfileResource :one
INSERT INTO "profile_resource" (
  id, profile_id, kind, is_managed, remote_id, public_id, url,
  title, description, properties, added_by_profile_id, created_at
) VALUES (
  $1, $2, $3, $4,
  $5, $6, $7,
  $8, $9, $10,
  $11, NOW()
) RETURNING id, profile_id, kind, is_managed, remote_id, public_id, url, title, description, properties, added_by_profile_id, created_at, updated_at, deleted_at
`

type CreateProfileResourceParams struct {
	ID               string                `db:"id" json:"id"`
	ProfileID        string                `db:"profile_id" json:"profile_id"`
	Kind             string                `db:"kind" json:"kind"`
	IsManaged        bool                  `db:"is_managed" json:"is_managed"`
	RemoteID         sql.NullString        `db:"remote_id" json:"remote_id"`
	PublicID         sql.NullString        `db:"public_id" json:"public_id"`
	URL              sql.NullString        `db:"url" json:"url"`
	Title            string                `db:"title" json:"title"`
	Description      sql.NullString        `db:"description" json:"description"`
	Properties       pqtype.NullRawMessage `db:"properties" json:"properties"`
	AddedByProfileID string                `db:"added_by_profile_id" json:"added_by_profile_id"`
}

// CreateProfileResource
//
//	INSERT INTO "profile_resource" (
//	  id, profile_id, kind, is_managed, remote_id, public_id, url,
//	  title, description, properties, added_by_profile_id, created_at
//	) VALUES (
//	  $1, $2, $3, $4,
//	  $5, $6, $7,
//	  $8, $9, $10,
//	  $11, NOW()
//	) RETURNING id, profile_id, kind, is_managed, remote_id, public_id, url, title, description, properties, added_by_profile_id, created_at, updated_at, deleted_at
func (q *Queries) CreateProfileResource(ctx context.Context, arg CreateProfileResourceParams) (*ProfileResource, error) {
	row := q.db.QueryRowContext(ctx, createProfileResource,
		arg.ID,
		arg.ProfileID,
		arg.Kind,
		arg.IsManaged,
		arg.RemoteID,
		arg.PublicID,
		arg.URL,
		arg.Title,
		arg.Description,
		arg.Properties,
		arg.AddedByProfileID,
	)
	var i ProfileResource
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Kind,
		&i.IsManaged,
		&i.RemoteID,
		&i.PublicID,
		&i.URL,
		&i.Title,
		&i.Description,
		&i.Properties,
		&i.AddedByProfileID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const createProfileTx = `-- name: CreateProfileTx :exec
INSERT INTO "profile_tx" (profile_id, locale_code, title, description, properties)
VALUES ($1, $2, $3, $4, $5)
`

type CreateProfileTxParams struct {
	ProfileID   string                `db:"profile_id" json:"profile_id"`
	LocaleCode  string                `db:"locale_code" json:"locale_code"`
	Title       string                `db:"title" json:"title"`
	Description string                `db:"description" json:"description"`
	Properties  pqtype.NullRawMessage `db:"properties" json:"properties"`
}

// CreateProfileTx
//
//	INSERT INTO "profile_tx" (profile_id, locale_code, title, description, properties)
//	VALUES ($1, $2, $3, $4, $5)
func (q *Queries) CreateProfileTx(ctx context.Context, arg CreateProfileTxParams) error {
	_, err := q.db.ExecContext(ctx, createProfileTx,
		arg.ProfileID,
		arg.LocaleCode,
		arg.Title,
		arg.Description,
		arg.Properties,
	)
	return err
}

const deleteCustomDomain = `-- name: DeleteCustomDomain :execrows
DELETE FROM "profile_custom_domain"
WHERE id = $1
`

type DeleteCustomDomainParams struct {
	ID string `db:"id" json:"id"`
}

// DeleteCustomDomain
//
//	DELETE FROM "profile_custom_domain"
//	WHERE id = $1
func (q *Queries) DeleteCustomDomain(ctx context.Context, arg DeleteCustomDomainParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteCustomDomain, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteProfileLink = `-- name: DeleteProfileLink :execrows
UPDATE "profile_link"
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type DeleteProfileLinkParams struct {
	ID string `db:"id" json:"id"`
}

// DeleteProfileLink
//
//	UPDATE "profile_link"
//	SET deleted_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) DeleteProfileLink(ctx context.Context, arg DeleteProfileLinkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteProfileLink, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteProfileMembership = `-- name: DeleteProfileMembership :execrows
UPDATE "profile_membership"
SET
  deleted_at = NOW(),
  finished_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type DeleteProfileMembershipParams struct {
	ID string `db:"id" json:"id"`
}

// DeleteProfileMembership
//
//	UPDATE "profile_membership"
//	SET
//	  deleted_at = NOW(),
//	  finished_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) DeleteProfileMembership(ctx context.Context, arg DeleteProfileMembershipParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteProfileMembership, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteProfilePage = `-- name: DeleteProfilePage :execrows
UPDATE "profile_page"
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type DeleteProfilePageParams struct {
	ID string `db:"id" json:"id"`
}

// DeleteProfilePage
//
//	UPDATE "profile_page"
//	SET deleted_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) DeleteProfilePage(ctx context.Context, arg DeleteProfilePageParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteProfilePage, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const deleteProfilePageTx = `-- name: DeleteProfilePageTx :execrows
DELETE FROM "profile_page_tx"
WHERE profile_page_id = $1
  AND locale_code = $2
`

type DeleteProfilePageTxParams struct {
	ProfilePageID string `db:"profile_page_id" json:"profile_page_id"`
	LocaleCode    string `db:"locale_code" json:"locale_code"`
}

// DeleteProfilePageTx
//
//	DELETE FROM "profile_page_tx"
//	WHERE profile_page_id = $1
//	  AND locale_code = $2
func (q *Queries) DeleteProfilePageTx(ctx context.Context, arg DeleteProfilePageTxParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, deleteProfilePageTx, arg.ProfilePageID, arg.LocaleCode)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getAdminProfileBySlug = `-- name: GetAdminProfileBySlug :one
SELECT
  p.id,
  p.slug,
  p.kind,
  p.profile_picture_uri,
  p.pronouns,
  p.properties,
  p.created_at,
  p.updated_at,
  p.points,
  COALESCE(pt.title, '') as title,
  COALESCE(pt.description, '') as description,
  pt.profile_id IS NOT NULL as has_translation
FROM "profile" p
  LEFT JOIN "profile_tx" pt ON pt.profile_id = p.id
  AND pt.locale_code = $1
WHERE p.slug = $2
  AND p.deleted_at IS NULL
LIMIT 1
`

type GetAdminProfileBySlugParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	Slug       string `db:"slug" json:"slug"`
}

type GetAdminProfileBySlugRow struct {
	ID                string                `db:"id" json:"id"`
	Slug              string                `db:"slug" json:"slug"`
	Kind              string                `db:"kind" json:"kind"`
	ProfilePictureURI sql.NullString        `db:"profile_picture_uri" json:"profile_picture_uri"`
	Pronouns          sql.NullString        `db:"pronouns" json:"pronouns"`
	Properties        pqtype.NullRawMessage `db:"properties" json:"properties"`
	CreatedAt         time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt         sql.NullTime          `db:"updated_at" json:"updated_at"`
	Points            int32                 `db:"points" json:"points"`
	Title             string                `db:"title" json:"title"`
	Description       string                `db:"description" json:"description"`
	HasTranslation    interface{}           `db:"has_translation" json:"has_translation"`
}

// GetAdminProfileBySlug
//
//	SELECT
//	  p.id,
//	  p.slug,
//	  p.kind,
//	  p.profile_picture_uri,
//	  p.pronouns,
//	  p.properties,
//	  p.created_at,
//	  p.updated_at,
//	  p.points,
//	  COALESCE(pt.title, '') as title,
//	  COALESCE(pt.description, '') as description,
//	  pt.profile_id IS NOT NULL as has_translation
//	FROM "profile" p
//	  LEFT JOIN "profile_tx" pt ON pt.profile_id = p.id
//	  AND pt.locale_code = $1
//	WHERE p.slug = $2
//	  AND p.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetAdminProfileBySlug(ctx context.Context, arg GetAdminProfileBySlugParams) (*GetAdminProfileBySlugRow, error) {
	row := q.db.QueryRowContext(ctx, getAdminProfileBySlug, arg.LocaleCode, arg.Slug)
	var i GetAdminProfileBySlugRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Kind,
		&i.ProfilePictureURI,
		&i.Pronouns,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Points,
		&i.Title,
		&i.Description,
		&i.HasTranslation,
	)
	return &i, err
}

const getCustomDomainByDomain = `-- name: GetCustomDomainByDomain :one
SELECT pcd.id, pcd.profile_id, pcd.domain, pcd.default_locale, pcd.created_at, pcd.updated_at
FROM "profile_custom_domain" pcd
WHERE pcd.domain = $1
LIMIT 1
`

type GetCustomDomainByDomainParams struct {
	Domain string `db:"domain" json:"domain"`
}

// GetCustomDomainByDomain
//
//	SELECT pcd.id, pcd.profile_id, pcd.domain, pcd.default_locale, pcd.created_at, pcd.updated_at
//	FROM "profile_custom_domain" pcd
//	WHERE pcd.domain = $1
//	LIMIT 1
func (q *Queries) GetCustomDomainByDomain(ctx context.Context, arg GetCustomDomainByDomainParams) (*ProfileCustomDomain, error) {
	row := q.db.QueryRowContext(ctx, getCustomDomainByDomain, arg.Domain)
	var i ProfileCustomDomain
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Domain,
		&i.DefaultLocale,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getManagedGitHubLinkByProfileID = `-- name: GetManagedGitHubLinkByProfileID :one
SELECT id, profile_id, auth_access_token
FROM "profile_link"
WHERE profile_id = $1
  AND kind = 'github'
  AND is_managed = true
  AND auth_access_token IS NOT NULL
  AND deleted_at IS NULL
LIMIT 1
`

type GetManagedGitHubLinkByProfileIDParams struct {
	ProfileID string `db:"profile_id" json:"profile_id"`
}

type GetManagedGitHubLinkByProfileIDRow struct {
	ID              string         `db:"id" json:"id"`
	ProfileID       string         `db:"profile_id" json:"profile_id"`
	AuthAccessToken sql.NullString `db:"auth_access_token" json:"auth_access_token"`
}

// GetManagedGitHubLinkByProfileID
//
//	SELECT id, profile_id, auth_access_token
//	FROM "profile_link"
//	WHERE profile_id = $1
//	  AND kind = 'github'
//	  AND is_managed = true
//	  AND auth_access_token IS NOT NULL
//	  AND deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetManagedGitHubLinkByProfileID(ctx context.Context, arg GetManagedGitHubLinkByProfileIDParams) (*GetManagedGitHubLinkByProfileIDRow, error) {
	row := q.db.QueryRowContext(ctx, getManagedGitHubLinkByProfileID, arg.ProfileID)
	var i GetManagedGitHubLinkByProfileIDRow
	err := row.Scan(&i.ID, &i.ProfileID, &i.AuthAccessToken)
	return &i, err
}

const getMaxProfileLinkOrder = `-- name: GetMaxProfileLinkOrder :one
SELECT COALESCE(MAX("order"), 0) as max_order
FROM "profile_link"
WHERE profile_id = $1
  AND deleted_at IS NULL
`

type GetMaxProfileLinkOrderParams struct {
	ProfileID string `db:"profile_id" json:"profile_id"`
}

// GetMaxProfileLinkOrder
//
//	SELECT COALESCE(MAX("order"), 0) as max_order
//	FROM "profile_link"
//	WHERE profile_id = $1
//	  AND deleted_at IS NULL
func (q *Queries) GetMaxProfileLinkOrder(ctx context.Context, arg GetMaxProfileLinkOrderParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getMaxProfileLinkOrder, arg.ProfileID)
	var max_order interface{}
	err := row.Scan(&max_order)
	return max_order, err
}

const getMembershipBetweenProfiles = `-- name: GetMembershipBetweenProfiles :one
SELECT pm.kind
FROM "profile_membership" pm
WHERE pm.profile_id = $1
  AND pm.member_profile_id = $2
  AND pm.deleted_at IS NULL
  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
LIMIT 1
`

type GetMembershipBetweenProfilesParams struct {
	ProfileID       string         `db:"profile_id" json:"profile_id"`
	MemberProfileID sql.NullString `db:"member_profile_id" json:"member_profile_id"`
}

// GetMembershipBetweenProfiles
//
//	SELECT pm.kind
//	FROM "profile_membership" pm
//	WHERE pm.profile_id = $1
//	  AND pm.member_profile_id = $2
//	  AND pm.deleted_at IS NULL
//	  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
//	LIMIT 1
func (q *Queries) GetMembershipBetweenProfiles(ctx context.Context, arg GetMembershipBetweenProfilesParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getMembershipBetweenProfiles, arg.ProfileID, arg.MemberProfileID)
	var kind string
	err := row.Scan(&kind)
	return kind, err
}

const getProfileByID = `-- name: GetProfileByID :one
SELECT p.id, p.slug, p.kind, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, p.approved_at, p.points, p.hide_relations, p.hide_links, p.default_locale, p.hide_qa, pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector
FROM "profile" p
  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
  AND pt.locale_code = (
    SELECT ptf.locale_code FROM "profile_tx" ptf
    WHERE ptf.profile_id = p.id
    AND (ptf.locale_code = $1 OR ptf.locale_code = p.default_locale)
    ORDER BY CASE WHEN ptf.locale_code = $1 THEN 0 ELSE 1 END
    LIMIT 1
  )
WHERE p.id = $2
  AND p.deleted_at IS NULL
LIMIT 1
`

type GetProfileByIDParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	ID         string `db:"id" json:"id"`
}

type GetProfileByIDRow struct {
	Profile   Profile   `db:"profile" json:"profile"`
	ProfileTx ProfileTx `db:"profile_tx" json:"profile_tx"`
}

// GetProfileByID
//
//	SELECT p.id, p.slug, p.kind, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, p.approved_at, p.points, p.hide_relations, p.hide_links, p.default_locale, p.hide_qa, pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector
//	FROM "profile" p
//	  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
//	  AND pt.locale_code = (
//	    SELECT ptf.locale_code FROM "profile_tx" ptf
//	    WHERE ptf.profile_id = p.id
//	    AND (ptf.locale_code = $1 OR ptf.locale_code = p.default_locale)
//	    ORDER BY CASE WHEN ptf.locale_code = $1 THEN 0 ELSE 1 END
//	    LIMIT 1
//	  )
//	WHERE p.id = $2
//	  AND p.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetProfileByID(ctx context.Context, arg GetProfileByIDParams) (*GetProfileByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileByID, arg.LocaleCode, arg.ID)
	var i GetProfileByIDRow
	err := row.Scan(
		&i.Profile.ID,
		&i.Profile.Slug,
		&i.Profile.Kind,
		&i.Profile.ProfilePictureURI,
		&i.Profile.Pronouns,
		&i.Profile.Properties,
		&i.Profile.CreatedAt,
		&i.Profile.UpdatedAt,
		&i.Profile.DeletedAt,
		&i.Profile.ApprovedAt,
		&i.Profile.Points,
		&i.Profile.HideRelations,
		&i.Profile.HideLinks,
		&i.Profile.DefaultLocale,
		&i.Profile.HideQa,
		&i.ProfileTx.ProfileID,
		&i.ProfileTx.LocaleCode,
		&i.ProfileTx.Title,
		&i.ProfileTx.Description,
		&i.ProfileTx.Properties,
		&i.ProfileTx.SearchVector,
	)
	return &i, err
}

const getProfileIDBySlug = `-- name: GetProfileIDBySlug :one
SELECT id
FROM "profile"
WHERE slug = $1
  AND deleted_at IS NULL
LIMIT 1
`

type GetProfileIDBySlugParams struct {
	Slug string `db:"slug" json:"slug"`
}

// GetProfileIDBySlug
//
//	SELECT id
//	FROM "profile"
//	WHERE slug = $1
//	  AND deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetProfileIDBySlug(ctx context.Context, arg GetProfileIDBySlugParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getProfileIDBySlug, arg.Slug)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getProfileIdentifierByID = `-- name: GetProfileIdentifierByID :one
SELECT p.id, p.slug, p.kind, p.profile_picture_uri
FROM "profile" p
WHERE p.id = $1
  AND p.deleted_at IS NULL
LIMIT 1
`

type GetProfileIdentifierByIDParams struct {
	ID string `db:"id" json:"id"`
}

type GetProfileIdentifierByIDRow struct {
	ID                string         `db:"id" json:"id"`
	Slug              string         `db:"slug" json:"slug"`
	Kind              string         `db:"kind" json:"kind"`
	ProfilePictureURI sql.NullString `db:"profile_picture_uri" json:"profile_picture_uri"`
}

// GetProfileIdentifierByID
//
//	SELECT p.id, p.slug, p.kind, p.profile_picture_uri
//	FROM "profile" p
//	WHERE p.id = $1
//	  AND p.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetProfileIdentifierByID(ctx context.Context, arg GetProfileIdentifierByIDParams) (*GetProfileIdentifierByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileIdentifierByID, arg.ID)
	var i GetProfileIdentifierByIDRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Kind,
		&i.ProfilePictureURI,
	)
	return &i, err
}

const getProfileLink = `-- name: GetProfileLink :one
SELECT
  pl.id, pl.profile_id, pl.kind, pl."order", pl.is_managed, pl.is_verified, pl.remote_id, pl.public_id, pl.uri, pl.auth_provider, pl.auth_access_token_scope, pl.auth_access_token, pl.auth_access_token_expires_at, pl.auth_refresh_token, pl.auth_refresh_token_expires_at, pl.properties, pl.created_at, pl.updated_at, pl.deleted_at, pl.visibility, pl.is_featured,
  COALESCE(plt.profile_link_id, plt_def.profile_link_id, pl.id) as profile_link_id,
  COALESCE(plt.locale_code, plt_def.locale_code, p.default_locale) as locale_code,
  COALESCE(plt.title, plt_def.title, pl.kind) as title,
  COALESCE(plt.icon, plt_def.icon, '') as icon,
  plt."group" as "group",
  plt.description as description
FROM "profile_link" pl
  INNER JOIN "profile" p ON p.id = pl.profile_id
  LEFT JOIN "profile_link_tx" plt ON plt.profile_link_id = pl.id
    AND plt.locale_code = $1
  LEFT JOIN "profile_link_tx" plt_def ON plt_def.profile_link_id = pl.id
    AND plt_def.locale_code = p.default_locale
WHERE pl.id = $2
  AND pl.deleted_at IS NULL
`

type GetProfileLinkParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	ID         string `db:"id" json:"id"`
}

type GetProfileLinkRow struct {
	ID                        string                `db:"id" json:"id"`
	ProfileID                 string                `db:"profile_id" json:"profile_id"`
	Kind                      string                `db:"kind" json:"kind"`
	Order                     int32                 `db:"order" json:"order"`
	IsManaged                 bool                  `db:"is_managed" json:"is_managed"`
	IsVerified                bool                  `db:"is_verified" json:"is_verified"`
	RemoteID                  sql.NullString        `db:"remote_id" json:"remote_id"`
	PublicID                  sql.NullString        `db:"public_id" json:"public_id"`
	URI                       sql.NullString        `db:"uri" json:"uri"`
	AuthProvider              sql.NullString        `db:"auth_provider" json:"auth_provider"`
	AuthAccessTokenScope      sql.NullString        `db:"auth_access_token_scope" json:"auth_access_token_scope"`
	AuthAccessToken           sql.NullString        `db:"auth_access_token" json:"auth_access_token"`
	AuthAccessTokenExpiresAt  sql.NullTime          `db:"auth_access_token_expires_at" json:"auth_access_token_expires_at"`
	AuthRefreshToken          sql.NullString        `db:"auth_refresh_token" json:"auth_refresh_token"`
	AuthRefreshTokenExpiresAt sql.NullTime          `db:"auth_refresh_token_expires_at" json:"auth_refresh_token_expires_at"`
	Properties                pqtype.NullRawMessage `db:"properties" json:"properties"`
	CreatedAt                 time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt                 sql.NullTime          `db:"updated_at" json:"updated_at"`
	DeletedAt                 sql.NullTime          `db:"deleted_at" json:"deleted_at"`
	Visibility                string                `db:"visibility" json:"visibility"`
	IsFeatured                bool                  `db:"is_featured" json:"is_featured"`
	ProfileLinkID             string                `db:"profile_link_id" json:"profile_link_id"`
	LocaleCode                string                `db:"locale_code" json:"locale_code"`
	Title                     string                `db:"title" json:"title"`
	Icon                      string                `db:"icon" json:"icon"`
	Group                     sql.NullString        `db:"group" json:"group"`
	Description               sql.NullString        `db:"description" json:"description"`
}

// GetProfileLink
//
//	SELECT
//	  pl.id, pl.profile_id, pl.kind, pl."order", pl.is_managed, pl.is_verified, pl.remote_id, pl.public_id, pl.uri, pl.auth_provider, pl.auth_access_token_scope, pl.auth_access_token, pl.auth_access_token_expires_at, pl.auth_refresh_token, pl.auth_refresh_token_expires_at, pl.properties, pl.created_at, pl.updated_at, pl.deleted_at, pl.visibility, pl.is_featured,
//	  COALESCE(plt.profile_link_id, plt_def.profile_link_id, pl.id) as profile_link_id,
//	  COALESCE(plt.locale_code, plt_def.locale_code, p.default_locale) as locale_code,
//	  COALESCE(plt.title, plt_def.title, pl.kind) as title,
//	  COALESCE(plt.icon, plt_def.icon, '') as icon,
//	  plt."group" as "group",
//	  plt.description as description
//	FROM "profile_link" pl
//	  INNER JOIN "profile" p ON p.id = pl.profile_id
//	  LEFT JOIN "profile_link_tx" plt ON plt.profile_link_id = pl.id
//	    AND plt.locale_code = $1
//	  LEFT JOIN "profile_link_tx" plt_def ON plt_def.profile_link_id = pl.id
//	    AND plt_def.locale_code = p.default_locale
//	WHERE pl.id = $2
//	  AND pl.deleted_at IS NULL
func (q *Queries) GetProfileLink(ctx context.Context, arg GetProfileLinkParams) (*GetProfileLinkRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileLink, arg.LocaleCode, arg.ID)
	var i GetProfileLinkRow
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Kind,
		&i.Order,
		&i.IsManaged,
		&i.IsVerified,
		&i.RemoteID,
		&i.PublicID,
		&i.URI,
		&i.AuthProvider,
		&i.AuthAccessTokenScope,
		&i.AuthAccessToken,
		&i.AuthAccessTokenExpiresAt,
		&i.AuthRefreshToken,
		&i.AuthRefreshTokenExpiresAt,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Visibility,
		&i.IsFeatured,
		&i.ProfileLinkID,
		&i.LocaleCode,
		&i.Title,
		&i.Icon,
		&i.Group,
		&i.Description,
	)
	return &i, err
}

const getProfileLinkByRemoteID = `-- name: GetProfileLinkByRemoteID :one
SELECT id, profile_id, kind, "order", is_managed, is_verified, remote_id, public_id, uri, auth_provider, auth_access_token_scope, auth_access_token, auth_access_token_expires_at, auth_refresh_token, auth_refresh_token_expires_at, properties, created_at, updated_at, deleted_at, visibility, is_featured
FROM "profile_link"
WHERE profile_id = $1
  AND kind = $2
  AND remote_id = $3
  AND deleted_at IS NULL
LIMIT 1
`

type GetProfileLinkByRemoteIDParams struct {
	ProfileID string         `db:"profile_id" json:"profile_id"`
	Kind      string         `db:"kind" json:"kind"`
	RemoteID  sql.NullString `db:"remote_id" json:"remote_id"`
}

// GetProfileLinkByRemoteID
//
//	SELECT id, profile_id, kind, "order", is_managed, is_verified, remote_id, public_id, uri, auth_provider, auth_access_token_scope, auth_access_token, auth_access_token_expires_at, auth_refresh_token, auth_refresh_token_expires_at, properties, created_at, updated_at, deleted_at, visibility, is_featured
//	FROM "profile_link"
//	WHERE profile_id = $1
//	  AND kind = $2
//	  AND remote_id = $3
//	  AND deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetProfileLinkByRemoteID(ctx context.Context, arg GetProfileLinkByRemoteIDParams) (*ProfileLink, error) {
	row := q.db.QueryRowContext(ctx, getProfileLinkByRemoteID, arg.ProfileID, arg.Kind, arg.RemoteID)
	var i ProfileLink
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Kind,
		&i.Order,
		&i.IsManaged,
		&i.IsVerified,
		&i.RemoteID,
		&i.PublicID,
		&i.URI,
		&i.AuthProvider,
		&i.AuthAccessTokenScope,
		&i.AuthAccessToken,
		&i.AuthAccessTokenExpiresAt,
		&i.AuthRefreshToken,
		&i.AuthRefreshTokenExpiresAt,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Visibility,
		&i.IsFeatured,
	)
	return &i, err
}

const getProfileLinkTx = `-- name: GetProfileLinkTx :one
SELECT profile_link_id, locale_code, title, "group", description, icon
FROM "profile_link_tx"
WHERE profile_link_id = $1
  AND locale_code = $2
LIMIT 1
`

type GetProfileLinkTxParams struct {
	ProfileLinkID string `db:"profile_link_id" json:"profile_link_id"`
	LocaleCode    string `db:"locale_code" json:"locale_code"`
}

// GetProfileLinkTx
//
//	SELECT profile_link_id, locale_code, title, "group", description, icon
//	FROM "profile_link_tx"
//	WHERE profile_link_id = $1
//	  AND locale_code = $2
//	LIMIT 1
func (q *Queries) GetProfileLinkTx(ctx context.Context, arg GetProfileLinkTxParams) (*ProfileLinkTx, error) {
	row := q.db.QueryRowContext(ctx, getProfileLinkTx, arg.ProfileLinkID, arg.LocaleCode)
	var i ProfileLinkTx
	err := row.Scan(
		&i.ProfileLinkID,
		&i.LocaleCode,
		&i.Title,
		&i.Group,
		&i.Description,
		&i.Icon,
	)
	return &i, err
}

const getProfileMembershipByID = `-- name: GetProfileMembershipByID :one
SELECT
  pm.id,
  pm.profile_id,
  pm.member_profile_id,
  pm.kind,
  pm.properties,
  pm.started_at,
  pm.finished_at
FROM "profile_membership" pm
WHERE pm.id = $1
  AND pm.deleted_at IS NULL
`

type GetProfileMembershipByIDParams struct {
	ID string `db:"id" json:"id"`
}

type GetProfileMembershipByIDRow struct {
	ID              string                `db:"id" json:"id"`
	ProfileID       string                `db:"profile_id" json:"profile_id"`
	MemberProfileID sql.NullString        `db:"member_profile_id" json:"member_profile_id"`
	Kind            string                `db:"kind" json:"kind"`
	Properties      pqtype.NullRawMessage `db:"properties" json:"properties"`
	StartedAt       sql.NullTime          `db:"started_at" json:"started_at"`
	FinishedAt      sql.NullTime          `db:"finished_at" json:"finished_at"`
}

// GetProfileMembershipByID
//
//	SELECT
//	  pm.id,
//	  pm.profile_id,
//	  pm.member_profile_id,
//	  pm.kind,
//	  pm.properties,
//	  pm.started_at,
//	  pm.finished_at
//	FROM "profile_membership" pm
//	WHERE pm.id = $1
//	  AND pm.deleted_at IS NULL
func (q *Queries) GetProfileMembershipByID(ctx context.Context, arg GetProfileMembershipByIDParams) (*GetProfileMembershipByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileMembershipByID, arg.ID)
	var i GetProfileMembershipByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.MemberProfileID,
		&i.Kind,
		&i.Properties,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return &i, err
}

const getProfileMembershipByProfileAndMember = `-- name: GetProfileMembershipByProfileAndMember :one
SELECT
  pm.id,
  pm.profile_id,
  pm.member_profile_id,
  pm.kind,
  pm.properties,
  pm.started_at,
  pm.finished_at
FROM "profile_membership" pm
WHERE pm.profile_id = $1
  AND pm.member_profile_id = $2
  AND pm.deleted_at IS NULL
  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
`

type GetProfileMembershipByProfileAndMemberParams struct {
	ProfileID       string         `db:"profile_id" json:"profile_id"`
	MemberProfileID sql.NullString `db:"member_profile_id" json:"member_profile_id"`
}

type GetProfileMembershipByProfileAndMemberRow struct {
	ID              string                `db:"id" json:"id"`
	ProfileID       string                `db:"profile_id" json:"profile_id"`
	MemberProfileID sql.NullString        `db:"member_profile_id" json:"member_profile_id"`
	Kind            string                `db:"kind" json:"kind"`
	Properties      pqtype.NullRawMessage `db:"properties" json:"properties"`
	StartedAt       sql.NullTime          `db:"started_at" json:"started_at"`
	FinishedAt      sql.NullTime          `db:"finished_at" json:"finished_at"`
}

// GetProfileMembershipByProfileAndMember
//
//	SELECT
//	  pm.id,
//	  pm.profile_id,
//	  pm.member_profile_id,
//	  pm.kind,
//	  pm.properties,
//	  pm.started_at,
//	  pm.finished_at
//	FROM "profile_membership" pm
//	WHERE pm.profile_id = $1
//	  AND pm.member_profile_id = $2
//	  AND pm.deleted_at IS NULL
//	  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
func (q *Queries) GetProfileMembershipByProfileAndMember(ctx context.Context, arg GetProfileMembershipByProfileAndMemberParams) (*GetProfileMembershipByProfileAndMemberRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileMembershipByProfileAndMember, arg.ProfileID, arg.MemberProfileID)
	var i GetProfileMembershipByProfileAndMemberRow
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.MemberProfileID,
		&i.Kind,
		&i.Properties,
		&i.StartedAt,
		&i.FinishedAt,
	)
	return &i, err
}

const getProfileMembershipsByMemberProfileID = `-- name: GetProfileMembershipsByMemberProfileID :many
SELECT
  pm.id as membership_id,
  pm.kind as membership_kind,
  pm.started_at,
  pm.finished_at,
  pm.properties as membership_properties,
  p.id, p.slug, p.kind, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, p.approved_at, p.points, p.hide_relations, p.hide_links, p.default_locale, p.hide_qa,
  pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector
FROM
  "profile_membership" pm
  INNER JOIN "profile" p ON p.id = pm.profile_id
    AND p.approved_at IS NOT NULL
    AND p.deleted_at IS NULL
  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
    AND pt.locale_code = (
      SELECT ptf.locale_code FROM "profile_tx" ptf
      WHERE ptf.profile_id = p.id
      AND (ptf.locale_code = $1 OR ptf.locale_code = p.default_locale)
      ORDER BY CASE WHEN ptf.locale_code = $1 THEN 0 ELSE 1 END
      LIMIT 1
    )
WHERE
  pm.deleted_at IS NULL
  AND pm.member_profile_id = $2
  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
  AND pm.kind NOT IN ('follower', 'sponsor')
ORDER BY pm.started_at DESC
`

type GetProfileMembershipsByMemberProfileIDParams struct {
	LocaleCode      string         `db:"locale_code" json:"locale_code"`
	MemberProfileID sql.NullString `db:"member_profile_id" json:"member_profile_id"`
}

type GetProfileMembershipsByMemberProfileIDRow struct {
	MembershipID         string                `db:"membership_id" json:"membership_id"`
	MembershipKind       string                `db:"membership_kind" json:"membership_kind"`
	StartedAt            sql.NullTime          `db:"started_at" json:"started_at"`
	FinishedAt           sql.NullTime          `db:"finished_at" json:"finished_at"`
	MembershipProperties pqtype.NullRawMessage `db:"membership_properties" json:"membership_properties"`
	Profile              Profile               `db:"profile" json:"profile"`
	ProfileTx            ProfileTx             `db:"profile_tx" json:"profile_tx"`
}

// GetProfileMembershipsByMemberProfileID
//
//	SELECT
//	  pm.id as membership_id,
//	  pm.kind as membership_kind,
//	  pm.started_at,
//	  pm.finished_at,
//	  pm.properties as membership_properties,
//	  p.id, p.slug, p.kind, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, p.approved_at, p.points, p.hide_relations, p.hide_links, p.default_locale, p.hide_qa,
//	  pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector
//	FROM
//	  "profile_membership" pm
//	  INNER JOIN "profile" p ON p.id = pm.profile_id
//	    AND p.approved_at IS NOT NULL
//	    AND p.deleted_at IS NULL
//	  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
//	    AND pt.locale_code = (
//	      SELECT ptf.locale_code FROM "profile_tx" ptf
//	      WHERE ptf.profile_id = p.id
//	      AND (ptf.locale_code = $1 OR ptf.locale_code = p.default_locale)
//	      ORDER BY CASE WHEN ptf.locale_code = $1 THEN 0 ELSE 1 END
//	      LIMIT 1
//	    )
//	WHERE
//	  pm.deleted_at IS NULL
//	  AND pm.member_profile_id = $2
//	  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
//	  AND pm.kind NOT IN ('follower', 'sponsor')
//	ORDER BY pm.started_at DESC
func (q *Queries) GetProfileMembershipsByMemberProfileID(ctx context.Context, arg GetProfileMembershipsByMemberProfileIDParams) ([]*GetProfileMembershipsByMemberProfileIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfileMembershipsByMemberProfileID, arg.LocaleCode, arg.MemberProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetProfileMembershipsByMemberProfileIDRow{}
	for rows.Next() {
		var i GetProfileMembershipsByMemberProfileIDRow
		if err := rows.Scan(
			&i.MembershipID,
			&i.MembershipKind,
			&i.StartedAt,
			&i.FinishedAt,
			&i.MembershipProperties,
			&i.Profile.ID,
			&i.Profile.Slug,
			&i.Profile.Kind,
			&i.Profile.ProfilePictureURI,
			&i.Profile.Pronouns,
			&i.Profile.Properties,
			&i.Profile.CreatedAt,
			&i.Profile.UpdatedAt,
			&i.Profile.DeletedAt,
			&i.Profile.ApprovedAt,
			&i.Profile.Points,
			&i.Profile.HideRelations,
			&i.Profile.HideLinks,
			&i.Profile.DefaultLocale,
			&i.Profile.HideQa,
			&i.ProfileTx.ProfileID,
			&i.ProfileTx.LocaleCode,
			&i.ProfileTx.Title,
			&i.ProfileTx.Description,
			&i.ProfileTx.Properties,
			&i.ProfileTx.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfileOwnershipForUser = `-- name: GetProfileOwnershipForUser :one
SELECT
  p.id,
  p.slug,
  p.kind as profile_kind,
  u.kind as user_kind,
  CASE
    WHEN u.kind = 'admin' THEN true
    WHEN p.kind = 'individual' AND u.individual_profile_id = p.id THEN true
    WHEN pm.kind IN ('owner', 'lead') THEN true
    ELSE false
  END as can_edit
FROM "profile" p
CROSS JOIN "user" u
LEFT JOIN "profile_membership" pm ON p.id = pm.profile_id
  AND pm.member_profile_id = u.individual_profile_id
  AND pm.deleted_at IS NULL
  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
WHERE u.id = $1
  AND p.slug = $2
  AND p.deleted_at IS NULL
  AND u.deleted_at IS NULL
LIMIT 1
`

type GetProfileOwnershipForUserParams struct {
	UserID      string `db:"user_id" json:"user_id"`
	ProfileSlug string `db:"profile_slug" json:"profile_slug"`
}

type GetProfileOwnershipForUserRow struct {
	ID          string `db:"id" json:"id"`
	Slug        string `db:"slug" json:"slug"`
	ProfileKind string `db:"profile_kind" json:"profile_kind"`
	UserKind    string `db:"user_kind" json:"user_kind"`
	CanEdit     bool   `db:"can_edit" json:"can_edit"`
}

// GetProfileOwnershipForUser
//
//	SELECT
//	  p.id,
//	  p.slug,
//	  p.kind as profile_kind,
//	  u.kind as user_kind,
//	  CASE
//	    WHEN u.kind = 'admin' THEN true
//	    WHEN p.kind = 'individual' AND u.individual_profile_id = p.id THEN true
//	    WHEN pm.kind IN ('owner', 'lead') THEN true
//	    ELSE false
//	  END as can_edit
//	FROM "profile" p
//	CROSS JOIN "user" u
//	LEFT JOIN "profile_membership" pm ON p.id = pm.profile_id
//	  AND pm.member_profile_id = u.individual_profile_id
//	  AND pm.deleted_at IS NULL
//	  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
//	WHERE u.id = $1
//	  AND p.slug = $2
//	  AND p.deleted_at IS NULL
//	  AND u.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetProfileOwnershipForUser(ctx context.Context, arg GetProfileOwnershipForUserParams) (*GetProfileOwnershipForUserRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileOwnershipForUser, arg.UserID, arg.ProfileSlug)
	var i GetProfileOwnershipForUserRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.ProfileKind,
		&i.UserKind,
		&i.CanEdit,
	)
	return &i, err
}

const getProfilePage = `-- name: GetProfilePage :one
SELECT id, profile_id, slug, "order", cover_picture_uri, published_at, created_at, updated_at, deleted_at
FROM "profile_page"
WHERE id = $1
  AND deleted_at IS NULL
`

type GetProfilePageParams struct {
	ID string `db:"id" json:"id"`
}

// GetProfilePage
//
//	SELECT id, profile_id, slug, "order", cover_picture_uri, published_at, created_at, updated_at, deleted_at
//	FROM "profile_page"
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) GetProfilePage(ctx context.Context, arg GetProfilePageParams) (*ProfilePage, error) {
	row := q.db.QueryRowContext(ctx, getProfilePage, arg.ID)
	var i ProfilePage
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Slug,
		&i.Order,
		&i.CoverPictureURI,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getProfilePageByProfileIDAndSlug = `-- name: GetProfilePageByProfileIDAndSlug :one
SELECT pp.id, pp.profile_id, pp.slug, pp."order", pp.cover_picture_uri, pp.published_at, pp.created_at, pp.updated_at, pp.deleted_at, ppt.profile_page_id, ppt.locale_code, ppt.title, ppt.summary, ppt.content, ppt.search_vector
FROM "profile_page" pp
  INNER JOIN "profile" p ON p.id = pp.profile_id
  INNER JOIN "profile_page_tx" ppt ON ppt.profile_page_id = pp.id
  AND ppt.locale_code = (
    SELECT pptf.locale_code FROM "profile_page_tx" pptf
    WHERE pptf.profile_page_id = pp.id
    AND (pptf.locale_code = $1 OR pptf.locale_code = p.default_locale)
    ORDER BY CASE WHEN pptf.locale_code = $1 THEN 0 ELSE 1 END
    LIMIT 1
  )
WHERE pp.profile_id = $2 AND pp.slug = $3 AND pp.deleted_at IS NULL
ORDER BY pp."order"
`

type GetProfilePageByProfileIDAndSlugParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	ProfileID  string `db:"profile_id" json:"profile_id"`
	PageSlug   string `db:"page_slug" json:"page_slug"`
}

type GetProfilePageByProfileIDAndSlugRow struct {
	ID              string         `db:"id" json:"id"`
	ProfileID       string         `db:"profile_id" json:"profile_id"`
	Slug            string         `db:"slug" json:"slug"`
	Order           int32          `db:"order" json:"order"`
	CoverPictureURI sql.NullString `db:"cover_picture_uri" json:"cover_picture_uri"`
	PublishedAt     sql.NullTime   `db:"published_at" json:"published_at"`
	CreatedAt       time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt       sql.NullTime   `db:"updated_at" json:"updated_at"`
	DeletedAt       sql.NullTime   `db:"deleted_at" json:"deleted_at"`
	ProfilePageID   string         `db:"profile_page_id" json:"profile_page_id"`
	LocaleCode      string         `db:"locale_code" json:"locale_code"`
	Title           string         `db:"title" json:"title"`
	Summary         string         `db:"summary" json:"summary"`
	Content         string         `db:"content" json:"content"`
	SearchVector    interface{}    `db:"search_vector" json:"search_vector"`
}

// GetProfilePageByProfileIDAndSlug
//
//	SELECT pp.id, pp.profile_id, pp.slug, pp."order", pp.cover_picture_uri, pp.published_at, pp.created_at, pp.updated_at, pp.deleted_at, ppt.profile_page_id, ppt.locale_code, ppt.title, ppt.summary, ppt.content, ppt.search_vector
//	FROM "profile_page" pp
//	  INNER JOIN "profile" p ON p.id = pp.profile_id
//	  INNER JOIN "profile_page_tx" ppt ON ppt.profile_page_id = pp.id
//	  AND ppt.locale_code = (
//	    SELECT pptf.locale_code FROM "profile_page_tx" pptf
//	    WHERE pptf.profile_page_id = pp.id
//	    AND (pptf.locale_code = $1 OR pptf.locale_code = p.default_locale)
//	    ORDER BY CASE WHEN pptf.locale_code = $1 THEN 0 ELSE 1 END
//	    LIMIT 1
//	  )
//	WHERE pp.profile_id = $2 AND pp.slug = $3 AND pp.deleted_at IS NULL
//	ORDER BY pp."order"
func (q *Queries) GetProfilePageByProfileIDAndSlug(ctx context.Context, arg GetProfilePageByProfileIDAndSlugParams) (*GetProfilePageByProfileIDAndSlugRow, error) {
	row := q.db.QueryRowContext(ctx, getProfilePageByProfileIDAndSlug, arg.LocaleCode, arg.ProfileID, arg.PageSlug)
	var i GetProfilePageByProfileIDAndSlugRow
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Slug,
		&i.Order,
		&i.CoverPictureURI,
		&i.PublishedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.ProfilePageID,
		&i.LocaleCode,
		&i.Title,
		&i.Summary,
		&i.Content,
		&i.SearchVector,
	)
	return &i, err
}

const getProfileResourceByID = `-- name: GetProfileResourceByID :one
SELECT id, profile_id, kind, is_managed, remote_id, public_id, url, title, description, properties, added_by_profile_id, created_at, updated_at, deleted_at FROM "profile_resource"
WHERE id = $1
  AND deleted_at IS NULL
`

type GetProfileResourceByIDParams struct {
	ID string `db:"id" json:"id"`
}

// GetProfileResourceByID
//
//	SELECT id, profile_id, kind, is_managed, remote_id, public_id, url, title, description, properties, added_by_profile_id, created_at, updated_at, deleted_at FROM "profile_resource"
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) GetProfileResourceByID(ctx context.Context, arg GetProfileResourceByIDParams) (*ProfileResource, error) {
	row := q.db.QueryRowContext(ctx, getProfileResourceByID, arg.ID)
	var i ProfileResource
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Kind,
		&i.IsManaged,
		&i.RemoteID,
		&i.PublicID,
		&i.URL,
		&i.Title,
		&i.Description,
		&i.Properties,
		&i.AddedByProfileID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getProfileResourceByRemoteID = `-- name: GetProfileResourceByRemoteID :one
SELECT id, profile_id, kind, is_managed, remote_id, public_id, url, title, description, properties, added_by_profile_id, created_at, updated_at, deleted_at FROM "profile_resource"
WHERE profile_id = $1
  AND kind = $2
  AND remote_id = $3
  AND deleted_at IS NULL
`

type GetProfileResourceByRemoteIDParams struct {
	ProfileID string         `db:"profile_id" json:"profile_id"`
	Kind      string         `db:"kind" json:"kind"`
	RemoteID  sql.NullString `db:"remote_id" json:"remote_id"`
}

// GetProfileResourceByRemoteID
//
//	SELECT id, profile_id, kind, is_managed, remote_id, public_id, url, title, description, properties, added_by_profile_id, created_at, updated_at, deleted_at FROM "profile_resource"
//	WHERE profile_id = $1
//	  AND kind = $2
//	  AND remote_id = $3
//	  AND deleted_at IS NULL
func (q *Queries) GetProfileResourceByRemoteID(ctx context.Context, arg GetProfileResourceByRemoteIDParams) (*ProfileResource, error) {
	row := q.db.QueryRowContext(ctx, getProfileResourceByRemoteID, arg.ProfileID, arg.Kind, arg.RemoteID)
	var i ProfileResource
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Kind,
		&i.IsManaged,
		&i.RemoteID,
		&i.PublicID,
		&i.URL,
		&i.Title,
		&i.Description,
		&i.Properties,
		&i.AddedByProfileID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getProfileTxByID = `-- name: GetProfileTxByID :many
SELECT pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector
FROM "profile_tx" pt
WHERE pt.profile_id = $1
`

type GetProfileTxByIDParams struct {
	ID string `db:"id" json:"id"`
}

type GetProfileTxByIDRow struct {
	ProfileTx ProfileTx `db:"profile_tx" json:"profile_tx"`
}

// GetProfileTxByID
//
//	SELECT pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector
//	FROM "profile_tx" pt
//	WHERE pt.profile_id = $1
func (q *Queries) GetProfileTxByID(ctx context.Context, arg GetProfileTxByIDParams) ([]*GetProfileTxByIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfileTxByID, arg.ID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetProfileTxByIDRow{}
	for rows.Next() {
		var i GetProfileTxByIDRow
		if err := rows.Scan(
			&i.ProfileTx.ProfileID,
			&i.ProfileTx.LocaleCode,
			&i.ProfileTx.Title,
			&i.ProfileTx.Description,
			&i.ProfileTx.Properties,
			&i.ProfileTx.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfilesByIDs = `-- name: GetProfilesByIDs :many
SELECT p.id, p.slug, p.kind, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, p.approved_at, p.points, p.hide_relations, p.hide_links, p.default_locale, p.hide_qa, pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector
FROM "profile" p
  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
  AND pt.locale_code = (
    SELECT ptf.locale_code FROM "profile_tx" ptf
    WHERE ptf.profile_id = p.id
    AND (ptf.locale_code = $1 OR ptf.locale_code = p.default_locale)
    ORDER BY CASE WHEN ptf.locale_code = $1 THEN 0 ELSE 1 END
    LIMIT 1
  )
WHERE p.id = ANY($2::TEXT[])
  AND p.deleted_at IS NULL
`

type GetProfilesByIDsParams struct {
	LocaleCode string   `db:"locale_code" json:"locale_code"`
	Ids        []string `db:"ids" json:"ids"`
}

type GetProfilesByIDsRow struct {
	Profile   Profile   `db:"profile" json:"profile"`
	ProfileTx ProfileTx `db:"profile_tx" json:"profile_tx"`
}

// GetProfilesByIDs
//
//	SELECT p.id, p.slug, p.kind, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, p.approved_at, p.points, p.hide_relations, p.hide_links, p.default_locale, p.hide_qa, pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector
//	FROM "profile" p
//	  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
//	  AND pt.locale_code = (
//	    SELECT ptf.locale_code FROM "profile_tx" ptf
//	    WHERE ptf.profile_id = p.id
//	    AND (ptf.locale_code = $1 OR ptf.locale_code = p.default_locale)
//	    ORDER BY CASE WHEN ptf.locale_code = $1 THEN 0 ELSE 1 END
//	    LIMIT 1
//	  )
//	WHERE p.id = ANY($2::TEXT[])
//	  AND p.deleted_at IS NULL
func (q *Queries) GetProfilesByIDs(ctx context.Context, arg GetProfilesByIDsParams) ([]*GetProfilesByIDsRow, error) {
	rows, err := q.db.QueryContext(ctx, getProfilesByIDs, arg.LocaleCode, pq.Array(arg.Ids))
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetProfilesByIDsRow{}
	for rows.Next() {
		var i GetProfilesByIDsRow
		if err := rows.Scan(
			&i.Profile.ID,
			&i.Profile.Slug,
			&i.Profile.Kind,
			&i.Profile.ProfilePictureURI,
			&i.Profile.Pronouns,
			&i.Profile.Properties,
			&i.Profile.CreatedAt,
			&i.Profile.UpdatedAt,
			&i.Profile.DeletedAt,
			&i.Profile.ApprovedAt,
			&i.Profile.Points,
			&i.Profile.HideRelations,
			&i.Profile.HideLinks,
			&i.Profile.DefaultLocale,
			&i.Profile.HideQa,
			&i.ProfileTx.ProfileID,
			&i.ProfileTx.LocaleCode,
			&i.ProfileTx.Title,
			&i.ProfileTx.Description,
			&i.ProfileTx.Properties,
			&i.ProfileTx.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserBriefInfoByID = `-- name: GetUserBriefInfoByID :one
SELECT kind, individual_profile_id
FROM "user"
WHERE id = $1
  AND deleted_at IS NULL
LIMIT 1
`

type GetUserBriefInfoByIDParams struct {
	UserID string `db:"user_id" json:"user_id"`
}

type GetUserBriefInfoByIDRow struct {
	Kind                string         `db:"kind" json:"kind"`
	IndividualProfileID sql.NullString `db:"individual_profile_id" json:"individual_profile_id"`
}

// GetUserBriefInfoByID
//
//	SELECT kind, individual_profile_id
//	FROM "user"
//	WHERE id = $1
//	  AND deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetUserBriefInfoByID(ctx context.Context, arg GetUserBriefInfoByIDParams) (*GetUserBriefInfoByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserBriefInfoByID, arg.UserID)
	var i GetUserBriefInfoByIDRow
	err := row.Scan(&i.Kind, &i.IndividualProfileID)
	return &i, err
}

const getUserProfilePermissions = `-- name: GetUserProfilePermissions :many
SELECT
  p.id,
  p.slug,
  p.kind as profile_kind,
  COALESCE(pm.kind, '') as membership_kind,
  u.kind as user_kind
FROM "profile" p
LEFT JOIN "profile_membership" pm ON p.id = pm.profile_id AND pm.deleted_at IS NULL
LEFT JOIN "profile" up ON pm.member_profile_id = up.id AND up.deleted_at IS NULL
LEFT JOIN "user" u ON up.id = u.individual_profile_id
WHERE u.id = $1
  AND p.deleted_at IS NULL
  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
`

type GetUserProfilePermissionsParams struct {
	UserID string `db:"user_id" json:"user_id"`
}

type GetUserProfilePermissionsRow struct {
	ID             string         `db:"id" json:"id"`
	Slug           string         `db:"slug" json:"slug"`
	ProfileKind    string         `db:"profile_kind" json:"profile_kind"`
	MembershipKind string         `db:"membership_kind" json:"membership_kind"`
	UserKind       sql.NullString `db:"user_kind" json:"user_kind"`
}

// GetUserProfilePermissions
//
//	SELECT
//	  p.id,
//	  p.slug,
//	  p.kind as profile_kind,
//	  COALESCE(pm.kind, '') as membership_kind,
//	  u.kind as user_kind
//	FROM "profile" p
//	LEFT JOIN "profile_membership" pm ON p.id = pm.profile_id AND pm.deleted_at IS NULL
//	LEFT JOIN "profile" up ON pm.member_profile_id = up.id AND up.deleted_at IS NULL
//	LEFT JOIN "user" u ON up.id = u.individual_profile_id
//	WHERE u.id = $1
//	  AND p.deleted_at IS NULL
//	  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
func (q *Queries) GetUserProfilePermissions(ctx context.Context, arg GetUserProfilePermissionsParams) ([]*GetUserProfilePermissionsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserProfilePermissions, arg.UserID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetUserProfilePermissionsRow{}
	for rows.Next() {
		var i GetUserProfilePermissionsRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.ProfileKind,
			&i.MembershipKind,
			&i.UserKind,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllProfileLinksByProfileID = `-- name: ListAllProfileLinksByProfileID :many
SELECT
  pl.id,
  pl.kind,
  pl.public_id,
  pl.uri,
  pl.is_verified,
  pl.is_managed,
  pl.is_featured,
  pl.visibility,
  COALESCE(plt.title, plt_def.title, pl.kind) as title,
  COALESCE(plt.icon, plt_def.icon, '') as icon,
  COALESCE(plt."group", plt_def."group", '') as "group",
  COALESCE(plt.description, plt_def.description, '') as description
FROM "profile_link" pl
  INNER JOIN "profile" p ON p.id = pl.profile_id
  LEFT JOIN "profile_link_tx" plt ON plt.profile_link_id = pl.id
    AND plt.locale_code = $1
  LEFT JOIN "profile_link_tx" plt_def ON plt_def.profile_link_id = pl.id
    AND plt_def.locale_code = p.default_locale
WHERE pl.profile_id = $2
  AND pl.deleted_at IS NULL
ORDER BY pl."order"
`

type ListAllProfileLinksByProfileIDParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	ProfileID  string `db:"profile_id" json:"profile_id"`
}

type ListAllProfileLinksByProfileIDRow struct {
	ID          string         `db:"id" json:"id"`
	Kind        string         `db:"kind" json:"kind"`
	PublicID    sql.NullString `db:"public_id" json:"public_id"`
	URI         sql.NullString `db:"uri" json:"uri"`
	IsVerified  bool           `db:"is_verified" json:"is_verified"`
	IsManaged   bool           `db:"is_managed" json:"is_managed"`
	IsFeatured  bool           `db:"is_featured" json:"is_featured"`
	Visibility  string         `db:"visibility" json:"visibility"`
	Title       string         `db:"title" json:"title"`
	Icon        string         `db:"icon" json:"icon"`
	Group       string         `db:"group" json:"group"`
	Description string         `db:"description" json:"description"`
}

// ListAllProfileLinksByProfileID
//
//	SELECT
//	  pl.id,
//	  pl.kind,
//	  pl.public_id,
//	  pl.uri,
//	  pl.is_verified,
//	  pl.is_managed,
//	  pl.is_featured,
//	  pl.visibility,
//	  COALESCE(plt.title, plt_def.title, pl.kind) as title,
//	  COALESCE(plt.icon, plt_def.icon, '') as icon,
//	  COALESCE(plt."group", plt_def."group", '') as "group",
//	  COALESCE(plt.description, plt_def.description, '') as description
//	FROM "profile_link" pl
//	  INNER JOIN "profile" p ON p.id = pl.profile_id
//	  LEFT JOIN "profile_link_tx" plt ON plt.profile_link_id = pl.id
//	    AND plt.locale_code = $1
//	  LEFT JOIN "profile_link_tx" plt_def ON plt_def.profile_link_id = pl.id
//	    AND plt_def.locale_code = p.default_locale
//	WHERE pl.profile_id = $2
//	  AND pl.deleted_at IS NULL
//	ORDER BY pl."order"
func (q *Queries) ListAllProfileLinksByProfileID(ctx context.Context, arg ListAllProfileLinksByProfileIDParams) ([]*ListAllProfileLinksByProfileIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllProfileLinksByProfileID, arg.LocaleCode, arg.ProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListAllProfileLinksByProfileIDRow{}
	for rows.Next() {
		var i ListAllProfileLinksByProfileIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.PublicID,
			&i.URI,
			&i.IsVerified,
			&i.IsManaged,
			&i.IsFeatured,
			&i.Visibility,
			&i.Title,
			&i.Icon,
			&i.Group,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAllProfilesForAdmin = `-- name: ListAllProfilesForAdmin :many
SELECT
  p.id,
  p.slug,
  p.kind,
  p.profile_picture_uri,
  p.pronouns,
  p.properties,
  p.created_at,
  p.updated_at,
  p.points,
  COALESCE(pt.title, '') as title,
  COALESCE(pt.description, '') as description,
  pt.profile_id IS NOT NULL as has_translation
FROM "profile" p
  LEFT JOIN "profile_tx" pt ON pt.profile_id = p.id
  AND pt.locale_code = $1
WHERE p.deleted_at IS NULL
  AND ($2::TEXT IS NULL OR p.kind = ANY(string_to_array($2::TEXT, ',')))
ORDER BY p.created_at DESC
LIMIT $4
OFFSET $3
`

type ListAllProfilesForAdminParams struct {
	LocaleCode  string         `db:"locale_code" json:"locale_code"`
	FilterKind  sql.NullString `db:"filter_kind" json:"filter_kind"`
	OffsetCount int32          `db:"offset_count" json:"offset_count"`
	LimitCount  int32          `db:"limit_count" json:"limit_count"`
}

type ListAllProfilesForAdminRow struct {
	ID                string                `db:"id" json:"id"`
	Slug              string                `db:"slug" json:"slug"`
	Kind              string                `db:"kind" json:"kind"`
	ProfilePictureURI sql.NullString        `db:"profile_picture_uri" json:"profile_picture_uri"`
	Pronouns          sql.NullString        `db:"pronouns" json:"pronouns"`
	Properties        pqtype.NullRawMessage `db:"properties" json:"properties"`
	CreatedAt         time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt         sql.NullTime          `db:"updated_at" json:"updated_at"`
	Points            int32                 `db:"points" json:"points"`
	Title             string                `db:"title" json:"title"`
	Description       string                `db:"description" json:"description"`
	HasTranslation    interface{}           `db:"has_translation" json:"has_translation"`
}

// ListAllProfilesForAdmin
//
//	SELECT
//	  p.id,
//	  p.slug,
//	  p.kind,
//	  p.profile_picture_uri,
//	  p.pronouns,
//	  p.properties,
//	  p.created_at,
//	  p.updated_at,
//	  p.points,
//	  COALESCE(pt.title, '') as title,
//	  COALESCE(pt.description, '') as description,
//	  pt.profile_id IS NOT NULL as has_translation
//	FROM "profile" p
//	  LEFT JOIN "profile_tx" pt ON pt.profile_id = p.id
//	  AND pt.locale_code = $1
//	WHERE p.deleted_at IS NULL
//	  AND ($2::TEXT IS NULL OR p.kind = ANY(string_to_array($2::TEXT, ',')))
//	ORDER BY p.created_at DESC
//	LIMIT $4
//	OFFSET $3
func (q *Queries) ListAllProfilesForAdmin(ctx context.Context, arg ListAllProfilesForAdminParams) ([]*ListAllProfilesForAdminRow, error) {
	rows, err := q.db.QueryContext(ctx, listAllProfilesForAdmin,
		arg.LocaleCode,
		arg.FilterKind,
		arg.OffsetCount,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListAllProfilesForAdminRow{}
	for rows.Next() {
		var i ListAllProfilesForAdminRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Kind,
			&i.ProfilePictureURI,
			&i.Pronouns,
			&i.Properties,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Points,
			&i.Title,
			&i.Description,
			&i.HasTranslation,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCustomDomainsByProfileID = `-- name: ListCustomDomainsByProfileID :many
SELECT pcd.id, pcd.profile_id, pcd.domain, pcd.default_locale, pcd.created_at, pcd.updated_at
FROM "profile_custom_domain" pcd
WHERE pcd.profile_id = $1
ORDER BY pcd.created_at
`

type ListCustomDomainsByProfileIDParams struct {
	ProfileID string `db:"profile_id" json:"profile_id"`
}

// ListCustomDomainsByProfileID
//
//	SELECT pcd.id, pcd.profile_id, pcd.domain, pcd.default_locale, pcd.created_at, pcd.updated_at
//	FROM "profile_custom_domain" pcd
//	WHERE pcd.profile_id = $1
//	ORDER BY pcd.created_at
func (q *Queries) ListCustomDomainsByProfileID(ctx context.Context, arg ListCustomDomainsByProfileIDParams) ([]*ProfileCustomDomain, error) {
	rows, err := q.db.QueryContext(ctx, listCustomDomainsByProfileID, arg.ProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ProfileCustomDomain{}
	for rows.Next() {
		var i ProfileCustomDomain
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Domain,
			&i.DefaultLocale,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listFeaturedProfileLinksByProfileID = `-- name: ListFeaturedProfileLinksByProfileID :many
SELECT
  pl.id,
  pl.kind,
  pl.public_id,
  pl.uri,
  pl.is_verified,
  pl.is_managed,
  pl.is_featured,
  pl.visibility,
  COALESCE(plt.title, plt_def.title, pl.kind) as title,
  COALESCE(plt.icon, plt_def.icon, '') as icon,
  COALESCE(plt."group", plt_def."group", '') as "group",
  COALESCE(plt.description, plt_def.description, '') as description
FROM "profile_link" pl
  INNER JOIN "profile" p ON p.id = pl.profile_id
  LEFT JOIN "profile_link_tx" plt ON plt.profile_link_id = pl.id
    AND plt.locale_code = $1
  LEFT JOIN "profile_link_tx" plt_def ON plt_def.profile_link_id = pl.id
    AND plt_def.locale_code = p.default_locale
WHERE pl.profile_id = $2
  AND pl.is_featured = TRUE
  AND pl.deleted_at IS NULL
ORDER BY pl."order"
`

type ListFeaturedProfileLinksByProfileIDParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	ProfileID  string `db:"profile_id" json:"profile_id"`
}

type ListFeaturedProfileLinksByProfileIDRow struct {
	ID          string         `db:"id" json:"id"`
	Kind        string         `db:"kind" json:"kind"`
	PublicID    sql.NullString `db:"public_id" json:"public_id"`
	URI         sql.NullString `db:"uri" json:"uri"`
	IsVerified  bool           `db:"is_verified" json:"is_verified"`
	IsManaged   bool           `db:"is_managed" json:"is_managed"`
	IsFeatured  bool           `db:"is_featured" json:"is_featured"`
	Visibility  string         `db:"visibility" json:"visibility"`
	Title       string         `db:"title" json:"title"`
	Icon        string         `db:"icon" json:"icon"`
	Group       string         `db:"group" json:"group"`
	Description string         `db:"description" json:"description"`
}

// ListFeaturedProfileLinksByProfileID
//
//	SELECT
//	  pl.id,
//	  pl.kind,
//	  pl.public_id,
//	  pl.uri,
//	  pl.is_verified,
//	  pl.is_managed,
//	  pl.is_featured,
//	  pl.visibility,
//	  COALESCE(plt.title, plt_def.title, pl.kind) as title,
//	  COALESCE(plt.icon, plt_def.icon, '') as icon,
//	  COALESCE(plt."group", plt_def."group", '') as "group",
//	  COALESCE(plt.description, plt_def.description, '') as description
//	FROM "profile_link" pl
//	  INNER JOIN "profile" p ON p.id = pl.profile_id
//	  LEFT JOIN "profile_link_tx" plt ON plt.profile_link_id = pl.id
//	    AND plt.locale_code = $1
//	  LEFT JOIN "profile_link_tx" plt_def ON plt_def.profile_link_id = pl.id
//	    AND plt_def.locale_code = p.default_locale
//	WHERE pl.profile_id = $2
//	  AND pl.is_featured = TRUE
//	  AND pl.deleted_at IS NULL
//	ORDER BY pl."order"
func (q *Queries) ListFeaturedProfileLinksByProfileID(ctx context.Context, arg ListFeaturedProfileLinksByProfileIDParams) ([]*ListFeaturedProfileLinksByProfileIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listFeaturedProfileLinksByProfileID, arg.LocaleCode, arg.ProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListFeaturedProfileLinksByProfileIDRow{}
	for rows.Next() {
		var i ListFeaturedProfileLinksByProfileIDRow
		if err := rows.Scan(
			&i.ID,
			&i.Kind,
			&i.PublicID,
			&i.URI,
			&i.IsVerified,
			&i.IsManaged,
			&i.IsFeatured,
			&i.Visibility,
			&i.Title,
			&i.Icon,
			&i.Group,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGitHubResourcesForSync = `-- name: ListGitHubResourcesForSync :many
SELECT
  pr.id as resource_id,
  pr.profile_id,
  pr.remote_id,
  pr.public_id,
  pr.properties as resource_properties,
  pl.auth_access_token
FROM "profile_resource" pr
JOIN "profile_link" pl ON pl.profile_id = pr.profile_id
  AND pl.kind = 'github'
  AND pl.is_managed = true
  AND pl.auth_access_token IS NOT NULL
  AND pl.deleted_at IS NULL
WHERE pr.kind = 'github_repo'
  AND pr.deleted_at IS NULL
ORDER BY pr.profile_id
LIMIT $1
`

type ListGitHubResourcesForSyncParams struct {
	BatchSize int32 `db:"batch_size" json:"batch_size"`
}

type ListGitHubResourcesForSyncRow struct {
	ResourceID         string                `db:"resource_id" json:"resource_id"`
	ProfileID          string                `db:"profile_id" json:"profile_id"`
	RemoteID           sql.NullString        `db:"remote_id" json:"remote_id"`
	PublicID           sql.NullString        `db:"public_id" json:"public_id"`
	ResourceProperties pqtype.NullRawMessage `db:"resource_properties" json:"resource_properties"`
	AuthAccessToken    sql.NullString        `db:"auth_access_token" json:"auth_access_token"`
}

// ListGitHubResourcesForSync
//
//	SELECT
//	  pr.id as resource_id,
//	  pr.profile_id,
//	  pr.remote_id,
//	  pr.public_id,
//	  pr.properties as resource_properties,
//	  pl.auth_access_token
//	FROM "profile_resource" pr
//	JOIN "profile_link" pl ON pl.profile_id = pr.profile_id
//	  AND pl.kind = 'github'
//	  AND pl.is_managed = true
//	  AND pl.auth_access_token IS NOT NULL
//	  AND pl.deleted_at IS NULL
//	WHERE pr.kind = 'github_repo'
//	  AND pr.deleted_at IS NULL
//	ORDER BY pr.profile_id
//	LIMIT $1
func (q *Queries) ListGitHubResourcesForSync(ctx context.Context, arg ListGitHubResourcesForSyncParams) ([]*ListGitHubResourcesForSyncRow, error) {
	rows, err := q.db.QueryContext(ctx, listGitHubResourcesForSync, arg.BatchSize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListGitHubResourcesForSyncRow{}
	for rows.Next() {
		var i ListGitHubResourcesForSyncRow
		if err := rows.Scan(
			&i.ResourceID,
			&i.ProfileID,
			&i.RemoteID,
			&i.PublicID,
			&i.ResourceProperties,
			&i.AuthAccessToken,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfileLinksByProfileID = `-- name: ListProfileLinksByProfileID :many
SELECT
  pl.id, pl.profile_id, pl.kind, pl."order", pl.is_managed, pl.is_verified, pl.remote_id, pl.public_id, pl.uri, pl.auth_provider, pl.auth_access_token_scope, pl.auth_access_token, pl.auth_access_token_expires_at, pl.auth_refresh_token, pl.auth_refresh_token_expires_at, pl.properties, pl.created_at, pl.updated_at, pl.deleted_at, pl.visibility, pl.is_featured,
  COALESCE(plt.profile_link_id, plt_def.profile_link_id, pl.id) as profile_link_id,
  COALESCE(plt.locale_code, plt_def.locale_code, p.default_locale) as locale_code,
  COALESCE(plt.title, plt_def.title, pl.kind) as title,
  COALESCE(plt.icon, plt_def.icon, '') as icon,
  plt."group" as "group",
  plt.description as description
FROM "profile_link" pl
  INNER JOIN "profile" p ON p.id = pl.profile_id
  LEFT JOIN "profile_link_tx" plt ON plt.profile_link_id = pl.id
    AND plt.locale_code = $1
  LEFT JOIN "profile_link_tx" plt_def ON plt_def.profile_link_id = pl.id
    AND plt_def.locale_code = p.default_locale
WHERE pl.profile_id = $2
  AND pl.deleted_at IS NULL
ORDER BY pl."order"
`

type ListProfileLinksByProfileIDParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	ProfileID  string `db:"profile_id" json:"profile_id"`
}

type ListProfileLinksByProfileIDRow struct {
	ID                        string                `db:"id" json:"id"`
	ProfileID                 string                `db:"profile_id" json:"profile_id"`
	Kind                      string                `db:"kind" json:"kind"`
	Order                     int32                 `db:"order" json:"order"`
	IsManaged                 bool                  `db:"is_managed" json:"is_managed"`
	IsVerified                bool                  `db:"is_verified" json:"is_verified"`
	RemoteID                  sql.NullString        `db:"remote_id" json:"remote_id"`
	PublicID                  sql.NullString        `db:"public_id" json:"public_id"`
	URI                       sql.NullString        `db:"uri" json:"uri"`
	AuthProvider              sql.NullString        `db:"auth_provider" json:"auth_provider"`
	AuthAccessTokenScope      sql.NullString        `db:"auth_access_token_scope" json:"auth_access_token_scope"`
	AuthAccessToken           sql.NullString        `db:"auth_access_token" json:"auth_access_token"`
	AuthAccessTokenExpiresAt  sql.NullTime          `db:"auth_access_token_expires_at" json:"auth_access_token_expires_at"`
	AuthRefreshToken          sql.NullString        `db:"auth_refresh_token" json:"auth_refresh_token"`
	AuthRefreshTokenExpiresAt sql.NullTime          `db:"auth_refresh_token_expires_at" json:"auth_refresh_token_expires_at"`
	Properties                pqtype.NullRawMessage `db:"properties" json:"properties"`
	CreatedAt                 time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt                 sql.NullTime          `db:"updated_at" json:"updated_at"`
	DeletedAt                 sql.NullTime          `db:"deleted_at" json:"deleted_at"`
	Visibility                string                `db:"visibility" json:"visibility"`
	IsFeatured                bool                  `db:"is_featured" json:"is_featured"`
	ProfileLinkID             string                `db:"profile_link_id" json:"profile_link_id"`
	LocaleCode                string                `db:"locale_code" json:"locale_code"`
	Title                     string                `db:"title" json:"title"`
	Icon                      string                `db:"icon" json:"icon"`
	Group                     sql.NullString        `db:"group" json:"group"`
	Description               sql.NullString        `db:"description" json:"description"`
}

// ListProfileLinksByProfileID
//
//	SELECT
//	  pl.id, pl.profile_id, pl.kind, pl."order", pl.is_managed, pl.is_verified, pl.remote_id, pl.public_id, pl.uri, pl.auth_provider, pl.auth_access_token_scope, pl.auth_access_token, pl.auth_access_token_expires_at, pl.auth_refresh_token, pl.auth_refresh_token_expires_at, pl.properties, pl.created_at, pl.updated_at, pl.deleted_at, pl.visibility, pl.is_featured,
//	  COALESCE(plt.profile_link_id, plt_def.profile_link_id, pl.id) as profile_link_id,
//	  COALESCE(plt.locale_code, plt_def.locale_code, p.default_locale) as locale_code,
//	  COALESCE(plt.title, plt_def.title, pl.kind) as title,
//	  COALESCE(plt.icon, plt_def.icon, '') as icon,
//	  plt."group" as "group",
//	  plt.description as description
//	FROM "profile_link" pl
//	  INNER JOIN "profile" p ON p.id = pl.profile_id
//	  LEFT JOIN "profile_link_tx" plt ON plt.profile_link_id = pl.id
//	    AND plt.locale_code = $1
//	  LEFT JOIN "profile_link_tx" plt_def ON plt_def.profile_link_id = pl.id
//	    AND plt_def.locale_code = p.default_locale
//	WHERE pl.profile_id = $2
//	  AND pl.deleted_at IS NULL
//	ORDER BY pl."order"
func (q *Queries) ListProfileLinksByProfileID(ctx context.Context, arg ListProfileLinksByProfileIDParams) ([]*ListProfileLinksByProfileIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listProfileLinksByProfileID, arg.LocaleCode, arg.ProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListProfileLinksByProfileIDRow{}
	for rows.Next() {
		var i ListProfileLinksByProfileIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Kind,
			&i.Order,
			&i.IsManaged,
			&i.IsVerified,
			&i.RemoteID,
			&i.PublicID,
			&i.URI,
			&i.AuthProvider,
			&i.AuthAccessTokenScope,
			&i.AuthAccessToken,
			&i.AuthAccessTokenExpiresAt,
			&i.AuthRefreshToken,
			&i.AuthRefreshTokenExpiresAt,
			&i.Properties,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Visibility,
			&i.IsFeatured,
			&i.ProfileLinkID,
			&i.LocaleCode,
			&i.Title,
			&i.Icon,
			&i.Group,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfileLinksForKind = `-- name: ListProfileLinksForKind :many
SELECT
  pl.id, pl.profile_id, pl.kind, pl."order", pl.is_managed, pl.is_verified, pl.remote_id, pl.public_id, pl.uri, pl.auth_provider, pl.auth_access_token_scope, pl.auth_access_token, pl.auth_access_token_expires_at, pl.auth_refresh_token, pl.auth_refresh_token_expires_at, pl.properties, pl.created_at, pl.updated_at, pl.deleted_at, pl.visibility, pl.is_featured,
  COALESCE(plt.profile_link_id, plt_def.profile_link_id, pl.id) as profile_link_id,
  COALESCE(plt.locale_code, plt_def.locale_code, p.default_locale) as locale_code,
  COALESCE(plt.title, plt_def.title, pl.kind) as title,
  plt."group" as "group",
  plt.description as description
FROM "profile_link" pl
  INNER JOIN "profile" p ON p.id = pl.profile_id
    AND p.deleted_at IS NULL
  LEFT JOIN "profile_link_tx" plt ON plt.profile_link_id = pl.id
    AND plt.locale_code = $1
  LEFT JOIN "profile_link_tx" plt_def ON plt_def.profile_link_id = pl.id
    AND plt_def.locale_code = p.default_locale
WHERE pl.kind = $2
  AND pl.deleted_at IS NULL
ORDER BY pl."order"
`

type ListProfileLinksForKindParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	Kind       string `db:"kind" json:"kind"`
}

type ListProfileLinksForKindRow struct {
	ID                        string                `db:"id" json:"id"`
	ProfileID                 string                `db:"profile_id" json:"profile_id"`
	Kind                      string                `db:"kind" json:"kind"`
	Order                     int32                 `db:"order" json:"order"`
	IsManaged                 bool                  `db:"is_managed" json:"is_managed"`
	IsVerified                bool                  `db:"is_verified" json:"is_verified"`
	RemoteID                  sql.NullString        `db:"remote_id" json:"remote_id"`
	PublicID                  sql.NullString        `db:"public_id" json:"public_id"`
	URI                       sql.NullString        `db:"uri" json:"uri"`
	AuthProvider              sql.NullString        `db:"auth_provider" json:"auth_provider"`
	AuthAccessTokenScope      sql.NullString        `db:"auth_access_token_scope" json:"auth_access_token_scope"`
	AuthAccessToken           sql.NullString        `db:"auth_access_token" json:"auth_access_token"`
	AuthAccessTokenExpiresAt  sql.NullTime          `db:"auth_access_token_expires_at" json:"auth_access_token_expires_at"`
	AuthRefreshToken          sql.NullString        `db:"auth_refresh_token" json:"auth_refresh_token"`
	AuthRefreshTokenExpiresAt sql.NullTime          `db:"auth_refresh_token_expires_at" json:"auth_refresh_token_expires_at"`
	Properties                pqtype.NullRawMessage `db:"properties" json:"properties"`
	CreatedAt                 time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt                 sql.NullTime          `db:"updated_at" json:"updated_at"`
	DeletedAt                 sql.NullTime          `db:"deleted_at" json:"deleted_at"`
	Visibility                string                `db:"visibility" json:"visibility"`
	IsFeatured                bool                  `db:"is_featured" json:"is_featured"`
	ProfileLinkID             string                `db:"profile_link_id" json:"profile_link_id"`
	LocaleCode                string                `db:"locale_code" json:"locale_code"`
	Title                     string                `db:"title" json:"title"`
	Group                     sql.NullString        `db:"group" json:"group"`
	Description               sql.NullString        `db:"description" json:"description"`
}

// ListProfileLinksForKind
//
//	SELECT
//	  pl.id, pl.profile_id, pl.kind, pl."order", pl.is_managed, pl.is_verified, pl.remote_id, pl.public_id, pl.uri, pl.auth_provider, pl.auth_access_token_scope, pl.auth_access_token, pl.auth_access_token_expires_at, pl.auth_refresh_token, pl.auth_refresh_token_expires_at, pl.properties, pl.created_at, pl.updated_at, pl.deleted_at, pl.visibility, pl.is_featured,
//	  COALESCE(plt.profile_link_id, plt_def.profile_link_id, pl.id) as profile_link_id,
//	  COALESCE(plt.locale_code, plt_def.locale_code, p.default_locale) as locale_code,
//	  COALESCE(plt.title, plt_def.title, pl.kind) as title,
//	  plt."group" as "group",
//	  plt.description as description
//	FROM "profile_link" pl
//	  INNER JOIN "profile" p ON p.id = pl.profile_id
//	    AND p.deleted_at IS NULL
//	  LEFT JOIN "profile_link_tx" plt ON plt.profile_link_id = pl.id
//	    AND plt.locale_code = $1
//	  LEFT JOIN "profile_link_tx" plt_def ON plt_def.profile_link_id = pl.id
//	    AND plt_def.locale_code = p.default_locale
//	WHERE pl.kind = $2
//	  AND pl.deleted_at IS NULL
//	ORDER BY pl."order"
func (q *Queries) ListProfileLinksForKind(ctx context.Context, arg ListProfileLinksForKindParams) ([]*ListProfileLinksForKindRow, error) {
	rows, err := q.db.QueryContext(ctx, listProfileLinksForKind, arg.LocaleCode, arg.Kind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListProfileLinksForKindRow{}
	for rows.Next() {
		var i ListProfileLinksForKindRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Kind,
			&i.Order,
			&i.IsManaged,
			&i.IsVerified,
			&i.RemoteID,
			&i.PublicID,
			&i.URI,
			&i.AuthProvider,
			&i.AuthAccessTokenScope,
			&i.AuthAccessToken,
			&i.AuthAccessTokenExpiresAt,
			&i.AuthRefreshToken,
			&i.AuthRefreshTokenExpiresAt,
			&i.Properties,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Visibility,
			&i.IsFeatured,
			&i.ProfileLinkID,
			&i.LocaleCode,
			&i.Title,
			&i.Group,
			&i.Description,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfileMemberships = `-- name: ListProfileMemberships :many
SELECT
  pm.id, pm.profile_id, pm.member_profile_id, pm.kind, pm.properties, pm.started_at, pm.finished_at, pm.deleted_at,
  p1.id, p1.slug, p1.kind, p1.profile_picture_uri, p1.pronouns, p1.properties, p1.created_at, p1.updated_at, p1.deleted_at, p1.approved_at, p1.points, p1.hide_relations, p1.hide_links, p1.default_locale, p1.hide_qa,
  p1t.profile_id, p1t.locale_code, p1t.title, p1t.description, p1t.properties, p1t.search_vector,
  p2.id, p2.slug, p2.kind, p2.profile_picture_uri, p2.pronouns, p2.properties, p2.created_at, p2.updated_at, p2.deleted_at, p2.approved_at, p2.points, p2.hide_relations, p2.hide_links, p2.default_locale, p2.hide_qa,
  p2t.profile_id, p2t.locale_code, p2t.title, p2t.description, p2t.properties, p2t.search_vector
FROM
	"profile_membership" pm
  INNER JOIN "profile" p1 ON p1.id = pm.profile_id
    AND ($1::TEXT IS NULL OR p1.kind = ANY(string_to_array($1::TEXT, ',')))
    AND p1.approved_at IS NOT NULL
    AND p1.deleted_at IS NULL
  INNER JOIN "profile_tx" p1t ON p1t.profile_id = p1.id
	  AND p1t.locale_code = (
      SELECT p1tf.locale_code FROM "profile_tx" p1tf
      WHERE p1tf.profile_id = p1.id
      AND (p1tf.locale_code = $2 OR p1tf.locale_code = p1.default_locale)
      ORDER BY CASE WHEN p1tf.locale_code = $2 THEN 0 ELSE 1 END
      LIMIT 1
    )
  INNER JOIN "profile" p2 ON p2.id = pm.member_profile_id
    AND ($3::TEXT IS NULL OR p2.kind = ANY(string_to_array($3::TEXT, ',')))
    AND p2.approved_at IS NOT NULL
    AND p2.deleted_at IS NULL
  INNER JOIN "profile_tx" p2t ON p2t.profile_id = p2.id
	  AND p2t.locale_code = (
      SELECT p2tf.locale_code FROM "profile_tx" p2tf
      WHERE p2tf.profile_id = p2.id
      AND (p2tf.locale_code = $2 OR p2tf.locale_code = p2.default_locale)
      ORDER BY CASE WHEN p2tf.locale_code = $2 THEN 0 ELSE 1 END
      LIMIT 1
    )
WHERE pm.deleted_at IS NULL
    AND ($4::TEXT IS NULL OR pm.profile_id = $4::TEXT)
    AND ($5::TEXT IS NULL OR pm.member_profile_id = $5::TEXT)
`

type ListProfileMembershipsParams struct {
	FilterProfileKind       sql.NullString `db:"filter_profile_kind" json:"filter_profile_kind"`
	LocaleCode              string         `db:"locale_code" json:"locale_code"`
	FilterMemberProfileKind sql.NullString `db:"filter_member_profile_kind" json:"filter_member_profile_kind"`
	FilterProfileID         sql.NullString `db:"filter_profile_id" json:"filter_profile_id"`
	FilterMemberProfileID   sql.NullString `db:"filter_member_profile_id" json:"filter_member_profile_id"`
}

type ListProfileMembershipsRow struct {
	ProfileMembership ProfileMembership `db:"profile_membership" json:"profile_membership"`
	Profile           Profile           `db:"profile" json:"profile"`
	ProfileTx         ProfileTx         `db:"profile_tx" json:"profile_tx"`
	Profile_2         Profile           `db:"profile_2" json:"profile_2"`
	ProfileTx_2       ProfileTx         `db:"profile_tx_2" json:"profile_tx_2"`
}

// ListProfileMemberships
//
//	SELECT
//	  pm.id, pm.profile_id, pm.member_profile_id, pm.kind, pm.properties, pm.started_at, pm.finished_at, pm.deleted_at,
//	  p1.id, p1.slug, p1.kind, p1.profile_picture_uri, p1.pronouns, p1.properties, p1.created_at, p1.updated_at, p1.deleted_at, p1.approved_at, p1.points, p1.hide_relations, p1.hide_links, p1.default_locale, p1.hide_qa,
//	  p1t.profile_id, p1t.locale_code, p1t.title, p1t.description, p1t.properties, p1t.search_vector,
//	  p2.id, p2.slug, p2.kind, p2.profile_picture_uri, p2.pronouns, p2.properties, p2.created_at, p2.updated_at, p2.deleted_at, p2.approved_at, p2.points, p2.hide_relations, p2.hide_links, p2.default_locale, p2.hide_qa,
//	  p2t.profile_id, p2t.locale_code, p2t.title, p2t.description, p2t.properties, p2t.search_vector
//	FROM
//		"profile_membership" pm
//	  INNER JOIN "profile" p1 ON p1.id = pm.profile_id
//	    AND ($1::TEXT IS NULL OR p1.kind = ANY(string_to_array($1::TEXT, ',')))
//	    AND p1.approved_at IS NOT NULL
//	    AND p1.deleted_at IS NULL
//	  INNER JOIN "profile_tx" p1t ON p1t.profile_id = p1.id
//		  AND p1t.locale_code = (
//	      SELECT p1tf.locale_code FROM "profile_tx" p1tf
//	      WHERE p1tf.profile_id = p1.id
//	      AND (p1tf.locale_code = $2 OR p1tf.locale_code = p1.default_locale)
//	      ORDER BY CASE WHEN p1tf.locale_code = $2 THEN 0 ELSE 1 END
//	      LIMIT 1
//	    )
//	  INNER JOIN "profile" p2 ON p2.id = pm.member_profile_id
//	    AND ($3::TEXT IS NULL OR p2.kind = ANY(string_to_array($3::TEXT, ',')))
//	    AND p2.approved_at IS NOT NULL
//	    AND p2.deleted_at IS NULL
//	  INNER JOIN "profile_tx" p2t ON p2t.profile_id = p2.id
//		  AND p2t.locale_code = (
//	      SELECT p2tf.locale_code FROM "profile_tx" p2tf
//	      WHERE p2tf.profile_id = p2.id
//	      AND (p2tf.locale_code = $2 OR p2tf.locale_code = p2.default_locale)
//	      ORDER BY CASE WHEN p2tf.locale_code = $2 THEN 0 ELSE 1 END
//	      LIMIT 1
//	    )
//	WHERE pm.deleted_at IS NULL
//	    AND ($4::TEXT IS NULL OR pm.profile_id = $4::TEXT)
//	    AND ($5::TEXT IS NULL OR pm.member_profile_id = $5::TEXT)
func (q *Queries) ListProfileMemberships(ctx context.Context, arg ListProfileMembershipsParams) ([]*ListProfileMembershipsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProfileMemberships,
		arg.FilterProfileKind,
		arg.LocaleCode,
		arg.FilterMemberProfileKind,
		arg.FilterProfileID,
		arg.FilterMemberProfileID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListProfileMembershipsRow{}
	for rows.Next() {
		var i ListProfileMembershipsRow
		if err := rows.Scan(
			&i.ProfileMembership.ID,
			&i.ProfileMembership.ProfileID,
			&i.ProfileMembership.MemberProfileID,
			&i.ProfileMembership.Kind,
			&i.ProfileMembership.Properties,
			&i.ProfileMembership.StartedAt,
			&i.ProfileMembership.FinishedAt,
			&i.ProfileMembership.DeletedAt,
			&i.Profile.ID,
			&i.Profile.Slug,
			&i.Profile.Kind,
			&i.Profile.ProfilePictureURI,
			&i.Profile.Pronouns,
			&i.Profile.Properties,
			&i.Profile.CreatedAt,
			&i.Profile.UpdatedAt,
			&i.Profile.DeletedAt,
			&i.Profile.ApprovedAt,
			&i.Profile.Points,
			&i.Profile.HideRelations,
			&i.Profile.HideLinks,
			&i.Profile.DefaultLocale,
			&i.Profile.HideQa,
			&i.ProfileTx.ProfileID,
			&i.ProfileTx.LocaleCode,
			&i.ProfileTx.Title,
			&i.ProfileTx.Description,
			&i.ProfileTx.Properties,
			&i.ProfileTx.SearchVector,
			&i.Profile_2.ID,
			&i.Profile_2.Slug,
			&i.Profile_2.Kind,
			&i.Profile_2.ProfilePictureURI,
			&i.Profile_2.Pronouns,
			&i.Profile_2.Properties,
			&i.Profile_2.CreatedAt,
			&i.Profile_2.UpdatedAt,
			&i.Profile_2.DeletedAt,
			&i.Profile_2.ApprovedAt,
			&i.Profile_2.Points,
			&i.Profile_2.HideRelations,
			&i.Profile_2.HideLinks,
			&i.Profile_2.DefaultLocale,
			&i.Profile_2.HideQa,
			&i.ProfileTx_2.ProfileID,
			&i.ProfileTx_2.LocaleCode,
			&i.ProfileTx_2.Title,
			&i.ProfileTx_2.Description,
			&i.ProfileTx_2.Properties,
			&i.ProfileTx_2.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfileMembershipsForSettings = `-- name: ListProfileMembershipsForSettings :many
SELECT
  pm.id,
  pm.profile_id,
  pm.member_profile_id,
  pm.kind,
  pm.properties,
  pm.started_at,
  pm.finished_at,
  mp.id, mp.slug, mp.kind, mp.profile_picture_uri, mp.pronouns, mp.properties, mp.created_at, mp.updated_at, mp.deleted_at, mp.approved_at, mp.points, mp.hide_relations, mp.hide_links, mp.default_locale, mp.hide_qa,
  mpt.profile_id, mpt.locale_code, mpt.title, mpt.description, mpt.properties, mpt.search_vector
FROM "profile_membership" pm
INNER JOIN "profile" mp ON mp.id = pm.member_profile_id
  AND mp.deleted_at IS NULL
INNER JOIN "profile_tx" mpt ON mpt.profile_id = mp.id
  AND mpt.locale_code = (
    SELECT mptf.locale_code FROM "profile_tx" mptf
    WHERE mptf.profile_id = mp.id
    AND (mptf.locale_code = $1 OR mptf.locale_code = mp.default_locale)
    ORDER BY CASE WHEN mptf.locale_code = $1 THEN 0 ELSE 1 END
    LIMIT 1
  )
WHERE pm.profile_id = $2
  AND pm.deleted_at IS NULL
  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
ORDER BY
  CASE pm.kind
    WHEN 'owner' THEN 1
    WHEN 'lead' THEN 2
    WHEN 'maintainer' THEN 3
    WHEN 'contributor' THEN 4
    WHEN 'sponsor' THEN 5
    WHEN 'follower' THEN 6
    ELSE 7
  END,
  pm.started_at ASC
`

type ListProfileMembershipsForSettingsParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	ProfileID  string `db:"profile_id" json:"profile_id"`
}

type ListProfileMembershipsForSettingsRow struct {
	ID              string                `db:"id" json:"id"`
	ProfileID       string                `db:"profile_id" json:"profile_id"`
	MemberProfileID sql.NullString        `db:"member_profile_id" json:"member_profile_id"`
	Kind            string                `db:"kind" json:"kind"`
	Properties      pqtype.NullRawMessage `db:"properties" json:"properties"`
	StartedAt       sql.NullTime          `db:"started_at" json:"started_at"`
	FinishedAt      sql.NullTime          `db:"finished_at" json:"finished_at"`
	Profile         Profile               `db:"profile" json:"profile"`
	ProfileTx       ProfileTx             `db:"profile_tx" json:"profile_tx"`
}

// ListProfileMembershipsForSettings
//
//	SELECT
//	  pm.id,
//	  pm.profile_id,
//	  pm.member_profile_id,
//	  pm.kind,
//	  pm.properties,
//	  pm.started_at,
//	  pm.finished_at,
//	  mp.id, mp.slug, mp.kind, mp.profile_picture_uri, mp.pronouns, mp.properties, mp.created_at, mp.updated_at, mp.deleted_at, mp.approved_at, mp.points, mp.hide_relations, mp.hide_links, mp.default_locale, mp.hide_qa,
//	  mpt.profile_id, mpt.locale_code, mpt.title, mpt.description, mpt.properties, mpt.search_vector
//	FROM "profile_membership" pm
//	INNER JOIN "profile" mp ON mp.id = pm.member_profile_id
//	  AND mp.deleted_at IS NULL
//	INNER JOIN "profile_tx" mpt ON mpt.profile_id = mp.id
//	  AND mpt.locale_code = (
//	    SELECT mptf.locale_code FROM "profile_tx" mptf
//	    WHERE mptf.profile_id = mp.id
//	    AND (mptf.locale_code = $1 OR mptf.locale_code = mp.default_locale)
//	    ORDER BY CASE WHEN mptf.locale_code = $1 THEN 0 ELSE 1 END
//	    LIMIT 1
//	  )
//	WHERE pm.profile_id = $2
//	  AND pm.deleted_at IS NULL
//	  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
//	ORDER BY
//	  CASE pm.kind
//	    WHEN 'owner' THEN 1
//	    WHEN 'lead' THEN 2
//	    WHEN 'maintainer' THEN 3
//	    WHEN 'contributor' THEN 4
//	    WHEN 'sponsor' THEN 5
//	    WHEN 'follower' THEN 6
//	    ELSE 7
//	  END,
//	  pm.started_at ASC
func (q *Queries) ListProfileMembershipsForSettings(ctx context.Context, arg ListProfileMembershipsForSettingsParams) ([]*ListProfileMembershipsForSettingsRow, error) {
	rows, err := q.db.QueryContext(ctx, listProfileMembershipsForSettings, arg.LocaleCode, arg.ProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListProfileMembershipsForSettingsRow{}
	for rows.Next() {
		var i ListProfileMembershipsForSettingsRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.MemberProfileID,
			&i.Kind,
			&i.Properties,
			&i.StartedAt,
			&i.FinishedAt,
			&i.Profile.ID,
			&i.Profile.Slug,
			&i.Profile.Kind,
			&i.Profile.ProfilePictureURI,
			&i.Profile.Pronouns,
			&i.Profile.Properties,
			&i.Profile.CreatedAt,
			&i.Profile.UpdatedAt,
			&i.Profile.DeletedAt,
			&i.Profile.ApprovedAt,
			&i.Profile.Points,
			&i.Profile.HideRelations,
			&i.Profile.HideLinks,
			&i.Profile.DefaultLocale,
			&i.Profile.HideQa,
			&i.ProfileTx.ProfileID,
			&i.ProfileTx.LocaleCode,
			&i.ProfileTx.Title,
			&i.ProfileTx.Description,
			&i.ProfileTx.Properties,
			&i.ProfileTx.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfilePageTxLocales = `-- name: ListProfilePageTxLocales :many
SELECT locale_code FROM "profile_page_tx"
WHERE profile_page_id = $1
ORDER BY locale_code
`

type ListProfilePageTxLocalesParams struct {
	ProfilePageID string `db:"profile_page_id" json:"profile_page_id"`
}

// ListProfilePageTxLocales
//
//	SELECT locale_code FROM "profile_page_tx"
//	WHERE profile_page_id = $1
//	ORDER BY locale_code
func (q *Queries) ListProfilePageTxLocales(ctx context.Context, arg ListProfilePageTxLocalesParams) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, listProfilePageTxLocales, arg.ProfilePageID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []string{}
	for rows.Next() {
		var locale_code string
		if err := rows.Scan(&locale_code); err != nil {
			return nil, err
		}
		items = append(items, locale_code)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfilePagesByProfileID = `-- name: ListProfilePagesByProfileID :many
SELECT pp.id, pp.profile_id, pp.slug, pp."order", pp.cover_picture_uri, pp.published_at, pp.created_at, pp.updated_at, pp.deleted_at, ppt.profile_page_id, ppt.locale_code, ppt.title, ppt.summary, ppt.content, ppt.search_vector
FROM "profile_page" pp
  INNER JOIN "profile" p ON p.id = pp.profile_id
  INNER JOIN "profile_page_tx" ppt ON ppt.profile_page_id = pp.id
  AND ppt.locale_code = (
    SELECT pptf.locale_code FROM "profile_page_tx" pptf
    WHERE pptf.profile_page_id = pp.id
    AND (pptf.locale_code = $1 OR pptf.locale_code = p.default_locale)
    ORDER BY CASE WHEN pptf.locale_code = $1 THEN 0 ELSE 1 END
    LIMIT 1
  )
WHERE pp.profile_id = $2
  AND pp.deleted_at IS NULL
ORDER BY pp."order"
`

type ListProfilePagesByProfileIDParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	ProfileID  string `db:"profile_id" json:"profile_id"`
}

type ListProfilePagesByProfileIDRow struct {
	ID              string         `db:"id" json:"id"`
	ProfileID       string         `db:"profile_id" json:"profile_id"`
	Slug            string         `db:"slug" json:"slug"`
	Order           int32          `db:"order" json:"order"`
	CoverPictureURI sql.NullString `db:"cover_picture_uri" json:"cover_picture_uri"`
	PublishedAt     sql.NullTime   `db:"published_at" json:"published_at"`
	CreatedAt       time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt       sql.NullTime   `db:"updated_at" json:"updated_at"`
	DeletedAt       sql.NullTime   `db:"deleted_at" json:"deleted_at"`
	ProfilePageID   string         `db:"profile_page_id" json:"profile_page_id"`
	LocaleCode      string         `db:"locale_code" json:"locale_code"`
	Title           string         `db:"title" json:"title"`
	Summary         string         `db:"summary" json:"summary"`
	Content         string         `db:"content" json:"content"`
	SearchVector    interface{}    `db:"search_vector" json:"search_vector"`
}

// ListProfilePagesByProfileID
//
//	SELECT pp.id, pp.profile_id, pp.slug, pp."order", pp.cover_picture_uri, pp.published_at, pp.created_at, pp.updated_at, pp.deleted_at, ppt.profile_page_id, ppt.locale_code, ppt.title, ppt.summary, ppt.content, ppt.search_vector
//	FROM "profile_page" pp
//	  INNER JOIN "profile" p ON p.id = pp.profile_id
//	  INNER JOIN "profile_page_tx" ppt ON ppt.profile_page_id = pp.id
//	  AND ppt.locale_code = (
//	    SELECT pptf.locale_code FROM "profile_page_tx" pptf
//	    WHERE pptf.profile_page_id = pp.id
//	    AND (pptf.locale_code = $1 OR pptf.locale_code = p.default_locale)
//	    ORDER BY CASE WHEN pptf.locale_code = $1 THEN 0 ELSE 1 END
//	    LIMIT 1
//	  )
//	WHERE pp.profile_id = $2
//	  AND pp.deleted_at IS NULL
//	ORDER BY pp."order"
func (q *Queries) ListProfilePagesByProfileID(ctx context.Context, arg ListProfilePagesByProfileIDParams) ([]*ListProfilePagesByProfileIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listProfilePagesByProfileID, arg.LocaleCode, arg.ProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListProfilePagesByProfileIDRow{}
	for rows.Next() {
		var i ListProfilePagesByProfileIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Slug,
			&i.Order,
			&i.CoverPictureURI,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.ProfilePageID,
			&i.LocaleCode,
			&i.Title,
			&i.Summary,
			&i.Content,
			&i.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfileResourcesByProfileID = `-- name: ListProfileResourcesByProfileID :many
SELECT
  pr.id, pr.profile_id, pr.kind, pr.is_managed, pr.remote_id, pr.public_id, pr.url, pr.title, pr.description, pr.properties, pr.added_by_profile_id, pr.created_at, pr.updated_at, pr.deleted_at,
  p.slug as added_by_slug,
  p.kind as added_by_kind,
  COALESCE(pt_added.title, '') as added_by_title,
  COALESCE(pt_added.description, '') as added_by_description,
  p.profile_picture_uri as added_by_profile_picture_uri
FROM "profile_resource" pr
LEFT JOIN "profile" p ON p.id = pr.added_by_profile_id AND p.deleted_at IS NULL
LEFT JOIN "profile_tx" pt_added ON pt_added.profile_id = p.id
  AND pt_added.locale_code = p.default_locale
WHERE pr.profile_id = $1
  AND pr.deleted_at IS NULL
ORDER BY pr.created_at DESC
`

type ListProfileResourcesByProfileIDParams struct {
	ProfileID string `db:"profile_id" json:"profile_id"`
}

type ListProfileResourcesByProfileIDRow struct {
	ID                       string                `db:"id" json:"id"`
	ProfileID                string                `db:"profile_id" json:"profile_id"`
	Kind                     string                `db:"kind" json:"kind"`
	IsManaged                bool                  `db:"is_managed" json:"is_managed"`
	RemoteID                 sql.NullString        `db:"remote_id" json:"remote_id"`
	PublicID                 sql.NullString        `db:"public_id" json:"public_id"`
	URL                      sql.NullString        `db:"url" json:"url"`
	Title                    string                `db:"title" json:"title"`
	Description              sql.NullString        `db:"description" json:"description"`
	Properties               pqtype.NullRawMessage `db:"properties" json:"properties"`
	AddedByProfileID         string                `db:"added_by_profile_id" json:"added_by_profile_id"`
	CreatedAt                time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt                sql.NullTime          `db:"updated_at" json:"updated_at"`
	DeletedAt                sql.NullTime          `db:"deleted_at" json:"deleted_at"`
	AddedBySlug              sql.NullString        `db:"added_by_slug" json:"added_by_slug"`
	AddedByKind              sql.NullString        `db:"added_by_kind" json:"added_by_kind"`
	AddedByTitle             string                `db:"added_by_title" json:"added_by_title"`
	AddedByDescription       string                `db:"added_by_description" json:"added_by_description"`
	AddedByProfilePictureURI sql.NullString        `db:"added_by_profile_picture_uri" json:"added_by_profile_picture_uri"`
}

// ListProfileResourcesByProfileID
//
//	SELECT
//	  pr.id, pr.profile_id, pr.kind, pr.is_managed, pr.remote_id, pr.public_id, pr.url, pr.title, pr.description, pr.properties, pr.added_by_profile_id, pr.created_at, pr.updated_at, pr.deleted_at,
//	  p.slug as added_by_slug,
//	  p.kind as added_by_kind,
//	  COALESCE(pt_added.title, '') as added_by_title,
//	  COALESCE(pt_added.description, '') as added_by_description,
//	  p.profile_picture_uri as added_by_profile_picture_uri
//	FROM "profile_resource" pr
//	LEFT JOIN "profile" p ON p.id = pr.added_by_profile_id AND p.deleted_at IS NULL
//	LEFT JOIN "profile_tx" pt_added ON pt_added.profile_id = p.id
//	  AND pt_added.locale_code = p.default_locale
//	WHERE pr.profile_id = $1
//	  AND pr.deleted_at IS NULL
//	ORDER BY pr.created_at DESC
func (q *Queries) ListProfileResourcesByProfileID(ctx context.Context, arg ListProfileResourcesByProfileIDParams) ([]*ListProfileResourcesByProfileIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listProfileResourcesByProfileID, arg.ProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListProfileResourcesByProfileIDRow{}
	for rows.Next() {
		var i ListProfileResourcesByProfileIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Kind,
			&i.IsManaged,
			&i.RemoteID,
			&i.PublicID,
			&i.URL,
			&i.Title,
			&i.Description,
			&i.Properties,
			&i.AddedByProfileID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.AddedBySlug,
			&i.AddedByKind,
			&i.AddedByTitle,
			&i.AddedByDescription,
			&i.AddedByProfilePictureURI,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listProfiles = `-- name: ListProfiles :many
SELECT p.id, p.slug, p.kind, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, p.approved_at, p.points, p.hide_relations, p.hide_links, p.default_locale, p.hide_qa, pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector
FROM "profile" p
  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
  AND pt.locale_code = (
    SELECT ptf.locale_code FROM "profile_tx" ptf
    WHERE ptf.profile_id = p.id
    AND (ptf.locale_code = $1 OR ptf.locale_code = p.default_locale)
    ORDER BY CASE WHEN ptf.locale_code = $1 THEN 0 ELSE 1 END
    LIMIT 1
  )
WHERE ($2::TEXT IS NULL OR p.kind = ANY(string_to_array($2::TEXT, ',')))
  AND p.approved_at IS NOT NULL
  AND p.deleted_at IS NULL
`

type ListProfilesParams struct {
	LocaleCode string         `db:"locale_code" json:"locale_code"`
	FilterKind sql.NullString `db:"filter_kind" json:"filter_kind"`
}

type ListProfilesRow struct {
	Profile   Profile   `db:"profile" json:"profile"`
	ProfileTx ProfileTx `db:"profile_tx" json:"profile_tx"`
}

// ListProfiles
//
//	SELECT p.id, p.slug, p.kind, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, p.approved_at, p.points, p.hide_relations, p.hide_links, p.default_locale, p.hide_qa, pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector
//	FROM "profile" p
//	  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
//	  AND pt.locale_code = (
//	    SELECT ptf.locale_code FROM "profile_tx" ptf
//	    WHERE ptf.profile_id = p.id
//	    AND (ptf.locale_code = $1 OR ptf.locale_code = p.default_locale)
//	    ORDER BY CASE WHEN ptf.locale_code = $1 THEN 0 ELSE 1 END
//	    LIMIT 1
//	  )
//	WHERE ($2::TEXT IS NULL OR p.kind = ANY(string_to_array($2::TEXT, ',')))
//	  AND p.approved_at IS NOT NULL
//	  AND p.deleted_at IS NULL
func (q *Queries) ListProfiles(ctx context.Context, arg ListProfilesParams) ([]*ListProfilesRow, error) {
	rows, err := q.db.QueryContext(ctx, listProfiles, arg.LocaleCode, arg.FilterKind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListProfilesRow{}
	for rows.Next() {
		var i ListProfilesRow
		if err := rows.Scan(
			&i.Profile.ID,
			&i.Profile.Slug,
			&i.Profile.Kind,
			&i.Profile.ProfilePictureURI,
			&i.Profile.Pronouns,
			&i.Profile.Properties,
			&i.Profile.CreatedAt,
			&i.Profile.UpdatedAt,
			&i.Profile.DeletedAt,
			&i.Profile.ApprovedAt,
			&i.Profile.Points,
			&i.Profile.HideRelations,
			&i.Profile.HideLinks,
			&i.Profile.DefaultLocale,
			&i.Profile.HideQa,
			&i.ProfileTx.ProfileID,
			&i.ProfileTx.LocaleCode,
			&i.ProfileTx.Title,
			&i.ProfileTx.Description,
			&i.ProfileTx.Properties,
			&i.ProfileTx.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeProfile = `-- name: RemoveProfile :execrows
UPDATE "profile"
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type RemoveProfileParams struct {
	ID string `db:"id" json:"id"`
}

// RemoveProfile
//
//	UPDATE "profile"
//	SET deleted_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) RemoveProfile(ctx context.Context, arg RemoveProfileParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeProfile, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const searchProfilePages = `-- name: SearchProfilePages :many
SELECT
  pp.id,
  pp.slug,
  pp.profile_id,
  pp.cover_picture_uri,
  ppt.title,
  ppt.summary,
  p.slug as profile_slug,
  pt.title as profile_title,
  ts_rank(ppt.search_vector, plainto_tsquery(locale_to_regconfig($1), $2)) as rank
FROM "profile_page" pp
  INNER JOIN "profile_page_tx" ppt ON ppt.profile_page_id = pp.id
    AND ppt.locale_code = $1
  INNER JOIN "profile" p ON p.id = pp.profile_id AND p.deleted_at IS NULL
  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
    AND pt.locale_code = (
      SELECT ptf.locale_code FROM "profile_tx" ptf
      WHERE ptf.profile_id = p.id
      AND (ptf.locale_code = $1 OR ptf.locale_code = p.default_locale)
      ORDER BY CASE WHEN ptf.locale_code = $1 THEN 0 ELSE 1 END
      LIMIT 1
    )
WHERE ppt.search_vector @@ plainto_tsquery(locale_to_regconfig($1), $2)
  AND pp.deleted_at IS NULL
  AND p.approved_at IS NOT NULL
  AND ($3::TEXT IS NULL OR p.slug = $3::TEXT)
ORDER BY rank DESC
LIMIT $4
`

type SearchProfilePagesParams struct {
	LocaleCode        string         `db:"locale_code" json:"locale_code"`
	Query             string         `db:"query" json:"query"`
	FilterProfileSlug sql.NullString `db:"filter_profile_slug" json:"filter_profile_slug"`
	LimitCount        int32          `db:"limit_count" json:"limit_count"`
}

type SearchProfilePagesRow struct {
	ID              string         `db:"id" json:"id"`
	Slug            string         `db:"slug" json:"slug"`
	ProfileID       string         `db:"profile_id" json:"profile_id"`
	CoverPictureURI sql.NullString `db:"cover_picture_uri" json:"cover_picture_uri"`
	Title           string         `db:"title" json:"title"`
	Summary         string         `db:"summary" json:"summary"`
	ProfileSlug     string         `db:"profile_slug" json:"profile_slug"`
	ProfileTitle    string         `db:"profile_title" json:"profile_title"`
	Rank            float32        `db:"rank" json:"rank"`
}

// SearchProfilePages
//
//	SELECT
//	  pp.id,
//	  pp.slug,
//	  pp.profile_id,
//	  pp.cover_picture_uri,
//	  ppt.title,
//	  ppt.summary,
//	  p.slug as profile_slug,
//	  pt.title as profile_title,
//	  ts_rank(ppt.search_vector, plainto_tsquery(locale_to_regconfig($1), $2)) as rank
//	FROM "profile_page" pp
//	  INNER JOIN "profile_page_tx" ppt ON ppt.profile_page_id = pp.id
//	    AND ppt.locale_code = $1
//	  INNER JOIN "profile" p ON p.id = pp.profile_id AND p.deleted_at IS NULL
//	  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
//	    AND pt.locale_code = (
//	      SELECT ptf.locale_code FROM "profile_tx" ptf
//	      WHERE ptf.profile_id = p.id
//	      AND (ptf.locale_code = $1 OR ptf.locale_code = p.default_locale)
//	      ORDER BY CASE WHEN ptf.locale_code = $1 THEN 0 ELSE 1 END
//	      LIMIT 1
//	    )
//	WHERE ppt.search_vector @@ plainto_tsquery(locale_to_regconfig($1), $2)
//	  AND pp.deleted_at IS NULL
//	  AND p.approved_at IS NOT NULL
//	  AND ($3::TEXT IS NULL OR p.slug = $3::TEXT)
//	ORDER BY rank DESC
//	LIMIT $4
func (q *Queries) SearchProfilePages(ctx context.Context, arg SearchProfilePagesParams) ([]*SearchProfilePagesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchProfilePages,
		arg.LocaleCode,
		arg.Query,
		arg.FilterProfileSlug,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchProfilePagesRow{}
	for rows.Next() {
		var i SearchProfilePagesRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.ProfileID,
			&i.CoverPictureURI,
			&i.Title,
			&i.Summary,
			&i.ProfileSlug,
			&i.ProfileTitle,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProfiles = `-- name: SearchProfiles :many
SELECT
  p.id,
  p.slug,
  p.kind,
  p.profile_picture_uri,
  pt.title,
  pt.description,
  ts_rank(pt.search_vector, plainto_tsquery(locale_to_regconfig($1), $2)) as rank
FROM "profile" p
  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
    AND pt.locale_code = $1
WHERE pt.search_vector @@ plainto_tsquery(locale_to_regconfig($1), $2)
  AND p.approved_at IS NOT NULL
  AND p.deleted_at IS NULL
  AND ($3::TEXT IS NULL OR p.slug = $3::TEXT)
ORDER BY rank DESC
LIMIT $4
`

type SearchProfilesParams struct {
	LocaleCode        string         `db:"locale_code" json:"locale_code"`
	Query             string         `db:"query" json:"query"`
	FilterProfileSlug sql.NullString `db:"filter_profile_slug" json:"filter_profile_slug"`
	LimitCount        int32          `db:"limit_count" json:"limit_count"`
}

type SearchProfilesRow struct {
	ID                string         `db:"id" json:"id"`
	Slug              string         `db:"slug" json:"slug"`
	Kind              string         `db:"kind" json:"kind"`
	ProfilePictureURI sql.NullString `db:"profile_picture_uri" json:"profile_picture_uri"`
	Title             string         `db:"title" json:"title"`
	Description       string         `db:"description" json:"description"`
	Rank              float32        `db:"rank" json:"rank"`
}

// SearchProfiles
//
//	SELECT
//	  p.id,
//	  p.slug,
//	  p.kind,
//	  p.profile_picture_uri,
//	  pt.title,
//	  pt.description,
//	  ts_rank(pt.search_vector, plainto_tsquery(locale_to_regconfig($1), $2)) as rank
//	FROM "profile" p
//	  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
//	    AND pt.locale_code = $1
//	WHERE pt.search_vector @@ plainto_tsquery(locale_to_regconfig($1), $2)
//	  AND p.approved_at IS NOT NULL
//	  AND p.deleted_at IS NULL
//	  AND ($3::TEXT IS NULL OR p.slug = $3::TEXT)
//	ORDER BY rank DESC
//	LIMIT $4
func (q *Queries) SearchProfiles(ctx context.Context, arg SearchProfilesParams) ([]*SearchProfilesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchProfiles,
		arg.LocaleCode,
		arg.Query,
		arg.FilterProfileSlug,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchProfilesRow{}
	for rows.Next() {
		var i SearchProfilesRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Kind,
			&i.ProfilePictureURI,
			&i.Title,
			&i.Description,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchUsersForMembership = `-- name: SearchUsersForMembership :many
SELECT
  u.id as user_id,
  u.email,
  u.name,
  u.individual_profile_id,
  p.id, p.slug, p.kind, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, p.approved_at, p.points, p.hide_relations, p.hide_links, p.default_locale, p.hide_qa,
  pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector
FROM "user" u
INNER JOIN "profile" p ON p.id = u.individual_profile_id
  AND p.deleted_at IS NULL
INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
  AND pt.locale_code = (
    SELECT ptf.locale_code FROM "profile_tx" ptf
    WHERE ptf.profile_id = p.id
    AND (ptf.locale_code = $1 OR ptf.locale_code = p.default_locale)
    ORDER BY CASE WHEN ptf.locale_code = $1 THEN 0 ELSE 1 END
    LIMIT 1
  )
WHERE u.deleted_at IS NULL
  AND u.individual_profile_id IS NOT NULL
  AND (
    u.email ILIKE '%' || $2 || '%'
    OR u.name ILIKE '%' || $2 || '%'
    OR p.slug ILIKE '%' || $2 || '%'
    OR pt.title ILIKE '%' || $2 || '%'
  )
  -- Exclude users who already have a non-follower/non-sponsor membership on this profile.
  -- Followers and sponsors are admin-only kinds and may be promoted to a higher role.
  AND NOT EXISTS (
    SELECT 1 FROM "profile_membership" pm
    WHERE pm.profile_id = $3
      AND pm.member_profile_id = u.individual_profile_id
      AND pm.deleted_at IS NULL
      AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
      AND pm.kind NOT IN ('follower', 'sponsor')
  )
ORDER BY u.name ASC
LIMIT 10
`

type SearchUsersForMembershipParams struct {
	LocaleCode string         `db:"locale_code" json:"locale_code"`
	Query      sql.NullString `db:"query" json:"query"`
	ProfileID  string         `db:"profile_id" json:"profile_id"`
}

type SearchUsersForMembershipRow struct {
	UserID              string         `db:"user_id" json:"user_id"`
	Email               sql.NullString `db:"email" json:"email"`
	Name                string         `db:"name" json:"name"`
	IndividualProfileID sql.NullString `db:"individual_profile_id" json:"individual_profile_id"`
	Profile             Profile        `db:"profile" json:"profile"`
	ProfileTx           ProfileTx      `db:"profile_tx" json:"profile_tx"`
}

// SearchUsersForMembership
//
//	SELECT
//	  u.id as user_id,
//	  u.email,
//	  u.name,
//	  u.individual_profile_id,
//	  p.id, p.slug, p.kind, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, p.approved_at, p.points, p.hide_relations, p.hide_links, p.default_locale, p.hide_qa,
//	  pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector
//	FROM "user" u
//	INNER JOIN "profile" p ON p.id = u.individual_profile_id
//	  AND p.deleted_at IS NULL
//	INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
//	  AND pt.locale_code = (
//	    SELECT ptf.locale_code FROM "profile_tx" ptf
//	    WHERE ptf.profile_id = p.id
//	    AND (ptf.locale_code = $1 OR ptf.locale_code = p.default_locale)
//	    ORDER BY CASE WHEN ptf.locale_code = $1 THEN 0 ELSE 1 END
//	    LIMIT 1
//	  )
//	WHERE u.deleted_at IS NULL
//	  AND u.individual_profile_id IS NOT NULL
//	  AND (
//	    u.email ILIKE '%' || $2 || '%'
//	    OR u.name ILIKE '%' || $2 || '%'
//	    OR p.slug ILIKE '%' || $2 || '%'
//	    OR pt.title ILIKE '%' || $2 || '%'
//	  )
//	  -- Exclude users who already have a non-follower/non-sponsor membership on this profile.
//	  -- Followers and sponsors are admin-only kinds and may be promoted to a higher role.
//	  AND NOT EXISTS (
//	    SELECT 1 FROM "profile_membership" pm
//	    WHERE pm.profile_id = $3
//	      AND pm.member_profile_id = u.individual_profile_id
//	      AND pm.deleted_at IS NULL
//	      AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
//	      AND pm.kind NOT IN ('follower', 'sponsor')
//	  )
//	ORDER BY u.name ASC
//	LIMIT 10
func (q *Queries) SearchUsersForMembership(ctx context.Context, arg SearchUsersForMembershipParams) ([]*SearchUsersForMembershipRow, error) {
	rows, err := q.db.QueryContext(ctx, searchUsersForMembership, arg.LocaleCode, arg.Query, arg.ProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchUsersForMembershipRow{}
	for rows.Next() {
		var i SearchUsersForMembershipRow
		if err := rows.Scan(
			&i.UserID,
			&i.Email,
			&i.Name,
			&i.IndividualProfileID,
			&i.Profile.ID,
			&i.Profile.Slug,
			&i.Profile.Kind,
			&i.Profile.ProfilePictureURI,
			&i.Profile.Pronouns,
			&i.Profile.Properties,
			&i.Profile.CreatedAt,
			&i.Profile.UpdatedAt,
			&i.Profile.DeletedAt,
			&i.Profile.ApprovedAt,
			&i.Profile.Points,
			&i.Profile.HideRelations,
			&i.Profile.HideLinks,
			&i.Profile.DefaultLocale,
			&i.Profile.HideQa,
			&i.ProfileTx.ProfileID,
			&i.ProfileTx.LocaleCode,
			&i.ProfileTx.Title,
			&i.ProfileTx.Description,
			&i.ProfileTx.Properties,
			&i.ProfileTx.SearchVector,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteProfileResource = `-- name: SoftDeleteProfileResource :execrows
UPDATE "profile_resource"
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type SoftDeleteProfileResourceParams struct {
	ID string `db:"id" json:"id"`
}

// SoftDeleteProfileResource
//
//	UPDATE "profile_resource"
//	SET deleted_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) SoftDeleteProfileResource(ctx context.Context, arg SoftDeleteProfileResourceParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, softDeleteProfileResource, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateCustomDomain = `-- name: UpdateCustomDomain :execrows
UPDATE "profile_custom_domain"
SET
  domain = $1,
  default_locale = $2,
  updated_at = NOW()
WHERE id = $3
`

type UpdateCustomDomainParams struct {
	Domain        string         `db:"domain" json:"domain"`
	DefaultLocale sql.NullString `db:"default_locale" json:"default_locale"`
	ID            string         `db:"id" json:"id"`
}

// UpdateCustomDomain
//
//	UPDATE "profile_custom_domain"
//	SET
//	  domain = $1,
//	  default_locale = $2,
//	  updated_at = NOW()
//	WHERE id = $3
func (q *Queries) UpdateCustomDomain(ctx context.Context, arg UpdateCustomDomainParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateCustomDomain, arg.Domain, arg.DefaultLocale, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateProfile = `-- name: UpdateProfile :execrows
UPDATE "profile"
SET
  profile_picture_uri = COALESCE($1, profile_picture_uri),
  pronouns = COALESCE($2, pronouns),
  properties = COALESCE($3, properties),
  hide_relations = COALESCE($4, hide_relations),
  hide_links = COALESCE($5, hide_links),
  hide_qa = COALESCE($6, hide_qa),
  updated_at = NOW()
WHERE id = $7
  AND deleted_at IS NULL
`

type UpdateProfileParams struct {
	ProfilePictureURI sql.NullString        `db:"profile_picture_uri" json:"profile_picture_uri"`
	Pronouns          sql.NullString        `db:"pronouns" json:"pronouns"`
	Properties        pqtype.NullRawMessage `db:"properties" json:"properties"`
	HideRelations     sql.NullBool          `db:"hide_relations" json:"hide_relations"`
	HideLinks         sql.NullBool          `db:"hide_links" json:"hide_links"`
	HideQa            sql.NullBool          `db:"hide_qa" json:"hide_qa"`
	ID                string                `db:"id" json:"id"`
}

// UpdateProfile
//
//	UPDATE "profile"
//	SET
//	  profile_picture_uri = COALESCE($1, profile_picture_uri),
//	  pronouns = COALESCE($2, pronouns),
//	  properties = COALESCE($3, properties),
//	  hide_relations = COALESCE($4, hide_relations),
//	  hide_links = COALESCE($5, hide_links),
//	  hide_qa = COALESCE($6, hide_qa),
//	  updated_at = NOW()
//	WHERE id = $7
//	  AND deleted_at IS NULL
func (q *Queries) UpdateProfile(ctx context.Context, arg UpdateProfileParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProfile,
		arg.ProfilePictureURI,
		arg.Pronouns,
		arg.Properties,
		arg.HideRelations,
		arg.HideLinks,
		arg.HideQa,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateProfileLink = `-- name: UpdateProfileLink :execrows
UPDATE "profile_link"
SET
  kind = $1,
  "order" = $2,
  uri = $3,
  is_featured = $4,
  visibility = $5,
  updated_at = NOW()
WHERE id = $6
  AND deleted_at IS NULL
`

type UpdateProfileLinkParams struct {
	Kind       string         `db:"kind" json:"kind"`
	LinkOrder  int32          `db:"link_order" json:"link_order"`
	URI        sql.NullString `db:"uri" json:"uri"`
	IsFeatured bool           `db:"is_featured" json:"is_featured"`
	Visibility string         `db:"visibility" json:"visibility"`
	ID         string         `db:"id" json:"id"`
}

// UpdateProfileLink
//
//	UPDATE "profile_link"
//	SET
//	  kind = $1,
//	  "order" = $2,
//	  uri = $3,
//	  is_featured = $4,
//	  visibility = $5,
//	  updated_at = NOW()
//	WHERE id = $6
//	  AND deleted_at IS NULL
func (q *Queries) UpdateProfileLink(ctx context.Context, arg UpdateProfileLinkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProfileLink,
		arg.Kind,
		arg.LinkOrder,
		arg.URI,
		arg.IsFeatured,
		arg.Visibility,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateProfileLinkOAuthTokens = `-- name: UpdateProfileLinkOAuthTokens :execrows
UPDATE "profile_link"
SET
  public_id = $1,
  uri = $2,
  auth_access_token = $3,
  auth_access_token_expires_at = $4,
  auth_refresh_token = $5,
  auth_access_token_scope = $6,
  is_verified = TRUE,
  updated_at = NOW()
WHERE id = $7
  AND deleted_at IS NULL
`

type UpdateProfileLinkOAuthTokensParams struct {
	PublicID                 sql.NullString `db:"public_id" json:"public_id"`
	URI                      sql.NullString `db:"uri" json:"uri"`
	AuthAccessToken          sql.NullString `db:"auth_access_token" json:"auth_access_token"`
	AuthAccessTokenExpiresAt sql.NullTime   `db:"auth_access_token_expires_at" json:"auth_access_token_expires_at"`
	AuthRefreshToken         sql.NullString `db:"auth_refresh_token" json:"auth_refresh_token"`
	AuthAccessTokenScope     sql.NullString `db:"auth_access_token_scope" json:"auth_access_token_scope"`
	ID                       string         `db:"id" json:"id"`
}

// UpdateProfileLinkOAuthTokens
//
//	UPDATE "profile_link"
//	SET
//	  public_id = $1,
//	  uri = $2,
//	  auth_access_token = $3,
//	  auth_access_token_expires_at = $4,
//	  auth_refresh_token = $5,
//	  auth_access_token_scope = $6,
//	  is_verified = TRUE,
//	  updated_at = NOW()
//	WHERE id = $7
//	  AND deleted_at IS NULL
func (q *Queries) UpdateProfileLinkOAuthTokens(ctx context.Context, arg UpdateProfileLinkOAuthTokensParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProfileLinkOAuthTokens,
		arg.PublicID,
		arg.URI,
		arg.AuthAccessToken,
		arg.AuthAccessTokenExpiresAt,
		arg.AuthRefreshToken,
		arg.AuthAccessTokenScope,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateProfileLinkTx = `-- name: UpdateProfileLinkTx :execrows
UPDATE "profile_link_tx"
SET
  title = $1,
  icon = $2,
  "group" = $3,
  description = $4
WHERE profile_link_id = $5
  AND locale_code = $6
`

type UpdateProfileLinkTxParams struct {
	Title         string         `db:"title" json:"title"`
	Icon          sql.NullString `db:"icon" json:"icon"`
	LinkGroup     sql.NullString `db:"link_group" json:"link_group"`
	Description   sql.NullString `db:"description" json:"description"`
	ProfileLinkID string         `db:"profile_link_id" json:"profile_link_id"`
	LocaleCode    string         `db:"locale_code" json:"locale_code"`
}

// UpdateProfileLinkTx
//
//	UPDATE "profile_link_tx"
//	SET
//	  title = $1,
//	  icon = $2,
//	  "group" = $3,
//	  description = $4
//	WHERE profile_link_id = $5
//	  AND locale_code = $6
func (q *Queries) UpdateProfileLinkTx(ctx context.Context, arg UpdateProfileLinkTxParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProfileLinkTx,
		arg.Title,
		arg.Icon,
		arg.LinkGroup,
		arg.Description,
		arg.ProfileLinkID,
		arg.LocaleCode,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateProfileMembership = `-- name: UpdateProfileMembership :execrows
UPDATE "profile_membership"
SET
  kind = $1
WHERE id = $2
  AND deleted_at IS NULL
`

type UpdateProfileMembershipParams struct {
	Kind string `db:"kind" json:"kind"`
	ID   string `db:"id" json:"id"`
}

// UpdateProfileMembership
//
//	UPDATE "profile_membership"
//	SET
//	  kind = $1
//	WHERE id = $2
//	  AND deleted_at IS NULL
func (q *Queries) UpdateProfileMembership(ctx context.Context, arg UpdateProfileMembershipParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProfileMembership, arg.Kind, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateProfileMembershipProperties = `-- name: UpdateProfileMembershipProperties :execrows
UPDATE "profile_membership"
SET
  properties = $1
WHERE id = $2
  AND deleted_at IS NULL
`

type UpdateProfileMembershipPropertiesParams struct {
	Properties pqtype.NullRawMessage `db:"properties" json:"properties"`
	ID         string                `db:"id" json:"id"`
}

// UpdateProfileMembershipProperties
//
//	UPDATE "profile_membership"
//	SET
//	  properties = $1
//	WHERE id = $2
//	  AND deleted_at IS NULL
func (q *Queries) UpdateProfileMembershipProperties(ctx context.Context, arg UpdateProfileMembershipPropertiesParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProfileMembershipProperties, arg.Properties, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateProfilePage = `-- name: UpdateProfilePage :execrows
UPDATE "profile_page"
SET
  slug = $1,
  "order" = $2,
  cover_picture_uri = $3,
  published_at = $4,
  updated_at = NOW()
WHERE id = $5
  AND deleted_at IS NULL
`

type UpdateProfilePageParams struct {
	Slug            string         `db:"slug" json:"slug"`
	PageOrder       int32          `db:"page_order" json:"page_order"`
	CoverPictureURI sql.NullString `db:"cover_picture_uri" json:"cover_picture_uri"`
	PublishedAt     sql.NullTime   `db:"published_at" json:"published_at"`
	ID              string         `db:"id" json:"id"`
}

// UpdateProfilePage
//
//	UPDATE "profile_page"
//	SET
//	  slug = $1,
//	  "order" = $2,
//	  cover_picture_uri = $3,
//	  published_at = $4,
//	  updated_at = NOW()
//	WHERE id = $5
//	  AND deleted_at IS NULL
func (q *Queries) UpdateProfilePage(ctx context.Context, arg UpdateProfilePageParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProfilePage,
		arg.Slug,
		arg.PageOrder,
		arg.CoverPictureURI,
		arg.PublishedAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateProfilePageTx = `-- name: UpdateProfilePageTx :execrows
UPDATE "profile_page_tx"
SET
  title = $1,
  summary = $2,
  content = $3
WHERE profile_page_id = $4
  AND locale_code = $5
`

type UpdateProfilePageTxParams struct {
	Title         string `db:"title" json:"title"`
	Summary       string `db:"summary" json:"summary"`
	Content       string `db:"content" json:"content"`
	ProfilePageID string `db:"profile_page_id" json:"profile_page_id"`
	LocaleCode    string `db:"locale_code" json:"locale_code"`
}

// UpdateProfilePageTx
//
//	UPDATE "profile_page_tx"
//	SET
//	  title = $1,
//	  summary = $2,
//	  content = $3
//	WHERE profile_page_id = $4
//	  AND locale_code = $5
func (q *Queries) UpdateProfilePageTx(ctx context.Context, arg UpdateProfilePageTxParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProfilePageTx,
		arg.Title,
		arg.Summary,
		arg.Content,
		arg.ProfilePageID,
		arg.LocaleCode,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateProfileResourceProperties = `-- name: UpdateProfileResourceProperties :execrows
UPDATE "profile_resource"
SET
  properties = $1,
  updated_at = NOW()
WHERE id = $2
  AND deleted_at IS NULL
`

type UpdateProfileResourcePropertiesParams struct {
	Properties pqtype.NullRawMessage `db:"properties" json:"properties"`
	ID         string                `db:"id" json:"id"`
}

// UpdateProfileResourceProperties
//
//	UPDATE "profile_resource"
//	SET
//	  properties = $1,
//	  updated_at = NOW()
//	WHERE id = $2
//	  AND deleted_at IS NULL
func (q *Queries) UpdateProfileResourceProperties(ctx context.Context, arg UpdateProfileResourcePropertiesParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProfileResourceProperties, arg.Properties, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateProfileTx = `-- name: UpdateProfileTx :execrows
UPDATE "profile_tx"
SET
  title = $1,
  description = $2,
  properties = $3
WHERE profile_id = $4
  AND locale_code = $5
`

type UpdateProfileTxParams struct {
	Title       string                `db:"title" json:"title"`
	Description string                `db:"description" json:"description"`
	Properties  pqtype.NullRawMessage `db:"properties" json:"properties"`
	ProfileID   string                `db:"profile_id" json:"profile_id"`
	LocaleCode  string                `db:"locale_code" json:"locale_code"`
}

// UpdateProfileTx
//
//	UPDATE "profile_tx"
//	SET
//	  title = $1,
//	  description = $2,
//	  properties = $3
//	WHERE profile_id = $4
//	  AND locale_code = $5
func (q *Queries) UpdateProfileTx(ctx context.Context, arg UpdateProfileTxParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateProfileTx,
		arg.Title,
		arg.Description,
		arg.Properties,
		arg.ProfileID,
		arg.LocaleCode,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const upsertProfileLinkTx = `-- name: UpsertProfileLinkTx :exec
INSERT INTO "profile_link_tx" (
  profile_link_id,
  locale_code,
  title,
  icon,
  "group",
  description
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6
) ON CONFLICT (profile_link_id, locale_code) DO UPDATE SET
  title = EXCLUDED.title,
  icon = EXCLUDED.icon,
  "group" = EXCLUDED."group",
  description = EXCLUDED.description
`

type UpsertProfileLinkTxParams struct {
	ProfileLinkID string         `db:"profile_link_id" json:"profile_link_id"`
	LocaleCode    string         `db:"locale_code" json:"locale_code"`
	Title         string         `db:"title" json:"title"`
	Icon          sql.NullString `db:"icon" json:"icon"`
	LinkGroup     sql.NullString `db:"link_group" json:"link_group"`
	Description   sql.NullString `db:"description" json:"description"`
}

// UpsertProfileLinkTx
//
//	INSERT INTO "profile_link_tx" (
//	  profile_link_id,
//	  locale_code,
//	  title,
//	  icon,
//	  "group",
//	  description
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5,
//	  $6
//	) ON CONFLICT (profile_link_id, locale_code) DO UPDATE SET
//	  title = EXCLUDED.title,
//	  icon = EXCLUDED.icon,
//	  "group" = EXCLUDED."group",
//	  description = EXCLUDED.description
func (q *Queries) UpsertProfileLinkTx(ctx context.Context, arg UpsertProfileLinkTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertProfileLinkTx,
		arg.ProfileLinkID,
		arg.LocaleCode,
		arg.Title,
		arg.Icon,
		arg.LinkGroup,
		arg.Description,
	)
	return err
}

const upsertProfilePageTx = `-- name: UpsertProfilePageTx :exec
INSERT INTO "profile_page_tx" (
  profile_page_id,
  locale_code,
  title,
  summary,
  content
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
) ON CONFLICT (profile_page_id, locale_code) DO UPDATE SET
  title = EXCLUDED.title,
  summary = EXCLUDED.summary,
  content = EXCLUDED.content
`

type UpsertProfilePageTxParams struct {
	ProfilePageID string `db:"profile_page_id" json:"profile_page_id"`
	LocaleCode    string `db:"locale_code" json:"locale_code"`
	Title         string `db:"title" json:"title"`
	Summary       string `db:"summary" json:"summary"`
	Content       string `db:"content" json:"content"`
}

// UpsertProfilePageTx
//
//	INSERT INTO "profile_page_tx" (
//	  profile_page_id,
//	  locale_code,
//	  title,
//	  summary,
//	  content
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5
//	) ON CONFLICT (profile_page_id, locale_code) DO UPDATE SET
//	  title = EXCLUDED.title,
//	  summary = EXCLUDED.summary,
//	  content = EXCLUDED.content
func (q *Queries) UpsertProfilePageTx(ctx context.Context, arg UpsertProfilePageTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertProfilePageTx,
		arg.ProfilePageID,
		arg.LocaleCode,
		arg.Title,
		arg.Summary,
		arg.Content,
	)
	return err
}

const upsertProfileTx = `-- name: UpsertProfileTx :exec
INSERT INTO "profile_tx" (profile_id, locale_code, title, description, properties)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (profile_id, locale_code)
DO UPDATE SET
  title = EXCLUDED.title,
  description = EXCLUDED.description,
  properties = EXCLUDED.properties
`

type UpsertProfileTxParams struct {
	ProfileID   string                `db:"profile_id" json:"profile_id"`
	LocaleCode  string                `db:"locale_code" json:"locale_code"`
	Title       string                `db:"title" json:"title"`
	Description string                `db:"description" json:"description"`
	Properties  pqtype.NullRawMessage `db:"properties" json:"properties"`
}

// UpsertProfileTx
//
//	INSERT INTO "profile_tx" (profile_id, locale_code, title, description, properties)
//	VALUES ($1, $2, $3, $4, $5)
//	ON CONFLICT (profile_id, locale_code)
//	DO UPDATE SET
//	  title = EXCLUDED.title,
//	  description = EXCLUDED.description,
//	  properties = EXCLUDED.properties
func (q *Queries) UpsertProfileTx(ctx context.Context, arg UpsertProfileTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertProfileTx,
		arg.ProfileID,
		arg.LocaleCode,
		arg.Title,
		arg.Description,
		arg.Properties,
	)
	return err
}
