// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: bulletin.sql

package storage

import (
	"context"
	"database/sql"
	"time"
)

const createBulletinLog = `-- name: CreateBulletinLog :exec
INSERT INTO "bulletin_log" (
  "id", "subscription_id", "story_count", "status", "error_message", "created_at"
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  NOW()
)
`

type CreateBulletinLogParams struct {
	ID             string         `db:"id" json:"id"`
	SubscriptionID string         `db:"subscription_id" json:"subscription_id"`
	StoryCount     int32          `db:"story_count" json:"story_count"`
	Status         string         `db:"status" json:"status"`
	ErrorMessage   sql.NullString `db:"error_message" json:"error_message"`
}

// Records a bulletin send attempt.
//
//	INSERT INTO "bulletin_log" (
//	  "id", "subscription_id", "story_count", "status", "error_message", "created_at"
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5,
//	  NOW()
//	)
func (q *Queries) CreateBulletinLog(ctx context.Context, arg CreateBulletinLogParams) error {
	_, err := q.db.ExecContext(ctx, createBulletinLog,
		arg.ID,
		arg.SubscriptionID,
		arg.StoryCount,
		arg.Status,
		arg.ErrorMessage,
	)
	return err
}

const deleteBulletinSubscription = `-- name: DeleteBulletinSubscription :exec
UPDATE "bulletin_subscription"
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type DeleteBulletinSubscriptionParams struct {
	ID string `db:"id" json:"id"`
}

// Soft-deletes a subscription.
//
//	UPDATE "bulletin_subscription"
//	SET deleted_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) DeleteBulletinSubscription(ctx context.Context, arg DeleteBulletinSubscriptionParams) error {
	_, err := q.db.ExecContext(ctx, deleteBulletinSubscription, arg.ID)
	return err
}

const deleteBulletinSubscriptionsByProfileID = `-- name: DeleteBulletinSubscriptionsByProfileID :exec
UPDATE "bulletin_subscription"
SET deleted_at = NOW()
WHERE profile_id = $1
  AND deleted_at IS NULL
`

type DeleteBulletinSubscriptionsByProfileIDParams struct {
	ProfileID string `db:"profile_id" json:"profile_id"`
}

// Soft-deletes all subscriptions for a profile (used for "Don't send").
//
//	UPDATE "bulletin_subscription"
//	SET deleted_at = NOW()
//	WHERE profile_id = $1
//	  AND deleted_at IS NULL
func (q *Queries) DeleteBulletinSubscriptionsByProfileID(ctx context.Context, arg DeleteBulletinSubscriptionsByProfileIDParams) error {
	_, err := q.db.ExecContext(ctx, deleteBulletinSubscriptionsByProfileID, arg.ProfileID)
	return err
}

const getActiveSubscriptionsForWindow = `-- name: GetActiveSubscriptionsForWindow :many
SELECT
  bs.id,
  bs.profile_id,
  bs.channel,
  bs.frequency,
  bs.preferred_time,
  bs.last_bulletin_at,
  bs.created_at,
  bs.updated_at,
  p.default_locale,
  p.slug AS profile_slug
FROM "bulletin_subscription" bs
  INNER JOIN "profile" p ON p.id = bs.profile_id
    AND p.deleted_at IS NULL
    AND p.approved_at IS NOT NULL
WHERE bs.deleted_at IS NULL
  AND bs.preferred_time = $1::SMALLINT
  AND (
    bs.last_bulletin_at IS NULL
    OR (bs.frequency = 'daily'   AND bs.last_bulletin_at < NOW() - INTERVAL '20 hours')
    OR (bs.frequency = 'bidaily' AND bs.last_bulletin_at < NOW() - INTERVAL '44 hours')
    OR (bs.frequency = 'weekly'  AND bs.last_bulletin_at < NOW() - INTERVAL '164 hours')
  )
`

type GetActiveSubscriptionsForWindowParams struct {
	UtcHour int16 `db:"utc_hour" json:"utc_hour"`
}

type GetActiveSubscriptionsForWindowRow struct {
	ID             string       `db:"id" json:"id"`
	ProfileID      string       `db:"profile_id" json:"profile_id"`
	Channel        string       `db:"channel" json:"channel"`
	Frequency      string       `db:"frequency" json:"frequency"`
	PreferredTime  int16        `db:"preferred_time" json:"preferred_time"`
	LastBulletinAt sql.NullTime `db:"last_bulletin_at" json:"last_bulletin_at"`
	CreatedAt      time.Time    `db:"created_at" json:"created_at"`
	UpdatedAt      sql.NullTime `db:"updated_at" json:"updated_at"`
	DefaultLocale  string       `db:"default_locale" json:"default_locale"`
	ProfileSlug    string       `db:"profile_slug" json:"profile_slug"`
}

// Returns active bulletin subscriptions whose preferred_time matches the given UTC hour
// and whose last_bulletin_at respects the frequency-based cooldown.
//
//	SELECT
//	  bs.id,
//	  bs.profile_id,
//	  bs.channel,
//	  bs.frequency,
//	  bs.preferred_time,
//	  bs.last_bulletin_at,
//	  bs.created_at,
//	  bs.updated_at,
//	  p.default_locale,
//	  p.slug AS profile_slug
//	FROM "bulletin_subscription" bs
//	  INNER JOIN "profile" p ON p.id = bs.profile_id
//	    AND p.deleted_at IS NULL
//	    AND p.approved_at IS NOT NULL
//	WHERE bs.deleted_at IS NULL
//	  AND bs.preferred_time = $1::SMALLINT
//	  AND (
//	    bs.last_bulletin_at IS NULL
//	    OR (bs.frequency = 'daily'   AND bs.last_bulletin_at < NOW() - INTERVAL '20 hours')
//	    OR (bs.frequency = 'bidaily' AND bs.last_bulletin_at < NOW() - INTERVAL '44 hours')
//	    OR (bs.frequency = 'weekly'  AND bs.last_bulletin_at < NOW() - INTERVAL '164 hours')
//	  )
func (q *Queries) GetActiveSubscriptionsForWindow(ctx context.Context, arg GetActiveSubscriptionsForWindowParams) ([]*GetActiveSubscriptionsForWindowRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveSubscriptionsForWindow, arg.UtcHour)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetActiveSubscriptionsForWindowRow{}
	for rows.Next() {
		var i GetActiveSubscriptionsForWindowRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Channel,
			&i.Frequency,
			&i.PreferredTime,
			&i.LastBulletinAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DefaultLocale,
			&i.ProfileSlug,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getBulletinSubscription = `-- name: GetBulletinSubscription :one
SELECT
  bs.id,
  bs.profile_id,
  bs.channel,
  bs.frequency,
  bs.preferred_time,
  bs.last_bulletin_at,
  bs.created_at,
  bs.updated_at
FROM "bulletin_subscription" bs
WHERE bs.id = $1
  AND bs.deleted_at IS NULL
`

type GetBulletinSubscriptionParams struct {
	ID string `db:"id" json:"id"`
}

type GetBulletinSubscriptionRow struct {
	ID             string       `db:"id" json:"id"`
	ProfileID      string       `db:"profile_id" json:"profile_id"`
	Channel        string       `db:"channel" json:"channel"`
	Frequency      string       `db:"frequency" json:"frequency"`
	PreferredTime  int16        `db:"preferred_time" json:"preferred_time"`
	LastBulletinAt sql.NullTime `db:"last_bulletin_at" json:"last_bulletin_at"`
	CreatedAt      time.Time    `db:"created_at" json:"created_at"`
	UpdatedAt      sql.NullTime `db:"updated_at" json:"updated_at"`
}

// Returns a single subscription by ID.
//
//	SELECT
//	  bs.id,
//	  bs.profile_id,
//	  bs.channel,
//	  bs.frequency,
//	  bs.preferred_time,
//	  bs.last_bulletin_at,
//	  bs.created_at,
//	  bs.updated_at
//	FROM "bulletin_subscription" bs
//	WHERE bs.id = $1
//	  AND bs.deleted_at IS NULL
func (q *Queries) GetBulletinSubscription(ctx context.Context, arg GetBulletinSubscriptionParams) (*GetBulletinSubscriptionRow, error) {
	row := q.db.QueryRowContext(ctx, getBulletinSubscription, arg.ID)
	var i GetBulletinSubscriptionRow
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Channel,
		&i.Frequency,
		&i.PreferredTime,
		&i.LastBulletinAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getBulletinSubscriptionsByProfileID = `-- name: GetBulletinSubscriptionsByProfileID :many
SELECT
  bs.id,
  bs.profile_id,
  bs.channel,
  bs.frequency,
  bs.preferred_time,
  bs.last_bulletin_at,
  bs.created_at,
  bs.updated_at
FROM "bulletin_subscription" bs
WHERE bs.profile_id = $1
  AND bs.deleted_at IS NULL
ORDER BY bs.created_at
`

type GetBulletinSubscriptionsByProfileIDParams struct {
	ProfileID string `db:"profile_id" json:"profile_id"`
}

type GetBulletinSubscriptionsByProfileIDRow struct {
	ID             string       `db:"id" json:"id"`
	ProfileID      string       `db:"profile_id" json:"profile_id"`
	Channel        string       `db:"channel" json:"channel"`
	Frequency      string       `db:"frequency" json:"frequency"`
	PreferredTime  int16        `db:"preferred_time" json:"preferred_time"`
	LastBulletinAt sql.NullTime `db:"last_bulletin_at" json:"last_bulletin_at"`
	CreatedAt      time.Time    `db:"created_at" json:"created_at"`
	UpdatedAt      sql.NullTime `db:"updated_at" json:"updated_at"`
}

// Returns all active subscriptions for a given profile.
//
//	SELECT
//	  bs.id,
//	  bs.profile_id,
//	  bs.channel,
//	  bs.frequency,
//	  bs.preferred_time,
//	  bs.last_bulletin_at,
//	  bs.created_at,
//	  bs.updated_at
//	FROM "bulletin_subscription" bs
//	WHERE bs.profile_id = $1
//	  AND bs.deleted_at IS NULL
//	ORDER BY bs.created_at
func (q *Queries) GetBulletinSubscriptionsByProfileID(ctx context.Context, arg GetBulletinSubscriptionsByProfileIDParams) ([]*GetBulletinSubscriptionsByProfileIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getBulletinSubscriptionsByProfileID, arg.ProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetBulletinSubscriptionsByProfileIDRow{}
	for rows.Next() {
		var i GetBulletinSubscriptionsByProfileIDRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.Channel,
			&i.Frequency,
			&i.PreferredTime,
			&i.LastBulletinAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getFollowedProfileStoriesSince = `-- name: GetFollowedProfileStoriesSince :many
SELECT
  s.id AS story_id,
  s.slug AS story_slug,
  s.kind AS story_kind,
  s.story_picture_uri,
  st.locale_code AS story_locale_code,
  st.title AS story_title,
  st.summary AS story_summary,
  st.summary_ai AS story_summary_ai,
  ap.id AS author_profile_id,
  ap.slug AS author_profile_slug,
  apt.title AS author_profile_title,
  (SELECT MIN(sp2.published_at) FROM story_publication sp2 WHERE sp2.story_id = s.id AND sp2.deleted_at IS NULL) AS published_at
FROM "profile_membership" pm
  INNER JOIN "story" s ON s.author_profile_id = pm.profile_id
    AND s.deleted_at IS NULL
    AND s.kind IN ('article', 'news', 'content')
  INNER JOIN "story_tx" st ON st.story_id = s.id
    AND st.locale_code = (
      SELECT stx.locale_code FROM "story_tx" stx
      WHERE stx.story_id = s.id
      ORDER BY CASE
        WHEN stx.locale_code = $1 THEN 0
        WHEN stx.locale_code = (SELECT p_loc.default_locale FROM "profile" p_loc WHERE p_loc.id = s.author_profile_id) THEN 1
        ELSE 2
      END
      LIMIT 1
    )
  INNER JOIN "profile" ap ON ap.id = s.author_profile_id
    AND ap.deleted_at IS NULL
    AND ap.approved_at IS NOT NULL
  INNER JOIN "profile_tx" apt ON apt.profile_id = ap.id
    AND apt.locale_code = (
      SELECT aptf.locale_code FROM "profile_tx" aptf
      WHERE aptf.profile_id = ap.id
      ORDER BY CASE
        WHEN aptf.locale_code = $1 THEN 0
        WHEN aptf.locale_code = ap.default_locale THEN 1
        ELSE 2
      END
      LIMIT 1
    )
WHERE pm.member_profile_id = $2
  AND pm.kind = 'follower'
  AND pm.deleted_at IS NULL
  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
  AND EXISTS (
    SELECT 1 FROM story_publication sp
    WHERE sp.story_id = s.id
      AND sp.published_at IS NOT NULL
      AND sp.published_at > $3
      AND sp.deleted_at IS NULL
  )
  AND s.visibility = 'public'
ORDER BY published_at DESC
LIMIT $4
`

type GetFollowedProfileStoriesSinceParams struct {
	LocaleCode          string         `db:"locale_code" json:"locale_code"`
	SubscriberProfileID sql.NullString `db:"subscriber_profile_id" json:"subscriber_profile_id"`
	Since               sql.NullTime   `db:"since" json:"since"`
	MaxStories          int32          `db:"max_stories" json:"max_stories"`
}

type GetFollowedProfileStoriesSinceRow struct {
	StoryID            string         `db:"story_id" json:"story_id"`
	StorySlug          string         `db:"story_slug" json:"story_slug"`
	StoryKind          string         `db:"story_kind" json:"story_kind"`
	StoryPictureURI    sql.NullString `db:"story_picture_uri" json:"story_picture_uri"`
	StoryLocaleCode    string         `db:"story_locale_code" json:"story_locale_code"`
	StoryTitle         string         `db:"story_title" json:"story_title"`
	StorySummary       string         `db:"story_summary" json:"story_summary"`
	StorySummaryAi     sql.NullString `db:"story_summary_ai" json:"story_summary_ai"`
	AuthorProfileID    string         `db:"author_profile_id" json:"author_profile_id"`
	AuthorProfileSlug  string         `db:"author_profile_slug" json:"author_profile_slug"`
	AuthorProfileTitle string         `db:"author_profile_title" json:"author_profile_title"`
	PublishedAt        interface{}    `db:"published_at" json:"published_at"`
}

// Returns published stories from profiles that the given subscriber follows,
// published since the given timestamp, with 3-tier locale fallback on both
// story_tx and author profile_tx.
//
//	SELECT
//	  s.id AS story_id,
//	  s.slug AS story_slug,
//	  s.kind AS story_kind,
//	  s.story_picture_uri,
//	  st.locale_code AS story_locale_code,
//	  st.title AS story_title,
//	  st.summary AS story_summary,
//	  st.summary_ai AS story_summary_ai,
//	  ap.id AS author_profile_id,
//	  ap.slug AS author_profile_slug,
//	  apt.title AS author_profile_title,
//	  (SELECT MIN(sp2.published_at) FROM story_publication sp2 WHERE sp2.story_id = s.id AND sp2.deleted_at IS NULL) AS published_at
//	FROM "profile_membership" pm
//	  INNER JOIN "story" s ON s.author_profile_id = pm.profile_id
//	    AND s.deleted_at IS NULL
//	    AND s.kind IN ('article', 'news', 'content')
//	  INNER JOIN "story_tx" st ON st.story_id = s.id
//	    AND st.locale_code = (
//	      SELECT stx.locale_code FROM "story_tx" stx
//	      WHERE stx.story_id = s.id
//	      ORDER BY CASE
//	        WHEN stx.locale_code = $1 THEN 0
//	        WHEN stx.locale_code = (SELECT p_loc.default_locale FROM "profile" p_loc WHERE p_loc.id = s.author_profile_id) THEN 1
//	        ELSE 2
//	      END
//	      LIMIT 1
//	    )
//	  INNER JOIN "profile" ap ON ap.id = s.author_profile_id
//	    AND ap.deleted_at IS NULL
//	    AND ap.approved_at IS NOT NULL
//	  INNER JOIN "profile_tx" apt ON apt.profile_id = ap.id
//	    AND apt.locale_code = (
//	      SELECT aptf.locale_code FROM "profile_tx" aptf
//	      WHERE aptf.profile_id = ap.id
//	      ORDER BY CASE
//	        WHEN aptf.locale_code = $1 THEN 0
//	        WHEN aptf.locale_code = ap.default_locale THEN 1
//	        ELSE 2
//	      END
//	      LIMIT 1
//	    )
//	WHERE pm.member_profile_id = $2
//	  AND pm.kind = 'follower'
//	  AND pm.deleted_at IS NULL
//	  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
//	  AND EXISTS (
//	    SELECT 1 FROM story_publication sp
//	    WHERE sp.story_id = s.id
//	      AND sp.published_at IS NOT NULL
//	      AND sp.published_at > $3
//	      AND sp.deleted_at IS NULL
//	  )
//	  AND s.visibility = 'public'
//	ORDER BY published_at DESC
//	LIMIT $4
func (q *Queries) GetFollowedProfileStoriesSince(ctx context.Context, arg GetFollowedProfileStoriesSinceParams) ([]*GetFollowedProfileStoriesSinceRow, error) {
	rows, err := q.db.QueryContext(ctx, getFollowedProfileStoriesSince,
		arg.LocaleCode,
		arg.SubscriberProfileID,
		arg.Since,
		arg.MaxStories,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetFollowedProfileStoriesSinceRow{}
	for rows.Next() {
		var i GetFollowedProfileStoriesSinceRow
		if err := rows.Scan(
			&i.StoryID,
			&i.StorySlug,
			&i.StoryKind,
			&i.StoryPictureURI,
			&i.StoryLocaleCode,
			&i.StoryTitle,
			&i.StorySummary,
			&i.StorySummaryAi,
			&i.AuthorProfileID,
			&i.AuthorProfileSlug,
			&i.AuthorProfileTitle,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserEmailByIndividualProfileID = `-- name: GetUserEmailByIndividualProfileID :one
SELECT u.email
FROM "user" u
WHERE u.individual_profile_id = $1
  AND u.deleted_at IS NULL
LIMIT 1
`

type GetUserEmailByIndividualProfileIDParams struct {
	ProfileID sql.NullString `db:"profile_id" json:"profile_id"`
}

// Returns the user's email for a given individual profile ID.
//
//	SELECT u.email
//	FROM "user" u
//	WHERE u.individual_profile_id = $1
//	  AND u.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetUserEmailByIndividualProfileID(ctx context.Context, arg GetUserEmailByIndividualProfileIDParams) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getUserEmailByIndividualProfileID, arg.ProfileID)
	var email sql.NullString
	err := row.Scan(&email)
	return email, err
}

const updateBulletinSubscriptionLastSentAt = `-- name: UpdateBulletinSubscriptionLastSentAt :exec
UPDATE "bulletin_subscription"
SET last_bulletin_at = NOW(),
    updated_at = NOW()
WHERE id = $1
`

type UpdateBulletinSubscriptionLastSentAtParams struct {
	ID string `db:"id" json:"id"`
}

// Updates the last_bulletin_at timestamp after successfully sending a bulletin.
//
//	UPDATE "bulletin_subscription"
//	SET last_bulletin_at = NOW(),
//	    updated_at = NOW()
//	WHERE id = $1
func (q *Queries) UpdateBulletinSubscriptionLastSentAt(ctx context.Context, arg UpdateBulletinSubscriptionLastSentAtParams) error {
	_, err := q.db.ExecContext(ctx, updateBulletinSubscriptionLastSentAt, arg.ID)
	return err
}

const updateBulletinSubscriptionPreferences = `-- name: UpdateBulletinSubscriptionPreferences :exec
UPDATE "bulletin_subscription"
SET frequency = $1,
    preferred_time = $2,
    updated_at = NOW()
WHERE id = $3
  AND deleted_at IS NULL
`

type UpdateBulletinSubscriptionPreferencesParams struct {
	Frequency     string `db:"frequency" json:"frequency"`
	PreferredTime int16  `db:"preferred_time" json:"preferred_time"`
	ID            string `db:"id" json:"id"`
}

// Updates the frequency and preferred time for a subscription.
//
//	UPDATE "bulletin_subscription"
//	SET frequency = $1,
//	    preferred_time = $2,
//	    updated_at = NOW()
//	WHERE id = $3
//	  AND deleted_at IS NULL
func (q *Queries) UpdateBulletinSubscriptionPreferences(ctx context.Context, arg UpdateBulletinSubscriptionPreferencesParams) error {
	_, err := q.db.ExecContext(ctx, updateBulletinSubscriptionPreferences, arg.Frequency, arg.PreferredTime, arg.ID)
	return err
}

const upsertBulletinSubscription = `-- name: UpsertBulletinSubscription :one
INSERT INTO "bulletin_subscription" (
  "id", "profile_id", "channel", "frequency", "preferred_time", "created_at"
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  NOW()
)
ON CONFLICT ("profile_id", "channel") WHERE "deleted_at" IS NULL
DO UPDATE SET
  frequency = EXCLUDED.frequency,
  preferred_time = EXCLUDED.preferred_time,
  deleted_at = NULL,
  updated_at = NOW()
RETURNING id, profile_id, channel, preferred_time, last_bulletin_at, created_at, updated_at, deleted_at, frequency
`

type UpsertBulletinSubscriptionParams struct {
	ID            string `db:"id" json:"id"`
	ProfileID     string `db:"profile_id" json:"profile_id"`
	Channel       string `db:"channel" json:"channel"`
	Frequency     string `db:"frequency" json:"frequency"`
	PreferredTime int16  `db:"preferred_time" json:"preferred_time"`
}

// Creates or reactivates a subscription for a profile+channel combination.
//
//	INSERT INTO "bulletin_subscription" (
//	  "id", "profile_id", "channel", "frequency", "preferred_time", "created_at"
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5,
//	  NOW()
//	)
//	ON CONFLICT ("profile_id", "channel") WHERE "deleted_at" IS NULL
//	DO UPDATE SET
//	  frequency = EXCLUDED.frequency,
//	  preferred_time = EXCLUDED.preferred_time,
//	  deleted_at = NULL,
//	  updated_at = NOW()
//	RETURNING id, profile_id, channel, preferred_time, last_bulletin_at, created_at, updated_at, deleted_at, frequency
func (q *Queries) UpsertBulletinSubscription(ctx context.Context, arg UpsertBulletinSubscriptionParams) (*BulletinSubscription, error) {
	row := q.db.QueryRowContext(ctx, upsertBulletinSubscription,
		arg.ID,
		arg.ProfileID,
		arg.Channel,
		arg.Frequency,
		arg.PreferredTime,
	)
	var i BulletinSubscription
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.Channel,
		&i.PreferredTime,
		&i.LastBulletinAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Frequency,
	)
	return &i, err
}

const upsertStorySummaryAI = `-- name: UpsertStorySummaryAI :exec
UPDATE "story_tx"
SET summary_ai = $1
WHERE story_id = $2
  AND locale_code = $3
`

type UpsertStorySummaryAIParams struct {
	SummaryAi  sql.NullString `db:"summary_ai" json:"summary_ai"`
	StoryID    string         `db:"story_id" json:"story_id"`
	LocaleCode string         `db:"locale_code" json:"locale_code"`
}

// Updates the AI-generated summary for a specific story translation.
//
//	UPDATE "story_tx"
//	SET summary_ai = $1
//	WHERE story_id = $2
//	  AND locale_code = $3
func (q *Queries) UpsertStorySummaryAI(ctx context.Context, arg UpsertStorySummaryAIParams) error {
	_, err := q.db.ExecContext(ctx, upsertStorySummaryAI, arg.SummaryAi, arg.StoryID, arg.LocaleCode)
	return err
}
