// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: telegram.sql

package storage

import (
	"context"
	"database/sql"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const cleanupExpiredExternalCodes = `-- name: CleanupExpiredExternalCodes :execrows
DELETE FROM "external_code"
WHERE expires_at < NOW() - INTERVAL '1 hour'
`

// CleanupExpiredExternalCodes
//
//	DELETE FROM "external_code"
//	WHERE expires_at < NOW() - INTERVAL '1 hour'
func (q *Queries) CleanupExpiredExternalCodes(ctx context.Context) (int64, error) {
	result, err := q.db.ExecContext(ctx, cleanupExpiredExternalCodes)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const consumeExternalCode = `-- name: ConsumeExternalCode :execrows
UPDATE "external_code"
SET consumed_at = NOW()
WHERE code = $1
  AND consumed_at IS NULL
`

type ConsumeExternalCodeParams struct {
	Code string `db:"code" json:"code"`
}

// ConsumeExternalCode
//
//	UPDATE "external_code"
//	SET consumed_at = NOW()
//	WHERE code = $1
//	  AND consumed_at IS NULL
func (q *Queries) ConsumeExternalCode(ctx context.Context, arg ConsumeExternalCodeParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, consumeExternalCode, arg.Code)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const createExternalCode = `-- name: CreateExternalCode :exec
INSERT INTO "external_code" (id, code, external_system, properties, created_at, expires_at)
VALUES ($1, $2, $3, $4, NOW(), $5)
`

type CreateExternalCodeParams struct {
	ID             string                `db:"id" json:"id"`
	Code           string                `db:"code" json:"code"`
	ExternalSystem string                `db:"external_system" json:"external_system"`
	Properties     pqtype.NullRawMessage `db:"properties" json:"properties"`
	ExpiresAt      time.Time             `db:"expires_at" json:"expires_at"`
}

// CreateExternalCode
//
//	INSERT INTO "external_code" (id, code, external_system, properties, created_at, expires_at)
//	VALUES ($1, $2, $3, $4, NOW(), $5)
func (q *Queries) CreateExternalCode(ctx context.Context, arg CreateExternalCodeParams) error {
	_, err := q.db.ExecContext(ctx, createExternalCode,
		arg.ID,
		arg.Code,
		arg.ExternalSystem,
		arg.Properties,
		arg.ExpiresAt,
	)
	return err
}

const getEligibleTelegramGroupsForProfile = `-- name: GetEligibleTelegramGroupsForProfile :many
SELECT DISTINCT
  pr.id as resource_id,
  pr.title as group_title,
  pr.properties as properties,
  p.slug as profile_slug,
  pt_tx.title as profile_title
FROM "profile_membership" pm
  INNER JOIN "profile_membership_team" pmt ON pmt.profile_membership_id = pm.id
    AND pmt.deleted_at IS NULL
  INNER JOIN "profile_resource_team" prt ON prt.profile_team_id = pmt.profile_team_id
    AND prt.deleted_at IS NULL
  INNER JOIN "profile_resource" pr ON pr.id = prt.profile_resource_id
    AND pr.kind = 'telegram_group'
    AND pr.deleted_at IS NULL
  INNER JOIN "profile" p ON p.id = pr.profile_id
    AND p.deleted_at IS NULL
  INNER JOIN "profile_tx" pt_tx ON pt_tx.profile_id = p.id
    AND pt_tx.locale_code = (
      SELECT ptf.locale_code FROM "profile_tx" ptf
      WHERE ptf.profile_id = p.id
      ORDER BY CASE WHEN ptf.locale_code = p.default_locale THEN 0 ELSE 1 END
      LIMIT 1
    )
WHERE pm.member_profile_id = $1
  AND pm.deleted_at IS NULL
  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
ORDER BY p.slug, pr.title
`

type GetEligibleTelegramGroupsForProfileParams struct {
	MemberProfileID sql.NullString `db:"member_profile_id" json:"member_profile_id"`
}

type GetEligibleTelegramGroupsForProfileRow struct {
	ResourceID   string                `db:"resource_id" json:"resource_id"`
	GroupTitle   string                `db:"group_title" json:"group_title"`
	Properties   pqtype.NullRawMessage `db:"properties" json:"properties"`
	ProfileSlug  string                `db:"profile_slug" json:"profile_slug"`
	ProfileTitle string                `db:"profile_title" json:"profile_title"`
}

// For a given member profile, find telegram_group resources they can access
// through team assignments: membership → membership_team → team → resource_team → resource.
//
//	SELECT DISTINCT
//	  pr.id as resource_id,
//	  pr.title as group_title,
//	  pr.properties as properties,
//	  p.slug as profile_slug,
//	  pt_tx.title as profile_title
//	FROM "profile_membership" pm
//	  INNER JOIN "profile_membership_team" pmt ON pmt.profile_membership_id = pm.id
//	    AND pmt.deleted_at IS NULL
//	  INNER JOIN "profile_resource_team" prt ON prt.profile_team_id = pmt.profile_team_id
//	    AND prt.deleted_at IS NULL
//	  INNER JOIN "profile_resource" pr ON pr.id = prt.profile_resource_id
//	    AND pr.kind = 'telegram_group'
//	    AND pr.deleted_at IS NULL
//	  INNER JOIN "profile" p ON p.id = pr.profile_id
//	    AND p.deleted_at IS NULL
//	  INNER JOIN "profile_tx" pt_tx ON pt_tx.profile_id = p.id
//	    AND pt_tx.locale_code = (
//	      SELECT ptf.locale_code FROM "profile_tx" ptf
//	      WHERE ptf.profile_id = p.id
//	      ORDER BY CASE WHEN ptf.locale_code = p.default_locale THEN 0 ELSE 1 END
//	      LIMIT 1
//	    )
//	WHERE pm.member_profile_id = $1
//	  AND pm.deleted_at IS NULL
//	  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
//	ORDER BY p.slug, pr.title
func (q *Queries) GetEligibleTelegramGroupsForProfile(ctx context.Context, arg GetEligibleTelegramGroupsForProfileParams) ([]*GetEligibleTelegramGroupsForProfileRow, error) {
	rows, err := q.db.QueryContext(ctx, getEligibleTelegramGroupsForProfile, arg.MemberProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetEligibleTelegramGroupsForProfileRow{}
	for rows.Next() {
		var i GetEligibleTelegramGroupsForProfileRow
		if err := rows.Scan(
			&i.ResourceID,
			&i.GroupTitle,
			&i.Properties,
			&i.ProfileSlug,
			&i.ProfileTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getExternalCodeByCode = `-- name: GetExternalCodeByCode :one
SELECT id, code, external_system, properties, created_at, expires_at, consumed_at
FROM "external_code"
WHERE code = $1
  AND consumed_at IS NULL
  AND expires_at > NOW()
LIMIT 1
`

type GetExternalCodeByCodeParams struct {
	Code string `db:"code" json:"code"`
}

// GetExternalCodeByCode
//
//	SELECT id, code, external_system, properties, created_at, expires_at, consumed_at
//	FROM "external_code"
//	WHERE code = $1
//	  AND consumed_at IS NULL
//	  AND expires_at > NOW()
//	LIMIT 1
func (q *Queries) GetExternalCodeByCode(ctx context.Context, arg GetExternalCodeByCodeParams) (*ExternalCode, error) {
	row := q.db.QueryRowContext(ctx, getExternalCodeByCode, arg.Code)
	var i ExternalCode
	err := row.Scan(
		&i.ID,
		&i.Code,
		&i.ExternalSystem,
		&i.Properties,
		&i.CreatedAt,
		&i.ExpiresAt,
		&i.ConsumedAt,
	)
	return &i, err
}

const getMemberProfileTelegramLinks = `-- name: GetMemberProfileTelegramLinks :many
SELECT
  p.id as profile_id,
  p.slug as profile_slug,
  pt.title as profile_title,
  pm.kind as membership_kind,
  pl.id as link_id,
  pl.uri,
  pl.public_id as link_public_id,
  pl.visibility as link_visibility,
  COALESCE(plt.title, '') as link_title
FROM "profile_membership" pm
  INNER JOIN "profile" p ON p.id = pm.profile_id
    AND p.kind != 'individual'
    AND p.approved_at IS NOT NULL
    AND p.deleted_at IS NULL
  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
    AND pt.locale_code = (
      SELECT ptf.locale_code FROM "profile_tx" ptf
      WHERE ptf.profile_id = p.id
      ORDER BY CASE WHEN ptf.locale_code = p.default_locale THEN 0 ELSE 1 END
      LIMIT 1
    )
  INNER JOIN "profile_link" pl ON pl.profile_id = p.id
    AND pl.kind = 'telegram'
    AND pl.deleted_at IS NULL
  LEFT JOIN "profile_link_tx" plt ON plt.profile_link_id = pl.id
    AND plt.locale_code = pt.locale_code
WHERE pm.member_profile_id = $1
  AND pm.deleted_at IS NULL
  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
ORDER BY p.slug, pl."order"
`

type GetMemberProfileTelegramLinksParams struct {
	MemberProfileID sql.NullString `db:"member_profile_id" json:"member_profile_id"`
}

type GetMemberProfileTelegramLinksRow struct {
	ProfileID      string         `db:"profile_id" json:"profile_id"`
	ProfileSlug    string         `db:"profile_slug" json:"profile_slug"`
	ProfileTitle   string         `db:"profile_title" json:"profile_title"`
	MembershipKind string         `db:"membership_kind" json:"membership_kind"`
	LinkID         string         `db:"link_id" json:"link_id"`
	URI            sql.NullString `db:"uri" json:"uri"`
	LinkPublicID   sql.NullString `db:"link_public_id" json:"link_public_id"`
	LinkVisibility string         `db:"link_visibility" json:"link_visibility"`
	LinkTitle      string         `db:"link_title" json:"link_title"`
}

// For a given member profile, find all non-individual profiles they belong to
// and return the telegram links on those profiles (visibility filtering happens in Go).
//
//	SELECT
//	  p.id as profile_id,
//	  p.slug as profile_slug,
//	  pt.title as profile_title,
//	  pm.kind as membership_kind,
//	  pl.id as link_id,
//	  pl.uri,
//	  pl.public_id as link_public_id,
//	  pl.visibility as link_visibility,
//	  COALESCE(plt.title, '') as link_title
//	FROM "profile_membership" pm
//	  INNER JOIN "profile" p ON p.id = pm.profile_id
//	    AND p.kind != 'individual'
//	    AND p.approved_at IS NOT NULL
//	    AND p.deleted_at IS NULL
//	  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
//	    AND pt.locale_code = (
//	      SELECT ptf.locale_code FROM "profile_tx" ptf
//	      WHERE ptf.profile_id = p.id
//	      ORDER BY CASE WHEN ptf.locale_code = p.default_locale THEN 0 ELSE 1 END
//	      LIMIT 1
//	    )
//	  INNER JOIN "profile_link" pl ON pl.profile_id = p.id
//	    AND pl.kind = 'telegram'
//	    AND pl.deleted_at IS NULL
//	  LEFT JOIN "profile_link_tx" plt ON plt.profile_link_id = pl.id
//	    AND plt.locale_code = pt.locale_code
//	WHERE pm.member_profile_id = $1
//	  AND pm.deleted_at IS NULL
//	  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
//	ORDER BY p.slug, pl."order"
func (q *Queries) GetMemberProfileTelegramLinks(ctx context.Context, arg GetMemberProfileTelegramLinksParams) ([]*GetMemberProfileTelegramLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, getMemberProfileTelegramLinks, arg.MemberProfileID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*GetMemberProfileTelegramLinksRow{}
	for rows.Next() {
		var i GetMemberProfileTelegramLinksRow
		if err := rows.Scan(
			&i.ProfileID,
			&i.ProfileSlug,
			&i.ProfileTitle,
			&i.MembershipKind,
			&i.LinkID,
			&i.URI,
			&i.LinkPublicID,
			&i.LinkVisibility,
			&i.LinkTitle,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProfileLinkByProfileIDAndTelegram = `-- name: GetProfileLinkByProfileIDAndTelegram :one
SELECT pl.id, pl.profile_id, pl.remote_id, pl.public_id
FROM "profile_link" pl
WHERE pl.profile_id = $1
  AND pl.kind = 'telegram'
  AND pl.is_managed = TRUE
  AND pl.deleted_at IS NULL
LIMIT 1
`

type GetProfileLinkByProfileIDAndTelegramParams struct {
	ProfileID string `db:"profile_id" json:"profile_id"`
}

type GetProfileLinkByProfileIDAndTelegramRow struct {
	ID        string         `db:"id" json:"id"`
	ProfileID string         `db:"profile_id" json:"profile_id"`
	RemoteID  sql.NullString `db:"remote_id" json:"remote_id"`
	PublicID  sql.NullString `db:"public_id" json:"public_id"`
}

// GetProfileLinkByProfileIDAndTelegram
//
//	SELECT pl.id, pl.profile_id, pl.remote_id, pl.public_id
//	FROM "profile_link" pl
//	WHERE pl.profile_id = $1
//	  AND pl.kind = 'telegram'
//	  AND pl.is_managed = TRUE
//	  AND pl.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetProfileLinkByProfileIDAndTelegram(ctx context.Context, arg GetProfileLinkByProfileIDAndTelegramParams) (*GetProfileLinkByProfileIDAndTelegramRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileLinkByProfileIDAndTelegram, arg.ProfileID)
	var i GetProfileLinkByProfileIDAndTelegramRow
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.RemoteID,
		&i.PublicID,
	)
	return &i, err
}

const getProfileLinkByTelegramRemoteID = `-- name: GetProfileLinkByTelegramRemoteID :one
SELECT pl.id, pl.profile_id, pl.remote_id, pl.public_id
FROM "profile_link" pl
WHERE pl.kind = 'telegram'
  AND pl.remote_id = $1
  AND pl.deleted_at IS NULL
LIMIT 1
`

type GetProfileLinkByTelegramRemoteIDParams struct {
	RemoteID sql.NullString `db:"remote_id" json:"remote_id"`
}

type GetProfileLinkByTelegramRemoteIDRow struct {
	ID        string         `db:"id" json:"id"`
	ProfileID string         `db:"profile_id" json:"profile_id"`
	RemoteID  sql.NullString `db:"remote_id" json:"remote_id"`
	PublicID  sql.NullString `db:"public_id" json:"public_id"`
}

// GetProfileLinkByTelegramRemoteID
//
//	SELECT pl.id, pl.profile_id, pl.remote_id, pl.public_id
//	FROM "profile_link" pl
//	WHERE pl.kind = 'telegram'
//	  AND pl.remote_id = $1
//	  AND pl.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetProfileLinkByTelegramRemoteID(ctx context.Context, arg GetProfileLinkByTelegramRemoteIDParams) (*GetProfileLinkByTelegramRemoteIDRow, error) {
	row := q.db.QueryRowContext(ctx, getProfileLinkByTelegramRemoteID, arg.RemoteID)
	var i GetProfileLinkByTelegramRemoteIDRow
	err := row.Scan(
		&i.ID,
		&i.ProfileID,
		&i.RemoteID,
		&i.PublicID,
	)
	return &i, err
}

const getProfileSlugByIDForTelegram = `-- name: GetProfileSlugByIDForTelegram :one
SELECT slug
FROM "profile"
WHERE id = $1
  AND deleted_at IS NULL
LIMIT 1
`

type GetProfileSlugByIDForTelegramParams struct {
	ID string `db:"id" json:"id"`
}

// GetProfileSlugByIDForTelegram
//
//	SELECT slug
//	FROM "profile"
//	WHERE id = $1
//	  AND deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetProfileSlugByIDForTelegram(ctx context.Context, arg GetProfileSlugByIDForTelegramParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getProfileSlugByIDForTelegram, arg.ID)
	var slug string
	err := row.Scan(&slug)
	return slug, err
}

const listManagedTelegramLinks = `-- name: ListManagedTelegramLinks :many
SELECT
  pl.id,
  pl.profile_id,
  pl.remote_id,
  pl.public_id
FROM "profile_link" pl
  INNER JOIN "profile" p ON p.id = pl.profile_id
    AND p.deleted_at IS NULL
WHERE pl.kind = 'telegram'
  AND pl.is_managed = TRUE
  AND pl.deleted_at IS NULL
ORDER BY pl.updated_at ASC NULLS FIRST
LIMIT $1
`

type ListManagedTelegramLinksParams struct {
	LimitCount int32 `db:"limit_count" json:"limit_count"`
}

type ListManagedTelegramLinksRow struct {
	ID        string         `db:"id" json:"id"`
	ProfileID string         `db:"profile_id" json:"profile_id"`
	RemoteID  sql.NullString `db:"remote_id" json:"remote_id"`
	PublicID  sql.NullString `db:"public_id" json:"public_id"`
}

// ListManagedTelegramLinks
//
//	SELECT
//	  pl.id,
//	  pl.profile_id,
//	  pl.remote_id,
//	  pl.public_id
//	FROM "profile_link" pl
//	  INNER JOIN "profile" p ON p.id = pl.profile_id
//	    AND p.deleted_at IS NULL
//	WHERE pl.kind = 'telegram'
//	  AND pl.is_managed = TRUE
//	  AND pl.deleted_at IS NULL
//	ORDER BY pl.updated_at ASC NULLS FIRST
//	LIMIT $1
func (q *Queries) ListManagedTelegramLinks(ctx context.Context, arg ListManagedTelegramLinksParams) ([]*ListManagedTelegramLinksRow, error) {
	rows, err := q.db.QueryContext(ctx, listManagedTelegramLinks, arg.LimitCount)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListManagedTelegramLinksRow{}
	for rows.Next() {
		var i ListManagedTelegramLinksRow
		if err := rows.Scan(
			&i.ID,
			&i.ProfileID,
			&i.RemoteID,
			&i.PublicID,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteTelegramProfileLink = `-- name: SoftDeleteTelegramProfileLink :execrows
UPDATE "profile_link"
SET deleted_at = NOW()
WHERE kind = 'telegram'
  AND remote_id = $1
  AND deleted_at IS NULL
`

type SoftDeleteTelegramProfileLinkParams struct {
	RemoteID sql.NullString `db:"remote_id" json:"remote_id"`
}

// SoftDeleteTelegramProfileLink
//
//	UPDATE "profile_link"
//	SET deleted_at = NOW()
//	WHERE kind = 'telegram'
//	  AND remote_id = $1
//	  AND deleted_at IS NULL
func (q *Queries) SoftDeleteTelegramProfileLink(ctx context.Context, arg SoftDeleteTelegramProfileLinkParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, softDeleteTelegramProfileLink, arg.RemoteID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}
