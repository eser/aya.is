// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: runtime_states.sql

package storage

import (
	"context"
)

const getRuntimeState = `-- name: GetRuntimeState :one
SELECT key, value, updated_at
FROM "runtime_state"
WHERE key = $1
LIMIT 1
`

type GetRuntimeStateParams struct {
	Key string `db:"key" json:"key"`
}

// GetRuntimeState
//
//	SELECT key, value, updated_at
//	FROM "runtime_state"
//	WHERE key = $1
//	LIMIT 1
func (q *Queries) GetRuntimeState(ctx context.Context, arg GetRuntimeStateParams) (*RuntimeState, error) {
	row := q.db.QueryRowContext(ctx, getRuntimeState, arg.Key)
	var i RuntimeState
	err := row.Scan(&i.Key, &i.Value, &i.UpdatedAt)
	return &i, err
}

const releaseAdvisoryLock = `-- name: ReleaseAdvisoryLock :one
SELECT pg_advisory_unlock($1::BIGINT) AS released
`

type ReleaseAdvisoryLockParams struct {
	LockID int64 `db:"lock_id" json:"lock_id"`
}

// ReleaseAdvisoryLock
//
//	SELECT pg_advisory_unlock($1::BIGINT) AS released
func (q *Queries) ReleaseAdvisoryLock(ctx context.Context, arg ReleaseAdvisoryLockParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, releaseAdvisoryLock, arg.LockID)
	var released bool
	err := row.Scan(&released)
	return released, err
}

const removeRuntimeState = `-- name: RemoveRuntimeState :execrows
DELETE FROM "runtime_state"
WHERE key = $1
`

type RemoveRuntimeStateParams struct {
	Key string `db:"key" json:"key"`
}

// RemoveRuntimeState
//
//	DELETE FROM "runtime_state"
//	WHERE key = $1
func (q *Queries) RemoveRuntimeState(ctx context.Context, arg RemoveRuntimeStateParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeRuntimeState, arg.Key)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const setRuntimeState = `-- name: SetRuntimeState :exec
INSERT INTO "runtime_state" (key, value, updated_at)
VALUES ($1, $2, NOW())
ON CONFLICT ("key") DO UPDATE SET value = $2, updated_at = NOW()
`

type SetRuntimeStateParams struct {
	Key   string `db:"key" json:"key"`
	Value string `db:"value" json:"value"`
}

// SetRuntimeState
//
//	INSERT INTO "runtime_state" (key, value, updated_at)
//	VALUES ($1, $2, NOW())
//	ON CONFLICT ("key") DO UPDATE SET value = $2, updated_at = NOW()
func (q *Queries) SetRuntimeState(ctx context.Context, arg SetRuntimeStateParams) error {
	_, err := q.db.ExecContext(ctx, setRuntimeState, arg.Key, arg.Value)
	return err
}

const tryAdvisoryLock = `-- name: TryAdvisoryLock :one
SELECT pg_try_advisory_lock($1::BIGINT) AS acquired
`

type TryAdvisoryLockParams struct {
	LockID int64 `db:"lock_id" json:"lock_id"`
}

// TryAdvisoryLock
//
//	SELECT pg_try_advisory_lock($1::BIGINT) AS acquired
func (q *Queries) TryAdvisoryLock(ctx context.Context, arg TryAdvisoryLockParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, tryAdvisoryLock, arg.LockID)
	var acquired bool
	err := row.Scan(&acquired)
	return acquired, err
}
