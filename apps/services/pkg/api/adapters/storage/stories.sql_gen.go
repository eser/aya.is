// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stories.sql

package storage

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const getStoryByID = `-- name: GetStoryByID :one
SELECT
  s.id, s.author_profile_id, s.slug, s.kind, s.status, s.is_featured, s.story_picture_uri, s.properties, s.created_at, s.updated_at, s.deleted_at, s.published_at,
  st.story_id, st.locale_code, st.title, st.summary, st.content, st.search_vector,
  p.id, p.slug, p.kind, p.custom_domain, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, p.approved_at,
  pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector,
  pb.publications
FROM "story" s
  INNER JOIN "story_tx" st ON st.story_id = s.id
  AND st.locale_code = $1
  LEFT JOIN "profile" p ON p.id = s.author_profile_id
  AND p.approved_at IS NOT NULL
  AND p.deleted_at IS NULL
  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
  AND pt.locale_code = $1
  LEFT JOIN LATERAL (
    SELECT JSONB_AGG(
      JSONB_BUILD_OBJECT('profile', row_to_json(p2), 'profile_tx', row_to_json(p2t))
    ) AS "publications"
    FROM story_publication sp
      INNER JOIN "profile" p2 ON p2.id = sp.profile_id
      AND p2.deleted_at IS NULL
      INNER JOIN "profile_tx" p2t ON p2t.profile_id = p2.id
      AND p2t.locale_code = $1
    WHERE sp.story_id = s.id
      AND ($2::CHAR(26) IS NULL OR sp.profile_id = $2::CHAR(26))
      AND sp.deleted_at IS NULL
  ) pb ON TRUE
WHERE s.id = $3
  AND ($4::CHAR(26) IS NULL OR s.author_profile_id = $4::CHAR(26))
  AND s.deleted_at IS NULL
LIMIT 1
`

type GetStoryByIDParams struct {
	LocaleCode                 string         `db:"locale_code" json:"locale_code"`
	FilterPublicationProfileID sql.NullString `db:"filter_publication_profile_id" json:"filter_publication_profile_id"`
	ID                         string         `db:"id" json:"id"`
	FilterAuthorProfileID      sql.NullString `db:"filter_author_profile_id" json:"filter_author_profile_id"`
}

type GetStoryByIDRow struct {
	Story        Story           `db:"story" json:"story"`
	StoryTx      StoryTx         `db:"story_tx" json:"story_tx"`
	Profile      Profile         `db:"profile" json:"profile"`
	ProfileTx    ProfileTx       `db:"profile_tx" json:"profile_tx"`
	Publications json.RawMessage `db:"publications" json:"publications"`
}

// GetStoryByID
//
//	SELECT
//	  s.id, s.author_profile_id, s.slug, s.kind, s.status, s.is_featured, s.story_picture_uri, s.properties, s.created_at, s.updated_at, s.deleted_at, s.published_at,
//	  st.story_id, st.locale_code, st.title, st.summary, st.content, st.search_vector,
//	  p.id, p.slug, p.kind, p.custom_domain, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, p.approved_at,
//	  pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector,
//	  pb.publications
//	FROM "story" s
//	  INNER JOIN "story_tx" st ON st.story_id = s.id
//	  AND st.locale_code = $1
//	  LEFT JOIN "profile" p ON p.id = s.author_profile_id
//	  AND p.approved_at IS NOT NULL
//	  AND p.deleted_at IS NULL
//	  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
//	  AND pt.locale_code = $1
//	  LEFT JOIN LATERAL (
//	    SELECT JSONB_AGG(
//	      JSONB_BUILD_OBJECT('profile', row_to_json(p2), 'profile_tx', row_to_json(p2t))
//	    ) AS "publications"
//	    FROM story_publication sp
//	      INNER JOIN "profile" p2 ON p2.id = sp.profile_id
//	      AND p2.deleted_at IS NULL
//	      INNER JOIN "profile_tx" p2t ON p2t.profile_id = p2.id
//	      AND p2t.locale_code = $1
//	    WHERE sp.story_id = s.id
//	      AND ($2::CHAR(26) IS NULL OR sp.profile_id = $2::CHAR(26))
//	      AND sp.deleted_at IS NULL
//	  ) pb ON TRUE
//	WHERE s.id = $3
//	  AND ($4::CHAR(26) IS NULL OR s.author_profile_id = $4::CHAR(26))
//	  AND s.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetStoryByID(ctx context.Context, arg GetStoryByIDParams) (*GetStoryByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getStoryByID,
		arg.LocaleCode,
		arg.FilterPublicationProfileID,
		arg.ID,
		arg.FilterAuthorProfileID,
	)
	var i GetStoryByIDRow
	err := row.Scan(
		&i.Story.ID,
		&i.Story.AuthorProfileID,
		&i.Story.Slug,
		&i.Story.Kind,
		&i.Story.Status,
		&i.Story.IsFeatured,
		&i.Story.StoryPictureURI,
		&i.Story.Properties,
		&i.Story.CreatedAt,
		&i.Story.UpdatedAt,
		&i.Story.DeletedAt,
		&i.Story.PublishedAt,
		&i.StoryTx.StoryID,
		&i.StoryTx.LocaleCode,
		&i.StoryTx.Title,
		&i.StoryTx.Summary,
		&i.StoryTx.Content,
		&i.StoryTx.SearchVector,
		&i.Profile.ID,
		&i.Profile.Slug,
		&i.Profile.Kind,
		&i.Profile.CustomDomain,
		&i.Profile.ProfilePictureURI,
		&i.Profile.Pronouns,
		&i.Profile.Properties,
		&i.Profile.CreatedAt,
		&i.Profile.UpdatedAt,
		&i.Profile.DeletedAt,
		&i.Profile.ApprovedAt,
		&i.ProfileTx.ProfileID,
		&i.ProfileTx.LocaleCode,
		&i.ProfileTx.Title,
		&i.ProfileTx.Description,
		&i.ProfileTx.Properties,
		&i.ProfileTx.SearchVector,
		&i.Publications,
	)
	return &i, err
}

const getStoryForEdit = `-- name: GetStoryForEdit :one
SELECT
  s.id, s.author_profile_id, s.slug, s.kind, s.status, s.is_featured, s.story_picture_uri, s.properties, s.created_at, s.updated_at, s.deleted_at, s.published_at,
  st.locale_code,
  st.title,
  st.summary,
  st.content
FROM "story" s
  INNER JOIN "story_tx" st ON st.story_id = s.id
  AND st.locale_code = $1
WHERE s.id = $2
  AND s.deleted_at IS NULL
LIMIT 1
`

type GetStoryForEditParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	ID         string `db:"id" json:"id"`
}

type GetStoryForEditRow struct {
	ID              string                `db:"id" json:"id"`
	AuthorProfileID sql.NullString        `db:"author_profile_id" json:"author_profile_id"`
	Slug            string                `db:"slug" json:"slug"`
	Kind            string                `db:"kind" json:"kind"`
	Status          string                `db:"status" json:"status"`
	IsFeatured      bool                  `db:"is_featured" json:"is_featured"`
	StoryPictureURI sql.NullString        `db:"story_picture_uri" json:"story_picture_uri"`
	Properties      pqtype.NullRawMessage `db:"properties" json:"properties"`
	CreatedAt       time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt       sql.NullTime          `db:"updated_at" json:"updated_at"`
	DeletedAt       sql.NullTime          `db:"deleted_at" json:"deleted_at"`
	PublishedAt     sql.NullTime          `db:"published_at" json:"published_at"`
	LocaleCode      string                `db:"locale_code" json:"locale_code"`
	Title           string                `db:"title" json:"title"`
	Summary         string                `db:"summary" json:"summary"`
	Content         string                `db:"content" json:"content"`
}

// GetStoryForEdit
//
//	SELECT
//	  s.id, s.author_profile_id, s.slug, s.kind, s.status, s.is_featured, s.story_picture_uri, s.properties, s.created_at, s.updated_at, s.deleted_at, s.published_at,
//	  st.locale_code,
//	  st.title,
//	  st.summary,
//	  st.content
//	FROM "story" s
//	  INNER JOIN "story_tx" st ON st.story_id = s.id
//	  AND st.locale_code = $1
//	WHERE s.id = $2
//	  AND s.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetStoryForEdit(ctx context.Context, arg GetStoryForEditParams) (*GetStoryForEditRow, error) {
	row := q.db.QueryRowContext(ctx, getStoryForEdit, arg.LocaleCode, arg.ID)
	var i GetStoryForEditRow
	err := row.Scan(
		&i.ID,
		&i.AuthorProfileID,
		&i.Slug,
		&i.Kind,
		&i.Status,
		&i.IsFeatured,
		&i.StoryPictureURI,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.PublishedAt,
		&i.LocaleCode,
		&i.Title,
		&i.Summary,
		&i.Content,
	)
	return &i, err
}

const getStoryIDBySlug = `-- name: GetStoryIDBySlug :one
SELECT id
FROM "story"
WHERE slug = $1
  AND deleted_at IS NULL
LIMIT 1
`

type GetStoryIDBySlugParams struct {
	Slug string `db:"slug" json:"slug"`
}

// GetStoryIDBySlug
//
//	SELECT id
//	FROM "story"
//	WHERE slug = $1
//	  AND deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetStoryIDBySlug(ctx context.Context, arg GetStoryIDBySlugParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getStoryIDBySlug, arg.Slug)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getStoryOwnershipForUser = `-- name: GetStoryOwnershipForUser :one
SELECT
  s.id,
  s.slug,
  s.author_profile_id,
  u.kind as user_kind,
  CASE
    WHEN u.kind = 'admin' THEN true
    WHEN s.author_profile_id = u.individual_profile_id THEN true
    WHEN pm.kind IN ('owner', 'lead', 'editor') THEN true
    ELSE false
  END as can_edit
FROM "story" s
LEFT JOIN "user" u ON u.id = $1
LEFT JOIN "profile_membership" pm ON s.author_profile_id = pm.profile_id
  AND pm.member_profile_id = u.individual_profile_id
  AND pm.deleted_at IS NULL
  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
WHERE s.id = $2
  AND s.deleted_at IS NULL
LIMIT 1
`

type GetStoryOwnershipForUserParams struct {
	UserID  string `db:"user_id" json:"user_id"`
	StoryID string `db:"story_id" json:"story_id"`
}

type GetStoryOwnershipForUserRow struct {
	ID              string         `db:"id" json:"id"`
	Slug            string         `db:"slug" json:"slug"`
	AuthorProfileID sql.NullString `db:"author_profile_id" json:"author_profile_id"`
	UserKind        sql.NullString `db:"user_kind" json:"user_kind"`
	CanEdit         bool           `db:"can_edit" json:"can_edit"`
}

// GetStoryOwnershipForUser
//
//	SELECT
//	  s.id,
//	  s.slug,
//	  s.author_profile_id,
//	  u.kind as user_kind,
//	  CASE
//	    WHEN u.kind = 'admin' THEN true
//	    WHEN s.author_profile_id = u.individual_profile_id THEN true
//	    WHEN pm.kind IN ('owner', 'lead', 'editor') THEN true
//	    ELSE false
//	  END as can_edit
//	FROM "story" s
//	LEFT JOIN "user" u ON u.id = $1
//	LEFT JOIN "profile_membership" pm ON s.author_profile_id = pm.profile_id
//	  AND pm.member_profile_id = u.individual_profile_id
//	  AND pm.deleted_at IS NULL
//	  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
//	WHERE s.id = $2
//	  AND s.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetStoryOwnershipForUser(ctx context.Context, arg GetStoryOwnershipForUserParams) (*GetStoryOwnershipForUserRow, error) {
	row := q.db.QueryRowContext(ctx, getStoryOwnershipForUser, arg.UserID, arg.StoryID)
	var i GetStoryOwnershipForUserRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.AuthorProfileID,
		&i.UserKind,
		&i.CanEdit,
	)
	return &i, err
}

const insertStory = `-- name: InsertStory :one

INSERT INTO "story" (
  id,
  author_profile_id,
  slug,
  kind,
  status,
  is_featured,
  story_picture_uri,
  properties,
  published_at,
  created_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  NOW()
) RETURNING id, author_profile_id, slug, kind, status, is_featured, story_picture_uri, properties, created_at, updated_at, deleted_at, published_at
`

type InsertStoryParams struct {
	ID              string                `db:"id" json:"id"`
	AuthorProfileID sql.NullString        `db:"author_profile_id" json:"author_profile_id"`
	Slug            string                `db:"slug" json:"slug"`
	Kind            string                `db:"kind" json:"kind"`
	Status          string                `db:"status" json:"status"`
	IsFeatured      bool                  `db:"is_featured" json:"is_featured"`
	StoryPictureURI sql.NullString        `db:"story_picture_uri" json:"story_picture_uri"`
	Properties      pqtype.NullRawMessage `db:"properties" json:"properties"`
	PublishedAt     sql.NullTime          `db:"published_at" json:"published_at"`
}

// -- name: ListStories :many
// SELECT sqlc.embed(s), sqlc.embed(st), sqlc.embed(p), sqlc.embed(pt)
// FROM "story" s
//
//	INNER JOIN "story_tx" st ON st.story_id = s.id
//	AND (sqlc.narg(filter_kind)::TEXT IS NULL OR s.kind = ANY(string_to_array(sqlc.narg(filter_kind)::TEXT, ',')))
//	AND (sqlc.narg(filter_author_profile_id)::CHAR(26) IS NULL OR s.author_profile_id = sqlc.narg(filter_author_profile_id)::CHAR(26))
//	AND st.locale_code = sqlc.arg(locale_code)
//	LEFT JOIN "profile" p ON p.id = s.author_profile_id AND p.deleted_at IS NULL
//	INNER JOIN "profile_tx" pt ON pt.profile_id = p.id AND pt.locale_code = sqlc.arg(locale_code)
//
// WHERE s.deleted_at IS NULL
// ORDER BY s.created_at DESC;
//
//	INSERT INTO "story" (
//	  id,
//	  author_profile_id,
//	  slug,
//	  kind,
//	  status,
//	  is_featured,
//	  story_picture_uri,
//	  properties,
//	  published_at,
//	  created_at
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5,
//	  $6,
//	  $7,
//	  $8,
//	  $9,
//	  NOW()
//	) RETURNING id, author_profile_id, slug, kind, status, is_featured, story_picture_uri, properties, created_at, updated_at, deleted_at, published_at
func (q *Queries) InsertStory(ctx context.Context, arg InsertStoryParams) (*Story, error) {
	row := q.db.QueryRowContext(ctx, insertStory,
		arg.ID,
		arg.AuthorProfileID,
		arg.Slug,
		arg.Kind,
		arg.Status,
		arg.IsFeatured,
		arg.StoryPictureURI,
		arg.Properties,
		arg.PublishedAt,
	)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.AuthorProfileID,
		&i.Slug,
		&i.Kind,
		&i.Status,
		&i.IsFeatured,
		&i.StoryPictureURI,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.PublishedAt,
	)
	return &i, err
}

const insertStoryPublication = `-- name: InsertStoryPublication :one
INSERT INTO "story_publication" (
  id,
  story_id,
  profile_id,
  kind,
  properties,
  created_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  NOW()
) RETURNING id, story_id, profile_id, kind, properties, created_at, updated_at, deleted_at
`

type InsertStoryPublicationParams struct {
	ID         string                `db:"id" json:"id"`
	StoryID    string                `db:"story_id" json:"story_id"`
	ProfileID  string                `db:"profile_id" json:"profile_id"`
	Kind       string                `db:"kind" json:"kind"`
	Properties pqtype.NullRawMessage `db:"properties" json:"properties"`
}

// InsertStoryPublication
//
//	INSERT INTO "story_publication" (
//	  id,
//	  story_id,
//	  profile_id,
//	  kind,
//	  properties,
//	  created_at
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5,
//	  NOW()
//	) RETURNING id, story_id, profile_id, kind, properties, created_at, updated_at, deleted_at
func (q *Queries) InsertStoryPublication(ctx context.Context, arg InsertStoryPublicationParams) (*StoryPublication, error) {
	row := q.db.QueryRowContext(ctx, insertStoryPublication,
		arg.ID,
		arg.StoryID,
		arg.ProfileID,
		arg.Kind,
		arg.Properties,
	)
	var i StoryPublication
	err := row.Scan(
		&i.ID,
		&i.StoryID,
		&i.ProfileID,
		&i.Kind,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const insertStoryTx = `-- name: InsertStoryTx :exec
INSERT INTO "story_tx" (
  story_id,
  locale_code,
  title,
  summary,
  content
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
`

type InsertStoryTxParams struct {
	StoryID    string `db:"story_id" json:"story_id"`
	LocaleCode string `db:"locale_code" json:"locale_code"`
	Title      string `db:"title" json:"title"`
	Summary    string `db:"summary" json:"summary"`
	Content    string `db:"content" json:"content"`
}

// InsertStoryTx
//
//	INSERT INTO "story_tx" (
//	  story_id,
//	  locale_code,
//	  title,
//	  summary,
//	  content
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5
//	)
func (q *Queries) InsertStoryTx(ctx context.Context, arg InsertStoryTxParams) error {
	_, err := q.db.ExecContext(ctx, insertStoryTx,
		arg.StoryID,
		arg.LocaleCode,
		arg.Title,
		arg.Summary,
		arg.Content,
	)
	return err
}

const listStoriesOfPublication = `-- name: ListStoriesOfPublication :many
SELECT
  s.id, s.author_profile_id, s.slug, s.kind, s.status, s.is_featured, s.story_picture_uri, s.properties, s.created_at, s.updated_at, s.deleted_at, s.published_at,
  st.story_id, st.locale_code, st.title, st.summary, st.content, st.search_vector,
  p1.id, p1.slug, p1.kind, p1.custom_domain, p1.profile_picture_uri, p1.pronouns, p1.properties, p1.created_at, p1.updated_at, p1.deleted_at, p1.approved_at,
  p1t.profile_id, p1t.locale_code, p1t.title, p1t.description, p1t.properties, p1t.search_vector,
  pb.publications
FROM "story" s
  INNER JOIN "story_tx" st ON st.story_id = s.id
  AND st.locale_code = $1
  LEFT JOIN "profile" p1 ON p1.id = s.author_profile_id
  AND p1.approved_at IS NOT NULL
  AND p1.deleted_at IS NULL
  INNER JOIN "profile_tx" p1t ON p1t.profile_id = p1.id
  AND p1t.locale_code = $1
  LEFT JOIN LATERAL (
    SELECT JSONB_AGG(
      JSONB_BUILD_OBJECT('profile', row_to_json(p2), 'profile_tx', row_to_json(p2t))
    ) AS "publications"
    FROM story_publication sp
      INNER JOIN "profile" p2 ON p2.id = sp.profile_id
      AND p2.approved_at IS NOT NULL
      AND p2.deleted_at IS NULL
      INNER JOIN "profile_tx" p2t ON p2t.profile_id = p2.id
      AND p2t.locale_code = $1
    WHERE sp.story_id = s.id
      AND ($2::CHAR(26) IS NULL OR sp.profile_id = $2::CHAR(26))
      AND sp.deleted_at IS NULL
  ) pb ON TRUE
WHERE
  pb.publications IS NOT NULL
  AND ($3::TEXT IS NULL OR s.kind = ANY(string_to_array($3::TEXT, ',')))
  AND ($4::CHAR(26) IS NULL OR s.author_profile_id = $4::CHAR(26))
  AND s.deleted_at IS NULL
ORDER BY s.created_at DESC
`

type ListStoriesOfPublicationParams struct {
	LocaleCode                 string         `db:"locale_code" json:"locale_code"`
	FilterPublicationProfileID sql.NullString `db:"filter_publication_profile_id" json:"filter_publication_profile_id"`
	FilterKind                 sql.NullString `db:"filter_kind" json:"filter_kind"`
	FilterAuthorProfileID      sql.NullString `db:"filter_author_profile_id" json:"filter_author_profile_id"`
}

type ListStoriesOfPublicationRow struct {
	Story        Story           `db:"story" json:"story"`
	StoryTx      StoryTx         `db:"story_tx" json:"story_tx"`
	Profile      Profile         `db:"profile" json:"profile"`
	ProfileTx    ProfileTx       `db:"profile_tx" json:"profile_tx"`
	Publications json.RawMessage `db:"publications" json:"publications"`
}

// ListStoriesOfPublication
//
//	SELECT
//	  s.id, s.author_profile_id, s.slug, s.kind, s.status, s.is_featured, s.story_picture_uri, s.properties, s.created_at, s.updated_at, s.deleted_at, s.published_at,
//	  st.story_id, st.locale_code, st.title, st.summary, st.content, st.search_vector,
//	  p1.id, p1.slug, p1.kind, p1.custom_domain, p1.profile_picture_uri, p1.pronouns, p1.properties, p1.created_at, p1.updated_at, p1.deleted_at, p1.approved_at,
//	  p1t.profile_id, p1t.locale_code, p1t.title, p1t.description, p1t.properties, p1t.search_vector,
//	  pb.publications
//	FROM "story" s
//	  INNER JOIN "story_tx" st ON st.story_id = s.id
//	  AND st.locale_code = $1
//	  LEFT JOIN "profile" p1 ON p1.id = s.author_profile_id
//	  AND p1.approved_at IS NOT NULL
//	  AND p1.deleted_at IS NULL
//	  INNER JOIN "profile_tx" p1t ON p1t.profile_id = p1.id
//	  AND p1t.locale_code = $1
//	  LEFT JOIN LATERAL (
//	    SELECT JSONB_AGG(
//	      JSONB_BUILD_OBJECT('profile', row_to_json(p2), 'profile_tx', row_to_json(p2t))
//	    ) AS "publications"
//	    FROM story_publication sp
//	      INNER JOIN "profile" p2 ON p2.id = sp.profile_id
//	      AND p2.approved_at IS NOT NULL
//	      AND p2.deleted_at IS NULL
//	      INNER JOIN "profile_tx" p2t ON p2t.profile_id = p2.id
//	      AND p2t.locale_code = $1
//	    WHERE sp.story_id = s.id
//	      AND ($2::CHAR(26) IS NULL OR sp.profile_id = $2::CHAR(26))
//	      AND sp.deleted_at IS NULL
//	  ) pb ON TRUE
//	WHERE
//	  pb.publications IS NOT NULL
//	  AND ($3::TEXT IS NULL OR s.kind = ANY(string_to_array($3::TEXT, ',')))
//	  AND ($4::CHAR(26) IS NULL OR s.author_profile_id = $4::CHAR(26))
//	  AND s.deleted_at IS NULL
//	ORDER BY s.created_at DESC
func (q *Queries) ListStoriesOfPublication(ctx context.Context, arg ListStoriesOfPublicationParams) ([]*ListStoriesOfPublicationRow, error) {
	rows, err := q.db.QueryContext(ctx, listStoriesOfPublication,
		arg.LocaleCode,
		arg.FilterPublicationProfileID,
		arg.FilterKind,
		arg.FilterAuthorProfileID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListStoriesOfPublicationRow{}
	for rows.Next() {
		var i ListStoriesOfPublicationRow
		if err := rows.Scan(
			&i.Story.ID,
			&i.Story.AuthorProfileID,
			&i.Story.Slug,
			&i.Story.Kind,
			&i.Story.Status,
			&i.Story.IsFeatured,
			&i.Story.StoryPictureURI,
			&i.Story.Properties,
			&i.Story.CreatedAt,
			&i.Story.UpdatedAt,
			&i.Story.DeletedAt,
			&i.Story.PublishedAt,
			&i.StoryTx.StoryID,
			&i.StoryTx.LocaleCode,
			&i.StoryTx.Title,
			&i.StoryTx.Summary,
			&i.StoryTx.Content,
			&i.StoryTx.SearchVector,
			&i.Profile.ID,
			&i.Profile.Slug,
			&i.Profile.Kind,
			&i.Profile.CustomDomain,
			&i.Profile.ProfilePictureURI,
			&i.Profile.Pronouns,
			&i.Profile.Properties,
			&i.Profile.CreatedAt,
			&i.Profile.UpdatedAt,
			&i.Profile.DeletedAt,
			&i.Profile.ApprovedAt,
			&i.ProfileTx.ProfileID,
			&i.ProfileTx.LocaleCode,
			&i.ProfileTx.Title,
			&i.ProfileTx.Description,
			&i.ProfileTx.Properties,
			&i.ProfileTx.SearchVector,
			&i.Publications,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeStory = `-- name: RemoveStory :execrows
UPDATE "story"
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type RemoveStoryParams struct {
	ID string `db:"id" json:"id"`
}

// RemoveStory
//
//	UPDATE "story"
//	SET deleted_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) RemoveStory(ctx context.Context, arg RemoveStoryParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeStory, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const searchStories = `-- name: SearchStories :many
SELECT
  s.id,
  s.slug,
  s.kind,
  s.story_picture_uri,
  s.author_profile_id,
  st.title,
  st.summary,
  p.slug as author_slug,
  pt.title as author_title,
  ts_rank(st.search_vector, plainto_tsquery(locale_to_regconfig($1), $2)) as rank
FROM "story" s
  INNER JOIN "story_tx" st ON st.story_id = s.id
    AND st.locale_code = $1
  LEFT JOIN "profile" p ON p.id = s.author_profile_id AND p.deleted_at IS NULL
  LEFT JOIN "profile_tx" pt ON pt.profile_id = p.id
    AND pt.locale_code = $1
WHERE st.search_vector @@ plainto_tsquery(locale_to_regconfig($1), $2)
  AND s.deleted_at IS NULL
  AND s.status = 'published'
  AND ($3::TEXT IS NULL OR p.slug = $3::TEXT)
ORDER BY rank DESC
LIMIT $4
`

type SearchStoriesParams struct {
	LocaleCode        string         `db:"locale_code" json:"locale_code"`
	Query             string         `db:"query" json:"query"`
	FilterProfileSlug sql.NullString `db:"filter_profile_slug" json:"filter_profile_slug"`
	LimitCount        int32          `db:"limit_count" json:"limit_count"`
}

type SearchStoriesRow struct {
	ID              string         `db:"id" json:"id"`
	Slug            string         `db:"slug" json:"slug"`
	Kind            string         `db:"kind" json:"kind"`
	StoryPictureURI sql.NullString `db:"story_picture_uri" json:"story_picture_uri"`
	AuthorProfileID sql.NullString `db:"author_profile_id" json:"author_profile_id"`
	Title           string         `db:"title" json:"title"`
	Summary         string         `db:"summary" json:"summary"`
	AuthorSlug      sql.NullString `db:"author_slug" json:"author_slug"`
	AuthorTitle     sql.NullString `db:"author_title" json:"author_title"`
	Rank            float32        `db:"rank" json:"rank"`
}

// SearchStories
//
//	SELECT
//	  s.id,
//	  s.slug,
//	  s.kind,
//	  s.story_picture_uri,
//	  s.author_profile_id,
//	  st.title,
//	  st.summary,
//	  p.slug as author_slug,
//	  pt.title as author_title,
//	  ts_rank(st.search_vector, plainto_tsquery(locale_to_regconfig($1), $2)) as rank
//	FROM "story" s
//	  INNER JOIN "story_tx" st ON st.story_id = s.id
//	    AND st.locale_code = $1
//	  LEFT JOIN "profile" p ON p.id = s.author_profile_id AND p.deleted_at IS NULL
//	  LEFT JOIN "profile_tx" pt ON pt.profile_id = p.id
//	    AND pt.locale_code = $1
//	WHERE st.search_vector @@ plainto_tsquery(locale_to_regconfig($1), $2)
//	  AND s.deleted_at IS NULL
//	  AND s.status = 'published'
//	  AND ($3::TEXT IS NULL OR p.slug = $3::TEXT)
//	ORDER BY rank DESC
//	LIMIT $4
func (q *Queries) SearchStories(ctx context.Context, arg SearchStoriesParams) ([]*SearchStoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchStories,
		arg.LocaleCode,
		arg.Query,
		arg.FilterProfileSlug,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchStoriesRow{}
	for rows.Next() {
		var i SearchStoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Kind,
			&i.StoryPictureURI,
			&i.AuthorProfileID,
			&i.Title,
			&i.Summary,
			&i.AuthorSlug,
			&i.AuthorTitle,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStory = `-- name: UpdateStory :execrows
UPDATE "story"
SET
  slug = $1,
  status = $2,
  is_featured = $3,
  story_picture_uri = $4,
  published_at = $5,
  updated_at = NOW()
WHERE id = $6
  AND deleted_at IS NULL
`

type UpdateStoryParams struct {
	Slug            string         `db:"slug" json:"slug"`
	Status          string         `db:"status" json:"status"`
	IsFeatured      bool           `db:"is_featured" json:"is_featured"`
	StoryPictureURI sql.NullString `db:"story_picture_uri" json:"story_picture_uri"`
	PublishedAt     sql.NullTime   `db:"published_at" json:"published_at"`
	ID              string         `db:"id" json:"id"`
}

// UpdateStory
//
//	UPDATE "story"
//	SET
//	  slug = $1,
//	  status = $2,
//	  is_featured = $3,
//	  story_picture_uri = $4,
//	  published_at = $5,
//	  updated_at = NOW()
//	WHERE id = $6
//	  AND deleted_at IS NULL
func (q *Queries) UpdateStory(ctx context.Context, arg UpdateStoryParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateStory,
		arg.Slug,
		arg.Status,
		arg.IsFeatured,
		arg.StoryPictureURI,
		arg.PublishedAt,
		arg.ID,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateStoryTx = `-- name: UpdateStoryTx :execrows
UPDATE "story_tx"
SET
  title = $1,
  summary = $2,
  content = $3
WHERE story_id = $4
  AND locale_code = $5
`

type UpdateStoryTxParams struct {
	Title      string `db:"title" json:"title"`
	Summary    string `db:"summary" json:"summary"`
	Content    string `db:"content" json:"content"`
	StoryID    string `db:"story_id" json:"story_id"`
	LocaleCode string `db:"locale_code" json:"locale_code"`
}

// UpdateStoryTx
//
//	UPDATE "story_tx"
//	SET
//	  title = $1,
//	  summary = $2,
//	  content = $3
//	WHERE story_id = $4
//	  AND locale_code = $5
func (q *Queries) UpdateStoryTx(ctx context.Context, arg UpdateStoryTxParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateStoryTx,
		arg.Title,
		arg.Summary,
		arg.Content,
		arg.StoryID,
		arg.LocaleCode,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const upsertStoryTx = `-- name: UpsertStoryTx :exec
INSERT INTO "story_tx" (
  story_id,
  locale_code,
  title,
  summary,
  content
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
) ON CONFLICT (story_id, locale_code) DO UPDATE SET
  title = EXCLUDED.title,
  summary = EXCLUDED.summary,
  content = EXCLUDED.content
`

type UpsertStoryTxParams struct {
	StoryID    string `db:"story_id" json:"story_id"`
	LocaleCode string `db:"locale_code" json:"locale_code"`
	Title      string `db:"title" json:"title"`
	Summary    string `db:"summary" json:"summary"`
	Content    string `db:"content" json:"content"`
}

// UpsertStoryTx
//
//	INSERT INTO "story_tx" (
//	  story_id,
//	  locale_code,
//	  title,
//	  summary,
//	  content
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5
//	) ON CONFLICT (story_id, locale_code) DO UPDATE SET
//	  title = EXCLUDED.title,
//	  summary = EXCLUDED.summary,
//	  content = EXCLUDED.content
func (q *Queries) UpsertStoryTx(ctx context.Context, arg UpsertStoryTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertStoryTx,
		arg.StoryID,
		arg.LocaleCode,
		arg.Title,
		arg.Summary,
		arg.Content,
	)
	return err
}
