// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: stories.sql

package storage

import (
	"context"
	"database/sql"
	"time"

	"github.com/sqlc-dev/pqtype"
)

const countStoryPublications = `-- name: CountStoryPublications :one
SELECT COUNT(*) as count
FROM story_publication
WHERE story_id = $1
  AND deleted_at IS NULL
`

type CountStoryPublicationsParams struct {
	StoryID string `db:"story_id" json:"story_id"`
}

// CountStoryPublications
//
//	SELECT COUNT(*) as count
//	FROM story_publication
//	WHERE story_id = $1
//	  AND deleted_at IS NULL
func (q *Queries) CountStoryPublications(ctx context.Context, arg CountStoryPublicationsParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countStoryPublications, arg.StoryID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getStoryByID = `-- name: GetStoryByID :one
SELECT
  s.id, s.author_profile_id, s.slug, s.kind, s.story_picture_uri, s.properties, s.created_at, s.updated_at, s.deleted_at,
  st.story_id, st.locale_code, st.title, st.summary, st.content, st.search_vector,
  p.id, p.slug, p.kind, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, p.approved_at, p.points, p.hide_relations, p.hide_links,
  pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector,
  pb.publications
FROM "story" s
  INNER JOIN "story_tx" st ON st.story_id = s.id
  AND st.locale_code = $1
  LEFT JOIN "profile" p ON p.id = s.author_profile_id
  AND p.approved_at IS NOT NULL
  AND p.deleted_at IS NULL
  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
  AND pt.locale_code = $1
  LEFT JOIN LATERAL (
    SELECT JSONB_AGG(
      JSONB_BUILD_OBJECT('profile', row_to_json(p2), 'profile_tx', row_to_json(p2t))
    ) AS "publications"
    FROM story_publication sp
      INNER JOIN "profile" p2 ON p2.id = sp.profile_id
      AND p2.deleted_at IS NULL
      INNER JOIN "profile_tx" p2t ON p2t.profile_id = p2.id
      AND p2t.locale_code = $1
    WHERE sp.story_id = s.id
      AND ($2::CHAR(26) IS NULL OR sp.profile_id = $2::CHAR(26))
      AND sp.deleted_at IS NULL
  ) pb ON TRUE
WHERE s.id = $3
  AND ($4::CHAR(26) IS NULL OR s.author_profile_id = $4::CHAR(26))
  AND s.deleted_at IS NULL
LIMIT 1
`

type GetStoryByIDParams struct {
	LocaleCode                 string         `db:"locale_code" json:"locale_code"`
	FilterPublicationProfileID sql.NullString `db:"filter_publication_profile_id" json:"filter_publication_profile_id"`
	ID                         string         `db:"id" json:"id"`
	FilterAuthorProfileID      sql.NullString `db:"filter_author_profile_id" json:"filter_author_profile_id"`
}

type GetStoryByIDRow struct {
	Story        Story                 `db:"story" json:"story"`
	StoryTx      StoryTx               `db:"story_tx" json:"story_tx"`
	Profile      Profile               `db:"profile" json:"profile"`
	ProfileTx    ProfileTx             `db:"profile_tx" json:"profile_tx"`
	Publications pqtype.NullRawMessage `db:"publications" json:"publications"`
}

// GetStoryByID
//
//	SELECT
//	  s.id, s.author_profile_id, s.slug, s.kind, s.story_picture_uri, s.properties, s.created_at, s.updated_at, s.deleted_at,
//	  st.story_id, st.locale_code, st.title, st.summary, st.content, st.search_vector,
//	  p.id, p.slug, p.kind, p.profile_picture_uri, p.pronouns, p.properties, p.created_at, p.updated_at, p.deleted_at, p.approved_at, p.points, p.hide_relations, p.hide_links,
//	  pt.profile_id, pt.locale_code, pt.title, pt.description, pt.properties, pt.search_vector,
//	  pb.publications
//	FROM "story" s
//	  INNER JOIN "story_tx" st ON st.story_id = s.id
//	  AND st.locale_code = $1
//	  LEFT JOIN "profile" p ON p.id = s.author_profile_id
//	  AND p.approved_at IS NOT NULL
//	  AND p.deleted_at IS NULL
//	  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id
//	  AND pt.locale_code = $1
//	  LEFT JOIN LATERAL (
//	    SELECT JSONB_AGG(
//	      JSONB_BUILD_OBJECT('profile', row_to_json(p2), 'profile_tx', row_to_json(p2t))
//	    ) AS "publications"
//	    FROM story_publication sp
//	      INNER JOIN "profile" p2 ON p2.id = sp.profile_id
//	      AND p2.deleted_at IS NULL
//	      INNER JOIN "profile_tx" p2t ON p2t.profile_id = p2.id
//	      AND p2t.locale_code = $1
//	    WHERE sp.story_id = s.id
//	      AND ($2::CHAR(26) IS NULL OR sp.profile_id = $2::CHAR(26))
//	      AND sp.deleted_at IS NULL
//	  ) pb ON TRUE
//	WHERE s.id = $3
//	  AND ($4::CHAR(26) IS NULL OR s.author_profile_id = $4::CHAR(26))
//	  AND s.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetStoryByID(ctx context.Context, arg GetStoryByIDParams) (*GetStoryByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getStoryByID,
		arg.LocaleCode,
		arg.FilterPublicationProfileID,
		arg.ID,
		arg.FilterAuthorProfileID,
	)
	var i GetStoryByIDRow
	err := row.Scan(
		&i.Story.ID,
		&i.Story.AuthorProfileID,
		&i.Story.Slug,
		&i.Story.Kind,
		&i.Story.StoryPictureURI,
		&i.Story.Properties,
		&i.Story.CreatedAt,
		&i.Story.UpdatedAt,
		&i.Story.DeletedAt,
		&i.StoryTx.StoryID,
		&i.StoryTx.LocaleCode,
		&i.StoryTx.Title,
		&i.StoryTx.Summary,
		&i.StoryTx.Content,
		&i.StoryTx.SearchVector,
		&i.Profile.ID,
		&i.Profile.Slug,
		&i.Profile.Kind,
		&i.Profile.ProfilePictureURI,
		&i.Profile.Pronouns,
		&i.Profile.Properties,
		&i.Profile.CreatedAt,
		&i.Profile.UpdatedAt,
		&i.Profile.DeletedAt,
		&i.Profile.ApprovedAt,
		&i.Profile.Points,
		&i.Profile.HideRelations,
		&i.Profile.HideLinks,
		&i.ProfileTx.ProfileID,
		&i.ProfileTx.LocaleCode,
		&i.ProfileTx.Title,
		&i.ProfileTx.Description,
		&i.ProfileTx.Properties,
		&i.ProfileTx.SearchVector,
		&i.Publications,
	)
	return &i, err
}

const getStoryFirstPublishedAt = `-- name: GetStoryFirstPublishedAt :one
SELECT MIN(published_at) as first_published_at
FROM story_publication
WHERE story_id = $1
  AND deleted_at IS NULL
  AND published_at IS NOT NULL
`

type GetStoryFirstPublishedAtParams struct {
	StoryID string `db:"story_id" json:"story_id"`
}

// GetStoryFirstPublishedAt
//
//	SELECT MIN(published_at) as first_published_at
//	FROM story_publication
//	WHERE story_id = $1
//	  AND deleted_at IS NULL
//	  AND published_at IS NOT NULL
func (q *Queries) GetStoryFirstPublishedAt(ctx context.Context, arg GetStoryFirstPublishedAtParams) (interface{}, error) {
	row := q.db.QueryRowContext(ctx, getStoryFirstPublishedAt, arg.StoryID)
	var first_published_at interface{}
	err := row.Scan(&first_published_at)
	return first_published_at, err
}

const getStoryForEdit = `-- name: GetStoryForEdit :one
SELECT
  s.id, s.author_profile_id, s.slug, s.kind, s.story_picture_uri, s.properties, s.created_at, s.updated_at, s.deleted_at,
  st.locale_code,
  st.title,
  st.summary,
  st.content,
  p.slug as author_profile_slug
FROM "story" s
  INNER JOIN "story_tx" st ON st.story_id = s.id
  AND st.locale_code = (
    SELECT stx.locale_code FROM "story_tx" stx
    WHERE stx.story_id = s.id
    ORDER BY CASE WHEN stx.locale_code = $1 THEN 0 ELSE 1 END
    LIMIT 1
  )
  LEFT JOIN "profile" p ON p.id = s.author_profile_id AND p.deleted_at IS NULL
WHERE s.id = $2
  AND s.deleted_at IS NULL
LIMIT 1
`

type GetStoryForEditParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	ID         string `db:"id" json:"id"`
}

type GetStoryForEditRow struct {
	ID                string                `db:"id" json:"id"`
	AuthorProfileID   sql.NullString        `db:"author_profile_id" json:"author_profile_id"`
	Slug              string                `db:"slug" json:"slug"`
	Kind              string                `db:"kind" json:"kind"`
	StoryPictureURI   sql.NullString        `db:"story_picture_uri" json:"story_picture_uri"`
	Properties        pqtype.NullRawMessage `db:"properties" json:"properties"`
	CreatedAt         time.Time             `db:"created_at" json:"created_at"`
	UpdatedAt         sql.NullTime          `db:"updated_at" json:"updated_at"`
	DeletedAt         sql.NullTime          `db:"deleted_at" json:"deleted_at"`
	LocaleCode        string                `db:"locale_code" json:"locale_code"`
	Title             string                `db:"title" json:"title"`
	Summary           string                `db:"summary" json:"summary"`
	Content           string                `db:"content" json:"content"`
	AuthorProfileSlug sql.NullString        `db:"author_profile_slug" json:"author_profile_slug"`
}

// Uses locale fallback: prefers the requested locale, falls back to any translation.
// The returned locale_code indicates which translation was actually found.
//
//	SELECT
//	  s.id, s.author_profile_id, s.slug, s.kind, s.story_picture_uri, s.properties, s.created_at, s.updated_at, s.deleted_at,
//	  st.locale_code,
//	  st.title,
//	  st.summary,
//	  st.content,
//	  p.slug as author_profile_slug
//	FROM "story" s
//	  INNER JOIN "story_tx" st ON st.story_id = s.id
//	  AND st.locale_code = (
//	    SELECT stx.locale_code FROM "story_tx" stx
//	    WHERE stx.story_id = s.id
//	    ORDER BY CASE WHEN stx.locale_code = $1 THEN 0 ELSE 1 END
//	    LIMIT 1
//	  )
//	  LEFT JOIN "profile" p ON p.id = s.author_profile_id AND p.deleted_at IS NULL
//	WHERE s.id = $2
//	  AND s.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetStoryForEdit(ctx context.Context, arg GetStoryForEditParams) (*GetStoryForEditRow, error) {
	row := q.db.QueryRowContext(ctx, getStoryForEdit, arg.LocaleCode, arg.ID)
	var i GetStoryForEditRow
	err := row.Scan(
		&i.ID,
		&i.AuthorProfileID,
		&i.Slug,
		&i.Kind,
		&i.StoryPictureURI,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.LocaleCode,
		&i.Title,
		&i.Summary,
		&i.Content,
		&i.AuthorProfileSlug,
	)
	return &i, err
}

const getStoryIDBySlug = `-- name: GetStoryIDBySlug :one
SELECT s.id
FROM "story" s
WHERE s.slug = $1
  AND s.deleted_at IS NULL
  AND EXISTS (
    SELECT 1 FROM story_publication sp
    WHERE sp.story_id = s.id AND sp.deleted_at IS NULL
  )
LIMIT 1
`

type GetStoryIDBySlugParams struct {
	Slug string `db:"slug" json:"slug"`
}

// GetStoryIDBySlug
//
//	SELECT s.id
//	FROM "story" s
//	WHERE s.slug = $1
//	  AND s.deleted_at IS NULL
//	  AND EXISTS (
//	    SELECT 1 FROM story_publication sp
//	    WHERE sp.story_id = s.id AND sp.deleted_at IS NULL
//	  )
//	LIMIT 1
func (q *Queries) GetStoryIDBySlug(ctx context.Context, arg GetStoryIDBySlugParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getStoryIDBySlug, arg.Slug)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getStoryIDBySlugForViewer = `-- name: GetStoryIDBySlugForViewer :one
SELECT s.id
FROM "story" s
LEFT JOIN "user" u ON u.id = $1::CHAR(26)
LEFT JOIN "profile_membership" pm ON s.author_profile_id = pm.profile_id
  AND pm.member_profile_id = u.individual_profile_id
  AND pm.deleted_at IS NULL
  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
WHERE s.slug = $2
  AND s.deleted_at IS NULL
  AND (
    EXISTS (SELECT 1 FROM story_publication sp WHERE sp.story_id = s.id AND sp.deleted_at IS NULL)
    OR u.kind = 'admin'
    OR s.author_profile_id = u.individual_profile_id
    OR pm.kind IN ('owner', 'lead', 'maintainer')
  )
LIMIT 1
`

type GetStoryIDBySlugForViewerParams struct {
	ViewerUserID sql.NullString `db:"viewer_user_id" json:"viewer_user_id"`
	Slug         string         `db:"slug" json:"slug"`
}

// Returns story ID if:
//
//  1. Story has at least one active publication, OR
//
//  2. Viewer is admin, OR
//
//  3. Viewer is the author (individual profile owner)
//
//  4. Viewer is owner/lead/maintainer of the author profile
//
//     SELECT s.id
//     FROM "story" s
//     LEFT JOIN "user" u ON u.id = $1::CHAR(26)
//     LEFT JOIN "profile_membership" pm ON s.author_profile_id = pm.profile_id
//     AND pm.member_profile_id = u.individual_profile_id
//     AND pm.deleted_at IS NULL
//     AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
//     WHERE s.slug = $2
//     AND s.deleted_at IS NULL
//     AND (
//     EXISTS (SELECT 1 FROM story_publication sp WHERE sp.story_id = s.id AND sp.deleted_at IS NULL)
//     OR u.kind = 'admin'
//     OR s.author_profile_id = u.individual_profile_id
//     OR pm.kind IN ('owner', 'lead', 'maintainer')
//     )
//     LIMIT 1
func (q *Queries) GetStoryIDBySlugForViewer(ctx context.Context, arg GetStoryIDBySlugForViewerParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getStoryIDBySlugForViewer, arg.ViewerUserID, arg.Slug)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getStoryIDBySlugIncludingDeleted = `-- name: GetStoryIDBySlugIncludingDeleted :one
SELECT id
FROM "story"
WHERE slug = $1
LIMIT 1
`

type GetStoryIDBySlugIncludingDeletedParams struct {
	Slug string `db:"slug" json:"slug"`
}

// GetStoryIDBySlugIncludingDeleted
//
//	SELECT id
//	FROM "story"
//	WHERE slug = $1
//	LIMIT 1
func (q *Queries) GetStoryIDBySlugIncludingDeleted(ctx context.Context, arg GetStoryIDBySlugIncludingDeletedParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getStoryIDBySlugIncludingDeleted, arg.Slug)
	var id string
	err := row.Scan(&id)
	return id, err
}

const getStoryOwnershipForUser = `-- name: GetStoryOwnershipForUser :one
SELECT
  s.id,
  s.slug,
  s.author_profile_id,
  u.kind as user_kind,
  CASE
    WHEN u.kind = 'admin' THEN true
    WHEN s.author_profile_id = u.individual_profile_id THEN true
    WHEN pm.kind IN ('owner', 'lead', 'maintainer') THEN true
    ELSE false
  END as can_edit
FROM "story" s
LEFT JOIN "user" u ON u.id = $1
LEFT JOIN "profile_membership" pm ON s.author_profile_id = pm.profile_id
  AND pm.member_profile_id = u.individual_profile_id
  AND pm.deleted_at IS NULL
  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
WHERE s.id = $2
  AND s.deleted_at IS NULL
LIMIT 1
`

type GetStoryOwnershipForUserParams struct {
	UserID  string `db:"user_id" json:"user_id"`
	StoryID string `db:"story_id" json:"story_id"`
}

type GetStoryOwnershipForUserRow struct {
	ID              string         `db:"id" json:"id"`
	Slug            string         `db:"slug" json:"slug"`
	AuthorProfileID sql.NullString `db:"author_profile_id" json:"author_profile_id"`
	UserKind        sql.NullString `db:"user_kind" json:"user_kind"`
	CanEdit         bool           `db:"can_edit" json:"can_edit"`
}

// GetStoryOwnershipForUser
//
//	SELECT
//	  s.id,
//	  s.slug,
//	  s.author_profile_id,
//	  u.kind as user_kind,
//	  CASE
//	    WHEN u.kind = 'admin' THEN true
//	    WHEN s.author_profile_id = u.individual_profile_id THEN true
//	    WHEN pm.kind IN ('owner', 'lead', 'maintainer') THEN true
//	    ELSE false
//	  END as can_edit
//	FROM "story" s
//	LEFT JOIN "user" u ON u.id = $1
//	LEFT JOIN "profile_membership" pm ON s.author_profile_id = pm.profile_id
//	  AND pm.member_profile_id = u.individual_profile_id
//	  AND pm.deleted_at IS NULL
//	  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
//	WHERE s.id = $2
//	  AND s.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetStoryOwnershipForUser(ctx context.Context, arg GetStoryOwnershipForUserParams) (*GetStoryOwnershipForUserRow, error) {
	row := q.db.QueryRowContext(ctx, getStoryOwnershipForUser, arg.UserID, arg.StoryID)
	var i GetStoryOwnershipForUserRow
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.AuthorProfileID,
		&i.UserKind,
		&i.CanEdit,
	)
	return &i, err
}

const getStoryPublicationProfileID = `-- name: GetStoryPublicationProfileID :one
SELECT profile_id
FROM story_publication
WHERE id = $1
  AND deleted_at IS NULL
LIMIT 1
`

type GetStoryPublicationProfileIDParams struct {
	ID string `db:"id" json:"id"`
}

// Returns the profile_id for a specific publication (used for auth checks).
//
//	SELECT profile_id
//	FROM story_publication
//	WHERE id = $1
//	  AND deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetStoryPublicationProfileID(ctx context.Context, arg GetStoryPublicationProfileIDParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getStoryPublicationProfileID, arg.ID)
	var profile_id string
	err := row.Scan(&profile_id)
	return profile_id, err
}

const getUserMembershipForProfile = `-- name: GetUserMembershipForProfile :one
SELECT
  CAST(CASE
    WHEN u.kind = 'admin' THEN 'admin'
    WHEN u.individual_profile_id = $1::CHAR(26) THEN 'owner'
    ELSE COALESCE(pm.kind, '')
  END AS TEXT) as membership_kind
FROM "user" u
LEFT JOIN "profile_membership" pm ON pm.profile_id = $1::CHAR(26)
  AND pm.member_profile_id = u.individual_profile_id
  AND pm.deleted_at IS NULL
  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
WHERE u.id = $2
  AND u.deleted_at IS NULL
LIMIT 1
`

type GetUserMembershipForProfileParams struct {
	ProfileID string `db:"profile_id" json:"profile_id"`
	UserID    string `db:"user_id" json:"user_id"`
}

// Returns the membership kind a user has for a specific profile.
// Used to verify a user has access to publish to a target profile.
// Returns:
//
//	 'admin' if the user is an admin
//	 'owner' if the target profile is the user's individual profile
//	 the membership kind (owner/lead/maintainer/contributor) if they have membership
//	 '' if no membership
//
//	SELECT
//	  CAST(CASE
//	    WHEN u.kind = 'admin' THEN 'admin'
//	    WHEN u.individual_profile_id = $1::CHAR(26) THEN 'owner'
//	    ELSE COALESCE(pm.kind, '')
//	  END AS TEXT) as membership_kind
//	FROM "user" u
//	LEFT JOIN "profile_membership" pm ON pm.profile_id = $1::CHAR(26)
//	  AND pm.member_profile_id = u.individual_profile_id
//	  AND pm.deleted_at IS NULL
//	  AND (pm.finished_at IS NULL OR pm.finished_at > NOW())
//	WHERE u.id = $2
//	  AND u.deleted_at IS NULL
//	LIMIT 1
func (q *Queries) GetUserMembershipForProfile(ctx context.Context, arg GetUserMembershipForProfileParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getUserMembershipForProfile, arg.ProfileID, arg.UserID)
	var membership_kind string
	err := row.Scan(&membership_kind)
	return membership_kind, err
}

const insertStory = `-- name: InsertStory :one
INSERT INTO "story" (
  id,
  author_profile_id,
  slug,
  kind,
  story_picture_uri,
  properties,
  created_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  NOW()
) RETURNING id, author_profile_id, slug, kind, story_picture_uri, properties, created_at, updated_at, deleted_at
`

type InsertStoryParams struct {
	ID              string                `db:"id" json:"id"`
	AuthorProfileID sql.NullString        `db:"author_profile_id" json:"author_profile_id"`
	Slug            string                `db:"slug" json:"slug"`
	Kind            string                `db:"kind" json:"kind"`
	StoryPictureURI sql.NullString        `db:"story_picture_uri" json:"story_picture_uri"`
	Properties      pqtype.NullRawMessage `db:"properties" json:"properties"`
}

// InsertStory
//
//	INSERT INTO "story" (
//	  id,
//	  author_profile_id,
//	  slug,
//	  kind,
//	  story_picture_uri,
//	  properties,
//	  created_at
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5,
//	  $6,
//	  NOW()
//	) RETURNING id, author_profile_id, slug, kind, story_picture_uri, properties, created_at, updated_at, deleted_at
func (q *Queries) InsertStory(ctx context.Context, arg InsertStoryParams) (*Story, error) {
	row := q.db.QueryRowContext(ctx, insertStory,
		arg.ID,
		arg.AuthorProfileID,
		arg.Slug,
		arg.Kind,
		arg.StoryPictureURI,
		arg.Properties,
	)
	var i Story
	err := row.Scan(
		&i.ID,
		&i.AuthorProfileID,
		&i.Slug,
		&i.Kind,
		&i.StoryPictureURI,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const insertStoryPublication = `-- name: InsertStoryPublication :one
INSERT INTO "story_publication" (
  id,
  story_id,
  profile_id,
  kind,
  is_featured,
  published_at,
  properties,
  created_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  NOW()
) RETURNING id, story_id, profile_id, kind, properties, created_at, updated_at, deleted_at, is_featured, published_at
`

type InsertStoryPublicationParams struct {
	ID          string                `db:"id" json:"id"`
	StoryID     string                `db:"story_id" json:"story_id"`
	ProfileID   string                `db:"profile_id" json:"profile_id"`
	Kind        string                `db:"kind" json:"kind"`
	IsFeatured  bool                  `db:"is_featured" json:"is_featured"`
	PublishedAt sql.NullTime          `db:"published_at" json:"published_at"`
	Properties  pqtype.NullRawMessage `db:"properties" json:"properties"`
}

// InsertStoryPublication
//
//	INSERT INTO "story_publication" (
//	  id,
//	  story_id,
//	  profile_id,
//	  kind,
//	  is_featured,
//	  published_at,
//	  properties,
//	  created_at
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5,
//	  $6,
//	  $7,
//	  NOW()
//	) RETURNING id, story_id, profile_id, kind, properties, created_at, updated_at, deleted_at, is_featured, published_at
func (q *Queries) InsertStoryPublication(ctx context.Context, arg InsertStoryPublicationParams) (*StoryPublication, error) {
	row := q.db.QueryRowContext(ctx, insertStoryPublication,
		arg.ID,
		arg.StoryID,
		arg.ProfileID,
		arg.Kind,
		arg.IsFeatured,
		arg.PublishedAt,
		arg.Properties,
	)
	var i StoryPublication
	err := row.Scan(
		&i.ID,
		&i.StoryID,
		&i.ProfileID,
		&i.Kind,
		&i.Properties,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.IsFeatured,
		&i.PublishedAt,
	)
	return &i, err
}

const insertStoryTx = `-- name: InsertStoryTx :exec
INSERT INTO "story_tx" (
  story_id,
  locale_code,
  title,
  summary,
  content
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
)
`

type InsertStoryTxParams struct {
	StoryID    string `db:"story_id" json:"story_id"`
	LocaleCode string `db:"locale_code" json:"locale_code"`
	Title      string `db:"title" json:"title"`
	Summary    string `db:"summary" json:"summary"`
	Content    string `db:"content" json:"content"`
}

// InsertStoryTx
//
//	INSERT INTO "story_tx" (
//	  story_id,
//	  locale_code,
//	  title,
//	  summary,
//	  content
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5
//	)
func (q *Queries) InsertStoryTx(ctx context.Context, arg InsertStoryTxParams) error {
	_, err := q.db.ExecContext(ctx, insertStoryTx,
		arg.StoryID,
		arg.LocaleCode,
		arg.Title,
		arg.Summary,
		arg.Content,
	)
	return err
}

const listStoriesByAuthorProfileID = `-- name: ListStoriesByAuthorProfileID :many
SELECT
  s.id, s.author_profile_id, s.slug, s.kind, s.story_picture_uri, s.properties, s.created_at, s.updated_at, s.deleted_at,
  st.story_id, st.locale_code, st.title, st.summary, st.content, st.search_vector,
  p1.id, p1.slug, p1.kind, p1.profile_picture_uri, p1.pronouns, p1.properties, p1.created_at, p1.updated_at, p1.deleted_at, p1.approved_at, p1.points, p1.hide_relations, p1.hide_links,
  p1t.profile_id, p1t.locale_code, p1t.title, p1t.description, p1t.properties, p1t.search_vector,
  pb.publications
FROM "story" s
  INNER JOIN "story_tx" st ON st.story_id = s.id
  AND st.locale_code = (
    SELECT stx.locale_code FROM "story_tx" stx
    WHERE stx.story_id = s.id
    ORDER BY CASE WHEN stx.locale_code = $1 THEN 0 ELSE 1 END
    LIMIT 1
  )
  LEFT JOIN "profile" p1 ON p1.id = s.author_profile_id
  AND p1.approved_at IS NOT NULL
  AND p1.deleted_at IS NULL
  INNER JOIN "profile_tx" p1t ON p1t.profile_id = p1.id
  AND p1t.locale_code = (
    SELECT ptx.locale_code FROM "profile_tx" ptx
    WHERE ptx.profile_id = p1.id
    ORDER BY CASE WHEN ptx.locale_code = $1 THEN 0 ELSE 1 END
    LIMIT 1
  )
  LEFT JOIN LATERAL (
    SELECT JSONB_AGG(
      JSONB_BUILD_OBJECT('profile', row_to_json(p2), 'profile_tx', row_to_json(p2t))
    ) AS "publications"
    FROM story_publication sp
      INNER JOIN "profile" p2 ON p2.id = sp.profile_id
      AND p2.approved_at IS NOT NULL
      AND p2.deleted_at IS NULL
      INNER JOIN "profile_tx" p2t ON p2t.profile_id = p2.id
      AND p2t.locale_code = (
        SELECT ptx2.locale_code FROM "profile_tx" ptx2
        WHERE ptx2.profile_id = p2.id
        ORDER BY CASE WHEN ptx2.locale_code = $1 THEN 0 ELSE 1 END
        LIMIT 1
      )
    WHERE sp.story_id = s.id
      AND sp.deleted_at IS NULL
  ) pb ON TRUE
WHERE s.author_profile_id = $2::CHAR(26)
  AND ($3::TEXT IS NULL OR s.kind = ANY(string_to_array($3::TEXT, ',')))
  AND s.deleted_at IS NULL
ORDER BY s.created_at DESC
`

type ListStoriesByAuthorProfileIDParams struct {
	LocaleCode      string         `db:"locale_code" json:"locale_code"`
	AuthorProfileID string         `db:"author_profile_id" json:"author_profile_id"`
	FilterKind      sql.NullString `db:"filter_kind" json:"filter_kind"`
}

type ListStoriesByAuthorProfileIDRow struct {
	Story        Story                 `db:"story" json:"story"`
	StoryTx      StoryTx               `db:"story_tx" json:"story_tx"`
	Profile      Profile               `db:"profile" json:"profile"`
	ProfileTx    ProfileTx             `db:"profile_tx" json:"profile_tx"`
	Publications pqtype.NullRawMessage `db:"publications" json:"publications"`
}

// Lists all stories authored by a profile, including unpublished ones.
// Uses locale fallback: prefers the requested locale, falls back to any translation.
// Publications are included as optional data (LEFT JOIN).
//
//	SELECT
//	  s.id, s.author_profile_id, s.slug, s.kind, s.story_picture_uri, s.properties, s.created_at, s.updated_at, s.deleted_at,
//	  st.story_id, st.locale_code, st.title, st.summary, st.content, st.search_vector,
//	  p1.id, p1.slug, p1.kind, p1.profile_picture_uri, p1.pronouns, p1.properties, p1.created_at, p1.updated_at, p1.deleted_at, p1.approved_at, p1.points, p1.hide_relations, p1.hide_links,
//	  p1t.profile_id, p1t.locale_code, p1t.title, p1t.description, p1t.properties, p1t.search_vector,
//	  pb.publications
//	FROM "story" s
//	  INNER JOIN "story_tx" st ON st.story_id = s.id
//	  AND st.locale_code = (
//	    SELECT stx.locale_code FROM "story_tx" stx
//	    WHERE stx.story_id = s.id
//	    ORDER BY CASE WHEN stx.locale_code = $1 THEN 0 ELSE 1 END
//	    LIMIT 1
//	  )
//	  LEFT JOIN "profile" p1 ON p1.id = s.author_profile_id
//	  AND p1.approved_at IS NOT NULL
//	  AND p1.deleted_at IS NULL
//	  INNER JOIN "profile_tx" p1t ON p1t.profile_id = p1.id
//	  AND p1t.locale_code = (
//	    SELECT ptx.locale_code FROM "profile_tx" ptx
//	    WHERE ptx.profile_id = p1.id
//	    ORDER BY CASE WHEN ptx.locale_code = $1 THEN 0 ELSE 1 END
//	    LIMIT 1
//	  )
//	  LEFT JOIN LATERAL (
//	    SELECT JSONB_AGG(
//	      JSONB_BUILD_OBJECT('profile', row_to_json(p2), 'profile_tx', row_to_json(p2t))
//	    ) AS "publications"
//	    FROM story_publication sp
//	      INNER JOIN "profile" p2 ON p2.id = sp.profile_id
//	      AND p2.approved_at IS NOT NULL
//	      AND p2.deleted_at IS NULL
//	      INNER JOIN "profile_tx" p2t ON p2t.profile_id = p2.id
//	      AND p2t.locale_code = (
//	        SELECT ptx2.locale_code FROM "profile_tx" ptx2
//	        WHERE ptx2.profile_id = p2.id
//	        ORDER BY CASE WHEN ptx2.locale_code = $1 THEN 0 ELSE 1 END
//	        LIMIT 1
//	      )
//	    WHERE sp.story_id = s.id
//	      AND sp.deleted_at IS NULL
//	  ) pb ON TRUE
//	WHERE s.author_profile_id = $2::CHAR(26)
//	  AND ($3::TEXT IS NULL OR s.kind = ANY(string_to_array($3::TEXT, ',')))
//	  AND s.deleted_at IS NULL
//	ORDER BY s.created_at DESC
func (q *Queries) ListStoriesByAuthorProfileID(ctx context.Context, arg ListStoriesByAuthorProfileIDParams) ([]*ListStoriesByAuthorProfileIDRow, error) {
	rows, err := q.db.QueryContext(ctx, listStoriesByAuthorProfileID, arg.LocaleCode, arg.AuthorProfileID, arg.FilterKind)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListStoriesByAuthorProfileIDRow{}
	for rows.Next() {
		var i ListStoriesByAuthorProfileIDRow
		if err := rows.Scan(
			&i.Story.ID,
			&i.Story.AuthorProfileID,
			&i.Story.Slug,
			&i.Story.Kind,
			&i.Story.StoryPictureURI,
			&i.Story.Properties,
			&i.Story.CreatedAt,
			&i.Story.UpdatedAt,
			&i.Story.DeletedAt,
			&i.StoryTx.StoryID,
			&i.StoryTx.LocaleCode,
			&i.StoryTx.Title,
			&i.StoryTx.Summary,
			&i.StoryTx.Content,
			&i.StoryTx.SearchVector,
			&i.Profile.ID,
			&i.Profile.Slug,
			&i.Profile.Kind,
			&i.Profile.ProfilePictureURI,
			&i.Profile.Pronouns,
			&i.Profile.Properties,
			&i.Profile.CreatedAt,
			&i.Profile.UpdatedAt,
			&i.Profile.DeletedAt,
			&i.Profile.ApprovedAt,
			&i.Profile.Points,
			&i.Profile.HideRelations,
			&i.Profile.HideLinks,
			&i.ProfileTx.ProfileID,
			&i.ProfileTx.LocaleCode,
			&i.ProfileTx.Title,
			&i.ProfileTx.Description,
			&i.ProfileTx.Properties,
			&i.ProfileTx.SearchVector,
			&i.Publications,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStoriesOfPublication = `-- name: ListStoriesOfPublication :many
SELECT
  s.id, s.author_profile_id, s.slug, s.kind, s.story_picture_uri, s.properties, s.created_at, s.updated_at, s.deleted_at,
  st.story_id, st.locale_code, st.title, st.summary, st.content, st.search_vector,
  p1.id, p1.slug, p1.kind, p1.profile_picture_uri, p1.pronouns, p1.properties, p1.created_at, p1.updated_at, p1.deleted_at, p1.approved_at, p1.points, p1.hide_relations, p1.hide_links,
  p1t.profile_id, p1t.locale_code, p1t.title, p1t.description, p1t.properties, p1t.search_vector,
  pb.publications
FROM "story" s
  INNER JOIN "story_tx" st ON st.story_id = s.id
  AND st.locale_code = (
    SELECT stx.locale_code FROM "story_tx" stx
    WHERE stx.story_id = s.id
    ORDER BY CASE WHEN stx.locale_code = $1 THEN 0 ELSE 1 END
    LIMIT 1
  )
  LEFT JOIN "profile" p1 ON p1.id = s.author_profile_id
  AND p1.approved_at IS NOT NULL
  AND p1.deleted_at IS NULL
  INNER JOIN "profile_tx" p1t ON p1t.profile_id = p1.id
  AND p1t.locale_code = (
    SELECT ptx.locale_code FROM "profile_tx" ptx
    WHERE ptx.profile_id = p1.id
    ORDER BY CASE WHEN ptx.locale_code = $1 THEN 0 ELSE 1 END
    LIMIT 1
  )
  LEFT JOIN LATERAL (
    SELECT JSONB_AGG(
      JSONB_BUILD_OBJECT('profile', row_to_json(p2), 'profile_tx', row_to_json(p2t))
    ) AS "publications"
    FROM story_publication sp
      INNER JOIN "profile" p2 ON p2.id = sp.profile_id
      AND p2.approved_at IS NOT NULL
      AND p2.deleted_at IS NULL
      INNER JOIN "profile_tx" p2t ON p2t.profile_id = p2.id
      AND p2t.locale_code = (
        SELECT ptx2.locale_code FROM "profile_tx" ptx2
        WHERE ptx2.profile_id = p2.id
        ORDER BY CASE WHEN ptx2.locale_code = $1 THEN 0 ELSE 1 END
        LIMIT 1
      )
    WHERE sp.story_id = s.id
      AND ($2::CHAR(26) IS NULL OR sp.profile_id = $2::CHAR(26))
      AND sp.deleted_at IS NULL
  ) pb ON TRUE
WHERE
  pb.publications IS NOT NULL
  AND ($3::TEXT IS NULL OR s.kind = ANY(string_to_array($3::TEXT, ',')))
  AND ($4::CHAR(26) IS NULL OR s.author_profile_id = $4::CHAR(26))
  AND s.deleted_at IS NULL
ORDER BY s.created_at DESC
`

type ListStoriesOfPublicationParams struct {
	LocaleCode                 string         `db:"locale_code" json:"locale_code"`
	FilterPublicationProfileID sql.NullString `db:"filter_publication_profile_id" json:"filter_publication_profile_id"`
	FilterKind                 sql.NullString `db:"filter_kind" json:"filter_kind"`
	FilterAuthorProfileID      sql.NullString `db:"filter_author_profile_id" json:"filter_author_profile_id"`
}

type ListStoriesOfPublicationRow struct {
	Story        Story                 `db:"story" json:"story"`
	StoryTx      StoryTx               `db:"story_tx" json:"story_tx"`
	Profile      Profile               `db:"profile" json:"profile"`
	ProfileTx    ProfileTx             `db:"profile_tx" json:"profile_tx"`
	Publications pqtype.NullRawMessage `db:"publications" json:"publications"`
}

// Uses locale fallback: prefers the requested locale, falls back to any translation.
//
//	SELECT
//	  s.id, s.author_profile_id, s.slug, s.kind, s.story_picture_uri, s.properties, s.created_at, s.updated_at, s.deleted_at,
//	  st.story_id, st.locale_code, st.title, st.summary, st.content, st.search_vector,
//	  p1.id, p1.slug, p1.kind, p1.profile_picture_uri, p1.pronouns, p1.properties, p1.created_at, p1.updated_at, p1.deleted_at, p1.approved_at, p1.points, p1.hide_relations, p1.hide_links,
//	  p1t.profile_id, p1t.locale_code, p1t.title, p1t.description, p1t.properties, p1t.search_vector,
//	  pb.publications
//	FROM "story" s
//	  INNER JOIN "story_tx" st ON st.story_id = s.id
//	  AND st.locale_code = (
//	    SELECT stx.locale_code FROM "story_tx" stx
//	    WHERE stx.story_id = s.id
//	    ORDER BY CASE WHEN stx.locale_code = $1 THEN 0 ELSE 1 END
//	    LIMIT 1
//	  )
//	  LEFT JOIN "profile" p1 ON p1.id = s.author_profile_id
//	  AND p1.approved_at IS NOT NULL
//	  AND p1.deleted_at IS NULL
//	  INNER JOIN "profile_tx" p1t ON p1t.profile_id = p1.id
//	  AND p1t.locale_code = (
//	    SELECT ptx.locale_code FROM "profile_tx" ptx
//	    WHERE ptx.profile_id = p1.id
//	    ORDER BY CASE WHEN ptx.locale_code = $1 THEN 0 ELSE 1 END
//	    LIMIT 1
//	  )
//	  LEFT JOIN LATERAL (
//	    SELECT JSONB_AGG(
//	      JSONB_BUILD_OBJECT('profile', row_to_json(p2), 'profile_tx', row_to_json(p2t))
//	    ) AS "publications"
//	    FROM story_publication sp
//	      INNER JOIN "profile" p2 ON p2.id = sp.profile_id
//	      AND p2.approved_at IS NOT NULL
//	      AND p2.deleted_at IS NULL
//	      INNER JOIN "profile_tx" p2t ON p2t.profile_id = p2.id
//	      AND p2t.locale_code = (
//	        SELECT ptx2.locale_code FROM "profile_tx" ptx2
//	        WHERE ptx2.profile_id = p2.id
//	        ORDER BY CASE WHEN ptx2.locale_code = $1 THEN 0 ELSE 1 END
//	        LIMIT 1
//	      )
//	    WHERE sp.story_id = s.id
//	      AND ($2::CHAR(26) IS NULL OR sp.profile_id = $2::CHAR(26))
//	      AND sp.deleted_at IS NULL
//	  ) pb ON TRUE
//	WHERE
//	  pb.publications IS NOT NULL
//	  AND ($3::TEXT IS NULL OR s.kind = ANY(string_to_array($3::TEXT, ',')))
//	  AND ($4::CHAR(26) IS NULL OR s.author_profile_id = $4::CHAR(26))
//	  AND s.deleted_at IS NULL
//	ORDER BY s.created_at DESC
func (q *Queries) ListStoriesOfPublication(ctx context.Context, arg ListStoriesOfPublicationParams) ([]*ListStoriesOfPublicationRow, error) {
	rows, err := q.db.QueryContext(ctx, listStoriesOfPublication,
		arg.LocaleCode,
		arg.FilterPublicationProfileID,
		arg.FilterKind,
		arg.FilterAuthorProfileID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListStoriesOfPublicationRow{}
	for rows.Next() {
		var i ListStoriesOfPublicationRow
		if err := rows.Scan(
			&i.Story.ID,
			&i.Story.AuthorProfileID,
			&i.Story.Slug,
			&i.Story.Kind,
			&i.Story.StoryPictureURI,
			&i.Story.Properties,
			&i.Story.CreatedAt,
			&i.Story.UpdatedAt,
			&i.Story.DeletedAt,
			&i.StoryTx.StoryID,
			&i.StoryTx.LocaleCode,
			&i.StoryTx.Title,
			&i.StoryTx.Summary,
			&i.StoryTx.Content,
			&i.StoryTx.SearchVector,
			&i.Profile.ID,
			&i.Profile.Slug,
			&i.Profile.Kind,
			&i.Profile.ProfilePictureURI,
			&i.Profile.Pronouns,
			&i.Profile.Properties,
			&i.Profile.CreatedAt,
			&i.Profile.UpdatedAt,
			&i.Profile.DeletedAt,
			&i.Profile.ApprovedAt,
			&i.Profile.Points,
			&i.Profile.HideRelations,
			&i.Profile.HideLinks,
			&i.ProfileTx.ProfileID,
			&i.ProfileTx.LocaleCode,
			&i.ProfileTx.Title,
			&i.ProfileTx.Description,
			&i.ProfileTx.Properties,
			&i.ProfileTx.SearchVector,
			&i.Publications,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStoryPublications = `-- name: ListStoryPublications :many
SELECT
  sp.id,
  sp.story_id,
  sp.profile_id,
  sp.kind,
  sp.is_featured,
  sp.published_at,
  sp.created_at,
  p.slug as profile_slug,
  pt.title as profile_title,
  p.profile_picture_uri,
  p.kind as profile_kind
FROM story_publication sp
  INNER JOIN "profile" p ON p.id = sp.profile_id AND p.deleted_at IS NULL
  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id AND pt.locale_code = $1
WHERE sp.story_id = $2
  AND sp.deleted_at IS NULL
ORDER BY sp.created_at
`

type ListStoryPublicationsParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	StoryID    string `db:"story_id" json:"story_id"`
}

type ListStoryPublicationsRow struct {
	ID                string         `db:"id" json:"id"`
	StoryID           string         `db:"story_id" json:"story_id"`
	ProfileID         string         `db:"profile_id" json:"profile_id"`
	Kind              string         `db:"kind" json:"kind"`
	IsFeatured        bool           `db:"is_featured" json:"is_featured"`
	PublishedAt       sql.NullTime   `db:"published_at" json:"published_at"`
	CreatedAt         time.Time      `db:"created_at" json:"created_at"`
	ProfileSlug       string         `db:"profile_slug" json:"profile_slug"`
	ProfileTitle      string         `db:"profile_title" json:"profile_title"`
	ProfilePictureURI sql.NullString `db:"profile_picture_uri" json:"profile_picture_uri"`
	ProfileKind       string         `db:"profile_kind" json:"profile_kind"`
}

// Lists all publications for a story with profile info (for publish popup)
//
//	SELECT
//	  sp.id,
//	  sp.story_id,
//	  sp.profile_id,
//	  sp.kind,
//	  sp.is_featured,
//	  sp.published_at,
//	  sp.created_at,
//	  p.slug as profile_slug,
//	  pt.title as profile_title,
//	  p.profile_picture_uri,
//	  p.kind as profile_kind
//	FROM story_publication sp
//	  INNER JOIN "profile" p ON p.id = sp.profile_id AND p.deleted_at IS NULL
//	  INNER JOIN "profile_tx" pt ON pt.profile_id = p.id AND pt.locale_code = $1
//	WHERE sp.story_id = $2
//	  AND sp.deleted_at IS NULL
//	ORDER BY sp.created_at
func (q *Queries) ListStoryPublications(ctx context.Context, arg ListStoryPublicationsParams) ([]*ListStoryPublicationsRow, error) {
	rows, err := q.db.QueryContext(ctx, listStoryPublications, arg.LocaleCode, arg.StoryID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListStoryPublicationsRow{}
	for rows.Next() {
		var i ListStoryPublicationsRow
		if err := rows.Scan(
			&i.ID,
			&i.StoryID,
			&i.ProfileID,
			&i.Kind,
			&i.IsFeatured,
			&i.PublishedAt,
			&i.CreatedAt,
			&i.ProfileSlug,
			&i.ProfileTitle,
			&i.ProfilePictureURI,
			&i.ProfileKind,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeStory = `-- name: RemoveStory :execrows
UPDATE "story"
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type RemoveStoryParams struct {
	ID string `db:"id" json:"id"`
}

// RemoveStory
//
//	UPDATE "story"
//	SET deleted_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) RemoveStory(ctx context.Context, arg RemoveStoryParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeStory, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const removeStoryPublication = `-- name: RemoveStoryPublication :execrows
UPDATE story_publication
SET deleted_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type RemoveStoryPublicationParams struct {
	ID string `db:"id" json:"id"`
}

// RemoveStoryPublication
//
//	UPDATE story_publication
//	SET deleted_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) RemoveStoryPublication(ctx context.Context, arg RemoveStoryPublicationParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, removeStoryPublication, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const searchStories = `-- name: SearchStories :many
SELECT
  s.id,
  s.slug,
  s.kind,
  s.story_picture_uri,
  s.author_profile_id,
  st.title,
  st.summary,
  p.slug as author_slug,
  pt.title as author_title,
  ts_rank(st.search_vector, plainto_tsquery(locale_to_regconfig($1), $2)) as rank
FROM "story" s
  INNER JOIN "story_tx" st ON st.story_id = s.id
    AND st.locale_code = $1
  LEFT JOIN "profile" p ON p.id = s.author_profile_id AND p.deleted_at IS NULL
  LEFT JOIN "profile_tx" pt ON pt.profile_id = p.id
    AND pt.locale_code = $1
WHERE st.search_vector @@ plainto_tsquery(locale_to_regconfig($1), $2)
  AND s.deleted_at IS NULL
  AND EXISTS (
    SELECT 1 FROM story_publication sp
    WHERE sp.story_id = s.id AND sp.deleted_at IS NULL
  )
  AND ($3::TEXT IS NULL OR p.slug = $3::TEXT)
ORDER BY rank DESC
LIMIT $4
`

type SearchStoriesParams struct {
	LocaleCode        string         `db:"locale_code" json:"locale_code"`
	Query             string         `db:"query" json:"query"`
	FilterProfileSlug sql.NullString `db:"filter_profile_slug" json:"filter_profile_slug"`
	LimitCount        int32          `db:"limit_count" json:"limit_count"`
}

type SearchStoriesRow struct {
	ID              string         `db:"id" json:"id"`
	Slug            string         `db:"slug" json:"slug"`
	Kind            string         `db:"kind" json:"kind"`
	StoryPictureURI sql.NullString `db:"story_picture_uri" json:"story_picture_uri"`
	AuthorProfileID sql.NullString `db:"author_profile_id" json:"author_profile_id"`
	Title           string         `db:"title" json:"title"`
	Summary         string         `db:"summary" json:"summary"`
	AuthorSlug      sql.NullString `db:"author_slug" json:"author_slug"`
	AuthorTitle     sql.NullString `db:"author_title" json:"author_title"`
	Rank            float32        `db:"rank" json:"rank"`
}

// SearchStories
//
//	SELECT
//	  s.id,
//	  s.slug,
//	  s.kind,
//	  s.story_picture_uri,
//	  s.author_profile_id,
//	  st.title,
//	  st.summary,
//	  p.slug as author_slug,
//	  pt.title as author_title,
//	  ts_rank(st.search_vector, plainto_tsquery(locale_to_regconfig($1), $2)) as rank
//	FROM "story" s
//	  INNER JOIN "story_tx" st ON st.story_id = s.id
//	    AND st.locale_code = $1
//	  LEFT JOIN "profile" p ON p.id = s.author_profile_id AND p.deleted_at IS NULL
//	  LEFT JOIN "profile_tx" pt ON pt.profile_id = p.id
//	    AND pt.locale_code = $1
//	WHERE st.search_vector @@ plainto_tsquery(locale_to_regconfig($1), $2)
//	  AND s.deleted_at IS NULL
//	  AND EXISTS (
//	    SELECT 1 FROM story_publication sp
//	    WHERE sp.story_id = s.id AND sp.deleted_at IS NULL
//	  )
//	  AND ($3::TEXT IS NULL OR p.slug = $3::TEXT)
//	ORDER BY rank DESC
//	LIMIT $4
func (q *Queries) SearchStories(ctx context.Context, arg SearchStoriesParams) ([]*SearchStoriesRow, error) {
	rows, err := q.db.QueryContext(ctx, searchStories,
		arg.LocaleCode,
		arg.Query,
		arg.FilterProfileSlug,
		arg.LimitCount,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*SearchStoriesRow{}
	for rows.Next() {
		var i SearchStoriesRow
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Kind,
			&i.StoryPictureURI,
			&i.AuthorProfileID,
			&i.Title,
			&i.Summary,
			&i.AuthorSlug,
			&i.AuthorTitle,
			&i.Rank,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateStory = `-- name: UpdateStory :execrows
UPDATE "story"
SET
  slug = $1,
  story_picture_uri = $2,
  updated_at = NOW()
WHERE id = $3
  AND deleted_at IS NULL
`

type UpdateStoryParams struct {
	Slug            string         `db:"slug" json:"slug"`
	StoryPictureURI sql.NullString `db:"story_picture_uri" json:"story_picture_uri"`
	ID              string         `db:"id" json:"id"`
}

// UpdateStory
//
//	UPDATE "story"
//	SET
//	  slug = $1,
//	  story_picture_uri = $2,
//	  updated_at = NOW()
//	WHERE id = $3
//	  AND deleted_at IS NULL
func (q *Queries) UpdateStory(ctx context.Context, arg UpdateStoryParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateStory, arg.Slug, arg.StoryPictureURI, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateStoryPublication = `-- name: UpdateStoryPublication :execrows
UPDATE story_publication
SET
  is_featured = $1,
  updated_at = NOW()
WHERE id = $2
  AND deleted_at IS NULL
`

type UpdateStoryPublicationParams struct {
	IsFeatured bool   `db:"is_featured" json:"is_featured"`
	ID         string `db:"id" json:"id"`
}

// UpdateStoryPublication
//
//	UPDATE story_publication
//	SET
//	  is_featured = $1,
//	  updated_at = NOW()
//	WHERE id = $2
//	  AND deleted_at IS NULL
func (q *Queries) UpdateStoryPublication(ctx context.Context, arg UpdateStoryPublicationParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateStoryPublication, arg.IsFeatured, arg.ID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const updateStoryTx = `-- name: UpdateStoryTx :execrows
UPDATE "story_tx"
SET
  title = $1,
  summary = $2,
  content = $3
WHERE story_id = $4
  AND locale_code = $5
`

type UpdateStoryTxParams struct {
	Title      string `db:"title" json:"title"`
	Summary    string `db:"summary" json:"summary"`
	Content    string `db:"content" json:"content"`
	StoryID    string `db:"story_id" json:"story_id"`
	LocaleCode string `db:"locale_code" json:"locale_code"`
}

// UpdateStoryTx
//
//	UPDATE "story_tx"
//	SET
//	  title = $1,
//	  summary = $2,
//	  content = $3
//	WHERE story_id = $4
//	  AND locale_code = $5
func (q *Queries) UpdateStoryTx(ctx context.Context, arg UpdateStoryTxParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, updateStoryTx,
		arg.Title,
		arg.Summary,
		arg.Content,
		arg.StoryID,
		arg.LocaleCode,
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const upsertStoryTx = `-- name: UpsertStoryTx :exec
INSERT INTO "story_tx" (
  story_id,
  locale_code,
  title,
  summary,
  content
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5
) ON CONFLICT (story_id, locale_code) DO UPDATE SET
  title = EXCLUDED.title,
  summary = EXCLUDED.summary,
  content = EXCLUDED.content
`

type UpsertStoryTxParams struct {
	StoryID    string `db:"story_id" json:"story_id"`
	LocaleCode string `db:"locale_code" json:"locale_code"`
	Title      string `db:"title" json:"title"`
	Summary    string `db:"summary" json:"summary"`
	Content    string `db:"content" json:"content"`
}

// UpsertStoryTx
//
//	INSERT INTO "story_tx" (
//	  story_id,
//	  locale_code,
//	  title,
//	  summary,
//	  content
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5
//	) ON CONFLICT (story_id, locale_code) DO UPDATE SET
//	  title = EXCLUDED.title,
//	  summary = EXCLUDED.summary,
//	  content = EXCLUDED.content
func (q *Queries) UpsertStoryTx(ctx context.Context, arg UpsertStoryTxParams) error {
	_, err := q.db.ExecContext(ctx, upsertStoryTx,
		arg.StoryID,
		arg.LocaleCode,
		arg.Title,
		arg.Summary,
		arg.Content,
	)
	return err
}
