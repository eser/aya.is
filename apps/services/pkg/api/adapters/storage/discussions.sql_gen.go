// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: discussions.sql

package storage

import (
	"context"
	"database/sql"
	"time"
)

const adjustDiscussionCommentVoteScore = `-- name: AdjustDiscussionCommentVoteScore :exec
UPDATE "discussion_comment"
SET
  vote_score = vote_score + $1::INTEGER,
  upvote_count = GREATEST(upvote_count + $2::INTEGER, 0),
  downvote_count = GREATEST(downvote_count + $3::INTEGER, 0),
  updated_at = NOW()
WHERE id = $4
  AND deleted_at IS NULL
`

type AdjustDiscussionCommentVoteScoreParams struct {
	ScoreDelta    int32  `db:"score_delta" json:"score_delta"`
	UpvoteDelta   int32  `db:"upvote_delta" json:"upvote_delta"`
	DownvoteDelta int32  `db:"downvote_delta" json:"downvote_delta"`
	ID            string `db:"id" json:"id"`
}

// AdjustDiscussionCommentVoteScore
//
//	UPDATE "discussion_comment"
//	SET
//	  vote_score = vote_score + $1::INTEGER,
//	  upvote_count = GREATEST(upvote_count + $2::INTEGER, 0),
//	  downvote_count = GREATEST(downvote_count + $3::INTEGER, 0),
//	  updated_at = NOW()
//	WHERE id = $4
//	  AND deleted_at IS NULL
func (q *Queries) AdjustDiscussionCommentVoteScore(ctx context.Context, arg AdjustDiscussionCommentVoteScoreParams) error {
	_, err := q.db.ExecContext(ctx, adjustDiscussionCommentVoteScore,
		arg.ScoreDelta,
		arg.UpvoteDelta,
		arg.DownvoteDelta,
		arg.ID,
	)
	return err
}

const decrementDiscussionCommentReplyCount = `-- name: DecrementDiscussionCommentReplyCount :exec
UPDATE "discussion_comment"
SET
  reply_count = GREATEST(reply_count - 1, 0),
  updated_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type DecrementDiscussionCommentReplyCountParams struct {
	ID string `db:"id" json:"id"`
}

// DecrementDiscussionCommentReplyCount
//
//	UPDATE "discussion_comment"
//	SET
//	  reply_count = GREATEST(reply_count - 1, 0),
//	  updated_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) DecrementDiscussionCommentReplyCount(ctx context.Context, arg DecrementDiscussionCommentReplyCountParams) error {
	_, err := q.db.ExecContext(ctx, decrementDiscussionCommentReplyCount, arg.ID)
	return err
}

const decrementDiscussionThreadCommentCount = `-- name: DecrementDiscussionThreadCommentCount :exec
UPDATE "discussion_thread"
SET
  comment_count = GREATEST(comment_count - 1, 0),
  updated_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type DecrementDiscussionThreadCommentCountParams struct {
	ID string `db:"id" json:"id"`
}

// DecrementDiscussionThreadCommentCount
//
//	UPDATE "discussion_thread"
//	SET
//	  comment_count = GREATEST(comment_count - 1, 0),
//	  updated_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) DecrementDiscussionThreadCommentCount(ctx context.Context, arg DecrementDiscussionThreadCommentCountParams) error {
	_, err := q.db.ExecContext(ctx, decrementDiscussionThreadCommentCount, arg.ID)
	return err
}

const deleteDiscussionCommentVote = `-- name: DeleteDiscussionCommentVote :exec
DELETE FROM "discussion_comment_vote"
WHERE comment_id = $1
  AND user_id = $2
`

type DeleteDiscussionCommentVoteParams struct {
	CommentID string `db:"comment_id" json:"comment_id"`
	UserID    string `db:"user_id" json:"user_id"`
}

// DeleteDiscussionCommentVote
//
//	DELETE FROM "discussion_comment_vote"
//	WHERE comment_id = $1
//	  AND user_id = $2
func (q *Queries) DeleteDiscussionCommentVote(ctx context.Context, arg DeleteDiscussionCommentVoteParams) error {
	_, err := q.db.ExecContext(ctx, deleteDiscussionCommentVote, arg.CommentID, arg.UserID)
	return err
}

const getDiscussionComment = `-- name: GetDiscussionComment :one
SELECT
  dc.id, dc.thread_id, dc.parent_id, dc.author_user_id, dc.content, dc.depth, dc.vote_score, dc.upvote_count, dc.downvote_count, dc.reply_count, dc.is_pinned, dc.is_hidden, dc.is_edited, dc.created_at, dc.updated_at, dc.deleted_at,
  u.individual_profile_id AS author_profile_id,
  ap.slug AS author_profile_slug,
  apt.title AS author_profile_title,
  ap.profile_picture_uri AS author_profile_picture_uri
FROM "discussion_comment" dc
  LEFT JOIN "user" u ON u.id = dc.author_user_id
  LEFT JOIN "profile" ap ON ap.id = u.individual_profile_id
  LEFT JOIN "profile_tx" apt ON apt.profile_id = ap.id
    AND apt.locale_code = (
      SELECT aptf.locale_code FROM "profile_tx" aptf
      WHERE aptf.profile_id = ap.id
      ORDER BY CASE
        WHEN aptf.locale_code = $1 THEN 0
        WHEN aptf.locale_code = ap.default_locale THEN 1
        ELSE 2
      END
      LIMIT 1
    )
WHERE dc.id = $2
  AND dc.deleted_at IS NULL
`

type GetDiscussionCommentParams struct {
	LocaleCode string `db:"locale_code" json:"locale_code"`
	ID         string `db:"id" json:"id"`
}

type GetDiscussionCommentRow struct {
	ID                      string         `db:"id" json:"id"`
	ThreadID                string         `db:"thread_id" json:"thread_id"`
	ParentID                sql.NullString `db:"parent_id" json:"parent_id"`
	AuthorUserID            string         `db:"author_user_id" json:"author_user_id"`
	Content                 string         `db:"content" json:"content"`
	Depth                   int32          `db:"depth" json:"depth"`
	VoteScore               int32          `db:"vote_score" json:"vote_score"`
	UpvoteCount             int32          `db:"upvote_count" json:"upvote_count"`
	DownvoteCount           int32          `db:"downvote_count" json:"downvote_count"`
	ReplyCount              int32          `db:"reply_count" json:"reply_count"`
	IsPinned                bool           `db:"is_pinned" json:"is_pinned"`
	IsHidden                bool           `db:"is_hidden" json:"is_hidden"`
	IsEdited                bool           `db:"is_edited" json:"is_edited"`
	CreatedAt               time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt               sql.NullTime   `db:"updated_at" json:"updated_at"`
	DeletedAt               sql.NullTime   `db:"deleted_at" json:"deleted_at"`
	AuthorProfileID         sql.NullString `db:"author_profile_id" json:"author_profile_id"`
	AuthorProfileSlug       sql.NullString `db:"author_profile_slug" json:"author_profile_slug"`
	AuthorProfileTitle      sql.NullString `db:"author_profile_title" json:"author_profile_title"`
	AuthorProfilePictureURI sql.NullString `db:"author_profile_picture_uri" json:"author_profile_picture_uri"`
}

// GetDiscussionComment
//
//	SELECT
//	  dc.id, dc.thread_id, dc.parent_id, dc.author_user_id, dc.content, dc.depth, dc.vote_score, dc.upvote_count, dc.downvote_count, dc.reply_count, dc.is_pinned, dc.is_hidden, dc.is_edited, dc.created_at, dc.updated_at, dc.deleted_at,
//	  u.individual_profile_id AS author_profile_id,
//	  ap.slug AS author_profile_slug,
//	  apt.title AS author_profile_title,
//	  ap.profile_picture_uri AS author_profile_picture_uri
//	FROM "discussion_comment" dc
//	  LEFT JOIN "user" u ON u.id = dc.author_user_id
//	  LEFT JOIN "profile" ap ON ap.id = u.individual_profile_id
//	  LEFT JOIN "profile_tx" apt ON apt.profile_id = ap.id
//	    AND apt.locale_code = (
//	      SELECT aptf.locale_code FROM "profile_tx" aptf
//	      WHERE aptf.profile_id = ap.id
//	      ORDER BY CASE
//	        WHEN aptf.locale_code = $1 THEN 0
//	        WHEN aptf.locale_code = ap.default_locale THEN 1
//	        ELSE 2
//	      END
//	      LIMIT 1
//	    )
//	WHERE dc.id = $2
//	  AND dc.deleted_at IS NULL
func (q *Queries) GetDiscussionComment(ctx context.Context, arg GetDiscussionCommentParams) (*GetDiscussionCommentRow, error) {
	row := q.db.QueryRowContext(ctx, getDiscussionComment, arg.LocaleCode, arg.ID)
	var i GetDiscussionCommentRow
	err := row.Scan(
		&i.ID,
		&i.ThreadID,
		&i.ParentID,
		&i.AuthorUserID,
		&i.Content,
		&i.Depth,
		&i.VoteScore,
		&i.UpvoteCount,
		&i.DownvoteCount,
		&i.ReplyCount,
		&i.IsPinned,
		&i.IsHidden,
		&i.IsEdited,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.AuthorProfileID,
		&i.AuthorProfileSlug,
		&i.AuthorProfileTitle,
		&i.AuthorProfilePictureURI,
	)
	return &i, err
}

const getDiscussionCommentRaw = `-- name: GetDiscussionCommentRaw :one
SELECT id, thread_id, parent_id, author_user_id, content, depth, vote_score, upvote_count, downvote_count, reply_count, is_pinned, is_hidden, is_edited, created_at, updated_at, deleted_at
FROM "discussion_comment"
WHERE id = $1
  AND deleted_at IS NULL
`

type GetDiscussionCommentRawParams struct {
	ID string `db:"id" json:"id"`
}

// GetDiscussionCommentRaw
//
//	SELECT id, thread_id, parent_id, author_user_id, content, depth, vote_score, upvote_count, downvote_count, reply_count, is_pinned, is_hidden, is_edited, created_at, updated_at, deleted_at
//	FROM "discussion_comment"
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) GetDiscussionCommentRaw(ctx context.Context, arg GetDiscussionCommentRawParams) (*DiscussionComment, error) {
	row := q.db.QueryRowContext(ctx, getDiscussionCommentRaw, arg.ID)
	var i DiscussionComment
	err := row.Scan(
		&i.ID,
		&i.ThreadID,
		&i.ParentID,
		&i.AuthorUserID,
		&i.Content,
		&i.Depth,
		&i.VoteScore,
		&i.UpvoteCount,
		&i.DownvoteCount,
		&i.ReplyCount,
		&i.IsPinned,
		&i.IsHidden,
		&i.IsEdited,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getDiscussionCommentVote = `-- name: GetDiscussionCommentVote :one
SELECT id, comment_id, user_id, direction, created_at
FROM "discussion_comment_vote"
WHERE comment_id = $1
  AND user_id = $2
`

type GetDiscussionCommentVoteParams struct {
	CommentID string `db:"comment_id" json:"comment_id"`
	UserID    string `db:"user_id" json:"user_id"`
}

// GetDiscussionCommentVote
//
//	SELECT id, comment_id, user_id, direction, created_at
//	FROM "discussion_comment_vote"
//	WHERE comment_id = $1
//	  AND user_id = $2
func (q *Queries) GetDiscussionCommentVote(ctx context.Context, arg GetDiscussionCommentVoteParams) (*DiscussionCommentVote, error) {
	row := q.db.QueryRowContext(ctx, getDiscussionCommentVote, arg.CommentID, arg.UserID)
	var i DiscussionCommentVote
	err := row.Scan(
		&i.ID,
		&i.CommentID,
		&i.UserID,
		&i.Direction,
		&i.CreatedAt,
	)
	return &i, err
}

const getDiscussionThread = `-- name: GetDiscussionThread :one
SELECT id, story_id, profile_id, is_locked, comment_count, created_at, updated_at, deleted_at
FROM "discussion_thread"
WHERE id = $1
  AND deleted_at IS NULL
`

type GetDiscussionThreadParams struct {
	ID string `db:"id" json:"id"`
}

// GetDiscussionThread
//
//	SELECT id, story_id, profile_id, is_locked, comment_count, created_at, updated_at, deleted_at
//	FROM "discussion_thread"
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) GetDiscussionThread(ctx context.Context, arg GetDiscussionThreadParams) (*DiscussionThread, error) {
	row := q.db.QueryRowContext(ctx, getDiscussionThread, arg.ID)
	var i DiscussionThread
	err := row.Scan(
		&i.ID,
		&i.StoryID,
		&i.ProfileID,
		&i.IsLocked,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getDiscussionThreadByProfileID = `-- name: GetDiscussionThreadByProfileID :one
SELECT id, story_id, profile_id, is_locked, comment_count, created_at, updated_at, deleted_at
FROM "discussion_thread"
WHERE profile_id = $1
  AND deleted_at IS NULL
`

type GetDiscussionThreadByProfileIDParams struct {
	ProfileID sql.NullString `db:"profile_id" json:"profile_id"`
}

// GetDiscussionThreadByProfileID
//
//	SELECT id, story_id, profile_id, is_locked, comment_count, created_at, updated_at, deleted_at
//	FROM "discussion_thread"
//	WHERE profile_id = $1
//	  AND deleted_at IS NULL
func (q *Queries) GetDiscussionThreadByProfileID(ctx context.Context, arg GetDiscussionThreadByProfileIDParams) (*DiscussionThread, error) {
	row := q.db.QueryRowContext(ctx, getDiscussionThreadByProfileID, arg.ProfileID)
	var i DiscussionThread
	err := row.Scan(
		&i.ID,
		&i.StoryID,
		&i.ProfileID,
		&i.IsLocked,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getDiscussionThreadByStoryID = `-- name: GetDiscussionThreadByStoryID :one
SELECT id, story_id, profile_id, is_locked, comment_count, created_at, updated_at, deleted_at
FROM "discussion_thread"
WHERE story_id = $1
  AND deleted_at IS NULL
`

type GetDiscussionThreadByStoryIDParams struct {
	StoryID sql.NullString `db:"story_id" json:"story_id"`
}

// GetDiscussionThreadByStoryID
//
//	SELECT id, story_id, profile_id, is_locked, comment_count, created_at, updated_at, deleted_at
//	FROM "discussion_thread"
//	WHERE story_id = $1
//	  AND deleted_at IS NULL
func (q *Queries) GetDiscussionThreadByStoryID(ctx context.Context, arg GetDiscussionThreadByStoryIDParams) (*DiscussionThread, error) {
	row := q.db.QueryRowContext(ctx, getDiscussionThreadByStoryID, arg.StoryID)
	var i DiscussionThread
	err := row.Scan(
		&i.ID,
		&i.StoryID,
		&i.ProfileID,
		&i.IsLocked,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getDiscussionVisibility = `-- name: GetDiscussionVisibility :one
SELECT feature_discussions
FROM "profile"
WHERE id = $1
`

type GetDiscussionVisibilityParams struct {
	ID string `db:"id" json:"id"`
}

// GetDiscussionVisibility
//
//	SELECT feature_discussions
//	FROM "profile"
//	WHERE id = $1
func (q *Queries) GetDiscussionVisibility(ctx context.Context, arg GetDiscussionVisibilityParams) (string, error) {
	row := q.db.QueryRowContext(ctx, getDiscussionVisibility, arg.ID)
	var feature_discussions string
	err := row.Scan(&feature_discussions)
	return feature_discussions, err
}

const getStoryAuthorProfileID = `-- name: GetStoryAuthorProfileID :one
SELECT author_profile_id
FROM "story"
WHERE id = $1
  AND deleted_at IS NULL
`

type GetStoryAuthorProfileIDParams struct {
	ID string `db:"id" json:"id"`
}

// GetStoryAuthorProfileID
//
//	SELECT author_profile_id
//	FROM "story"
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) GetStoryAuthorProfileID(ctx context.Context, arg GetStoryAuthorProfileIDParams) (sql.NullString, error) {
	row := q.db.QueryRowContext(ctx, getStoryAuthorProfileID, arg.ID)
	var author_profile_id sql.NullString
	err := row.Scan(&author_profile_id)
	return author_profile_id, err
}

const incrementDiscussionCommentReplyCount = `-- name: IncrementDiscussionCommentReplyCount :exec
UPDATE "discussion_comment"
SET
  reply_count = reply_count + 1,
  updated_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type IncrementDiscussionCommentReplyCountParams struct {
	ID string `db:"id" json:"id"`
}

// IncrementDiscussionCommentReplyCount
//
//	UPDATE "discussion_comment"
//	SET
//	  reply_count = reply_count + 1,
//	  updated_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) IncrementDiscussionCommentReplyCount(ctx context.Context, arg IncrementDiscussionCommentReplyCountParams) error {
	_, err := q.db.ExecContext(ctx, incrementDiscussionCommentReplyCount, arg.ID)
	return err
}

const incrementDiscussionThreadCommentCount = `-- name: IncrementDiscussionThreadCommentCount :exec
UPDATE "discussion_thread"
SET
  comment_count = comment_count + 1,
  updated_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type IncrementDiscussionThreadCommentCountParams struct {
	ID string `db:"id" json:"id"`
}

// IncrementDiscussionThreadCommentCount
//
//	UPDATE "discussion_thread"
//	SET
//	  comment_count = comment_count + 1,
//	  updated_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) IncrementDiscussionThreadCommentCount(ctx context.Context, arg IncrementDiscussionThreadCommentCountParams) error {
	_, err := q.db.ExecContext(ctx, incrementDiscussionThreadCommentCount, arg.ID)
	return err
}

const insertDiscussionComment = `-- name: InsertDiscussionComment :one
INSERT INTO "discussion_comment" (
  id,
  thread_id,
  parent_id,
  author_user_id,
  content,
  depth,
  created_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  NOW()
) RETURNING id, thread_id, parent_id, author_user_id, content, depth, vote_score, upvote_count, downvote_count, reply_count, is_pinned, is_hidden, is_edited, created_at, updated_at, deleted_at
`

type InsertDiscussionCommentParams struct {
	ID           string         `db:"id" json:"id"`
	ThreadID     string         `db:"thread_id" json:"thread_id"`
	ParentID     sql.NullString `db:"parent_id" json:"parent_id"`
	AuthorUserID string         `db:"author_user_id" json:"author_user_id"`
	Content      string         `db:"content" json:"content"`
	Depth        int32          `db:"depth" json:"depth"`
}

// InsertDiscussionComment
//
//	INSERT INTO "discussion_comment" (
//	  id,
//	  thread_id,
//	  parent_id,
//	  author_user_id,
//	  content,
//	  depth,
//	  created_at
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  $5,
//	  $6,
//	  NOW()
//	) RETURNING id, thread_id, parent_id, author_user_id, content, depth, vote_score, upvote_count, downvote_count, reply_count, is_pinned, is_hidden, is_edited, created_at, updated_at, deleted_at
func (q *Queries) InsertDiscussionComment(ctx context.Context, arg InsertDiscussionCommentParams) (*DiscussionComment, error) {
	row := q.db.QueryRowContext(ctx, insertDiscussionComment,
		arg.ID,
		arg.ThreadID,
		arg.ParentID,
		arg.AuthorUserID,
		arg.Content,
		arg.Depth,
	)
	var i DiscussionComment
	err := row.Scan(
		&i.ID,
		&i.ThreadID,
		&i.ParentID,
		&i.AuthorUserID,
		&i.Content,
		&i.Depth,
		&i.VoteScore,
		&i.UpvoteCount,
		&i.DownvoteCount,
		&i.ReplyCount,
		&i.IsPinned,
		&i.IsHidden,
		&i.IsEdited,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const insertDiscussionCommentVote = `-- name: InsertDiscussionCommentVote :one
INSERT INTO "discussion_comment_vote" (
  id,
  comment_id,
  user_id,
  direction,
  created_at
) VALUES (
  $1,
  $2,
  $3,
  $4,
  NOW()
) RETURNING id, comment_id, user_id, direction, created_at
`

type InsertDiscussionCommentVoteParams struct {
	ID        string `db:"id" json:"id"`
	CommentID string `db:"comment_id" json:"comment_id"`
	UserID    string `db:"user_id" json:"user_id"`
	Direction int16  `db:"direction" json:"direction"`
}

// InsertDiscussionCommentVote
//
//	INSERT INTO "discussion_comment_vote" (
//	  id,
//	  comment_id,
//	  user_id,
//	  direction,
//	  created_at
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  $4,
//	  NOW()
//	) RETURNING id, comment_id, user_id, direction, created_at
func (q *Queries) InsertDiscussionCommentVote(ctx context.Context, arg InsertDiscussionCommentVoteParams) (*DiscussionCommentVote, error) {
	row := q.db.QueryRowContext(ctx, insertDiscussionCommentVote,
		arg.ID,
		arg.CommentID,
		arg.UserID,
		arg.Direction,
	)
	var i DiscussionCommentVote
	err := row.Scan(
		&i.ID,
		&i.CommentID,
		&i.UserID,
		&i.Direction,
		&i.CreatedAt,
	)
	return &i, err
}

const insertDiscussionThread = `-- name: InsertDiscussionThread :one
INSERT INTO "discussion_thread" (
  id,
  story_id,
  profile_id,
  created_at
) VALUES (
  $1,
  $2,
  $3,
  NOW()
) RETURNING id, story_id, profile_id, is_locked, comment_count, created_at, updated_at, deleted_at
`

type InsertDiscussionThreadParams struct {
	ID        string         `db:"id" json:"id"`
	StoryID   sql.NullString `db:"story_id" json:"story_id"`
	ProfileID sql.NullString `db:"profile_id" json:"profile_id"`
}

// InsertDiscussionThread
//
//	INSERT INTO "discussion_thread" (
//	  id,
//	  story_id,
//	  profile_id,
//	  created_at
//	) VALUES (
//	  $1,
//	  $2,
//	  $3,
//	  NOW()
//	) RETURNING id, story_id, profile_id, is_locked, comment_count, created_at, updated_at, deleted_at
func (q *Queries) InsertDiscussionThread(ctx context.Context, arg InsertDiscussionThreadParams) (*DiscussionThread, error) {
	row := q.db.QueryRowContext(ctx, insertDiscussionThread, arg.ID, arg.StoryID, arg.ProfileID)
	var i DiscussionThread
	err := row.Scan(
		&i.ID,
		&i.StoryID,
		&i.ProfileID,
		&i.IsLocked,
		&i.CommentCount,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const listChildDiscussionComments = `-- name: ListChildDiscussionComments :many
SELECT
  dc.id, dc.thread_id, dc.parent_id, dc.author_user_id, dc.content, dc.depth, dc.vote_score, dc.upvote_count, dc.downvote_count, dc.reply_count, dc.is_pinned, dc.is_hidden, dc.is_edited, dc.created_at, dc.updated_at, dc.deleted_at,
  u.individual_profile_id AS author_profile_id,
  ap.slug AS author_profile_slug,
  apt.title AS author_profile_title,
  ap.profile_picture_uri AS author_profile_picture_uri,
  CASE
    WHEN $1::TEXT IS NOT NULL THEN
      COALESCE(
        (SELECT dcv.direction FROM "discussion_comment_vote" dcv
         WHERE dcv.comment_id = dc.id AND dcv.user_id = $1::TEXT),
        0
      )
    ELSE 0
  END AS viewer_vote_direction
FROM "discussion_comment" dc
  LEFT JOIN "user" u ON u.id = dc.author_user_id
  LEFT JOIN "profile" ap ON ap.id = u.individual_profile_id
  LEFT JOIN "profile_tx" apt ON apt.profile_id = ap.id
    AND apt.locale_code = (
      SELECT aptf.locale_code FROM "profile_tx" aptf
      WHERE aptf.profile_id = ap.id
      ORDER BY CASE
        WHEN aptf.locale_code = $2 THEN 0
        WHEN aptf.locale_code = ap.default_locale THEN 1
        ELSE 2
      END
      LIMIT 1
    )
WHERE dc.thread_id = $3
  AND dc.parent_id = $4
  AND dc.deleted_at IS NULL
  AND ($5::BOOLEAN = TRUE OR dc.is_hidden = FALSE)
ORDER BY dc.created_at ASC
LIMIT $7
OFFSET $6
`

type ListChildDiscussionCommentsParams struct {
	ViewerUserID  sql.NullString `db:"viewer_user_id" json:"viewer_user_id"`
	LocaleCode    string         `db:"locale_code" json:"locale_code"`
	ThreadID      string         `db:"thread_id" json:"thread_id"`
	ParentID      sql.NullString `db:"parent_id" json:"parent_id"`
	IncludeHidden bool           `db:"include_hidden" json:"include_hidden"`
	PageOffset    int32          `db:"page_offset" json:"page_offset"`
	PageLimit     int32          `db:"page_limit" json:"page_limit"`
}

type ListChildDiscussionCommentsRow struct {
	ID                      string         `db:"id" json:"id"`
	ThreadID                string         `db:"thread_id" json:"thread_id"`
	ParentID                sql.NullString `db:"parent_id" json:"parent_id"`
	AuthorUserID            string         `db:"author_user_id" json:"author_user_id"`
	Content                 string         `db:"content" json:"content"`
	Depth                   int32          `db:"depth" json:"depth"`
	VoteScore               int32          `db:"vote_score" json:"vote_score"`
	UpvoteCount             int32          `db:"upvote_count" json:"upvote_count"`
	DownvoteCount           int32          `db:"downvote_count" json:"downvote_count"`
	ReplyCount              int32          `db:"reply_count" json:"reply_count"`
	IsPinned                bool           `db:"is_pinned" json:"is_pinned"`
	IsHidden                bool           `db:"is_hidden" json:"is_hidden"`
	IsEdited                bool           `db:"is_edited" json:"is_edited"`
	CreatedAt               time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt               sql.NullTime   `db:"updated_at" json:"updated_at"`
	DeletedAt               sql.NullTime   `db:"deleted_at" json:"deleted_at"`
	AuthorProfileID         sql.NullString `db:"author_profile_id" json:"author_profile_id"`
	AuthorProfileSlug       sql.NullString `db:"author_profile_slug" json:"author_profile_slug"`
	AuthorProfileTitle      sql.NullString `db:"author_profile_title" json:"author_profile_title"`
	AuthorProfilePictureURI sql.NullString `db:"author_profile_picture_uri" json:"author_profile_picture_uri"`
	ViewerVoteDirection     int32          `db:"viewer_vote_direction" json:"viewer_vote_direction"`
}

// ListChildDiscussionComments
//
//	SELECT
//	  dc.id, dc.thread_id, dc.parent_id, dc.author_user_id, dc.content, dc.depth, dc.vote_score, dc.upvote_count, dc.downvote_count, dc.reply_count, dc.is_pinned, dc.is_hidden, dc.is_edited, dc.created_at, dc.updated_at, dc.deleted_at,
//	  u.individual_profile_id AS author_profile_id,
//	  ap.slug AS author_profile_slug,
//	  apt.title AS author_profile_title,
//	  ap.profile_picture_uri AS author_profile_picture_uri,
//	  CASE
//	    WHEN $1::TEXT IS NOT NULL THEN
//	      COALESCE(
//	        (SELECT dcv.direction FROM "discussion_comment_vote" dcv
//	         WHERE dcv.comment_id = dc.id AND dcv.user_id = $1::TEXT),
//	        0
//	      )
//	    ELSE 0
//	  END AS viewer_vote_direction
//	FROM "discussion_comment" dc
//	  LEFT JOIN "user" u ON u.id = dc.author_user_id
//	  LEFT JOIN "profile" ap ON ap.id = u.individual_profile_id
//	  LEFT JOIN "profile_tx" apt ON apt.profile_id = ap.id
//	    AND apt.locale_code = (
//	      SELECT aptf.locale_code FROM "profile_tx" aptf
//	      WHERE aptf.profile_id = ap.id
//	      ORDER BY CASE
//	        WHEN aptf.locale_code = $2 THEN 0
//	        WHEN aptf.locale_code = ap.default_locale THEN 1
//	        ELSE 2
//	      END
//	      LIMIT 1
//	    )
//	WHERE dc.thread_id = $3
//	  AND dc.parent_id = $4
//	  AND dc.deleted_at IS NULL
//	  AND ($5::BOOLEAN = TRUE OR dc.is_hidden = FALSE)
//	ORDER BY dc.created_at ASC
//	LIMIT $7
//	OFFSET $6
func (q *Queries) ListChildDiscussionComments(ctx context.Context, arg ListChildDiscussionCommentsParams) ([]*ListChildDiscussionCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listChildDiscussionComments,
		arg.ViewerUserID,
		arg.LocaleCode,
		arg.ThreadID,
		arg.ParentID,
		arg.IncludeHidden,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListChildDiscussionCommentsRow{}
	for rows.Next() {
		var i ListChildDiscussionCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.ParentID,
			&i.AuthorUserID,
			&i.Content,
			&i.Depth,
			&i.VoteScore,
			&i.UpvoteCount,
			&i.DownvoteCount,
			&i.ReplyCount,
			&i.IsPinned,
			&i.IsHidden,
			&i.IsEdited,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.AuthorProfileID,
			&i.AuthorProfileSlug,
			&i.AuthorProfileTitle,
			&i.AuthorProfilePictureURI,
			&i.ViewerVoteDirection,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listTopLevelDiscussionComments = `-- name: ListTopLevelDiscussionComments :many
SELECT
  dc.id, dc.thread_id, dc.parent_id, dc.author_user_id, dc.content, dc.depth, dc.vote_score, dc.upvote_count, dc.downvote_count, dc.reply_count, dc.is_pinned, dc.is_hidden, dc.is_edited, dc.created_at, dc.updated_at, dc.deleted_at,
  u.individual_profile_id AS author_profile_id,
  ap.slug AS author_profile_slug,
  apt.title AS author_profile_title,
  ap.profile_picture_uri AS author_profile_picture_uri,
  CASE
    WHEN $1::TEXT IS NOT NULL THEN
      COALESCE(
        (SELECT dcv.direction FROM "discussion_comment_vote" dcv
         WHERE dcv.comment_id = dc.id AND dcv.user_id = $1::TEXT),
        0
      )
    ELSE 0
  END AS viewer_vote_direction
FROM "discussion_comment" dc
  LEFT JOIN "user" u ON u.id = dc.author_user_id
  LEFT JOIN "profile" ap ON ap.id = u.individual_profile_id
  LEFT JOIN "profile_tx" apt ON apt.profile_id = ap.id
    AND apt.locale_code = (
      SELECT aptf.locale_code FROM "profile_tx" aptf
      WHERE aptf.profile_id = ap.id
      ORDER BY CASE
        WHEN aptf.locale_code = $2 THEN 0
        WHEN aptf.locale_code = ap.default_locale THEN 1
        ELSE 2
      END
      LIMIT 1
    )
WHERE dc.thread_id = $3
  AND dc.parent_id IS NULL
  AND dc.deleted_at IS NULL
  AND ($4::BOOLEAN = TRUE OR dc.is_hidden = FALSE)
ORDER BY
  dc.is_pinned DESC,
  CASE WHEN $5::TEXT = 'hot' THEN dc.vote_score ELSE 0 END DESC,
  CASE WHEN $5::TEXT = 'oldest' THEN EXTRACT(EPOCH FROM dc.created_at) ELSE 0 END ASC,
  dc.created_at DESC
LIMIT $7
OFFSET $6
`

type ListTopLevelDiscussionCommentsParams struct {
	ViewerUserID  sql.NullString `db:"viewer_user_id" json:"viewer_user_id"`
	LocaleCode    string         `db:"locale_code" json:"locale_code"`
	ThreadID      string         `db:"thread_id" json:"thread_id"`
	IncludeHidden bool           `db:"include_hidden" json:"include_hidden"`
	SortMode      string         `db:"sort_mode" json:"sort_mode"`
	PageOffset    int32          `db:"page_offset" json:"page_offset"`
	PageLimit     int32          `db:"page_limit" json:"page_limit"`
}

type ListTopLevelDiscussionCommentsRow struct {
	ID                      string         `db:"id" json:"id"`
	ThreadID                string         `db:"thread_id" json:"thread_id"`
	ParentID                sql.NullString `db:"parent_id" json:"parent_id"`
	AuthorUserID            string         `db:"author_user_id" json:"author_user_id"`
	Content                 string         `db:"content" json:"content"`
	Depth                   int32          `db:"depth" json:"depth"`
	VoteScore               int32          `db:"vote_score" json:"vote_score"`
	UpvoteCount             int32          `db:"upvote_count" json:"upvote_count"`
	DownvoteCount           int32          `db:"downvote_count" json:"downvote_count"`
	ReplyCount              int32          `db:"reply_count" json:"reply_count"`
	IsPinned                bool           `db:"is_pinned" json:"is_pinned"`
	IsHidden                bool           `db:"is_hidden" json:"is_hidden"`
	IsEdited                bool           `db:"is_edited" json:"is_edited"`
	CreatedAt               time.Time      `db:"created_at" json:"created_at"`
	UpdatedAt               sql.NullTime   `db:"updated_at" json:"updated_at"`
	DeletedAt               sql.NullTime   `db:"deleted_at" json:"deleted_at"`
	AuthorProfileID         sql.NullString `db:"author_profile_id" json:"author_profile_id"`
	AuthorProfileSlug       sql.NullString `db:"author_profile_slug" json:"author_profile_slug"`
	AuthorProfileTitle      sql.NullString `db:"author_profile_title" json:"author_profile_title"`
	AuthorProfilePictureURI sql.NullString `db:"author_profile_picture_uri" json:"author_profile_picture_uri"`
	ViewerVoteDirection     int32          `db:"viewer_vote_direction" json:"viewer_vote_direction"`
}

// ListTopLevelDiscussionComments
//
//	SELECT
//	  dc.id, dc.thread_id, dc.parent_id, dc.author_user_id, dc.content, dc.depth, dc.vote_score, dc.upvote_count, dc.downvote_count, dc.reply_count, dc.is_pinned, dc.is_hidden, dc.is_edited, dc.created_at, dc.updated_at, dc.deleted_at,
//	  u.individual_profile_id AS author_profile_id,
//	  ap.slug AS author_profile_slug,
//	  apt.title AS author_profile_title,
//	  ap.profile_picture_uri AS author_profile_picture_uri,
//	  CASE
//	    WHEN $1::TEXT IS NOT NULL THEN
//	      COALESCE(
//	        (SELECT dcv.direction FROM "discussion_comment_vote" dcv
//	         WHERE dcv.comment_id = dc.id AND dcv.user_id = $1::TEXT),
//	        0
//	      )
//	    ELSE 0
//	  END AS viewer_vote_direction
//	FROM "discussion_comment" dc
//	  LEFT JOIN "user" u ON u.id = dc.author_user_id
//	  LEFT JOIN "profile" ap ON ap.id = u.individual_profile_id
//	  LEFT JOIN "profile_tx" apt ON apt.profile_id = ap.id
//	    AND apt.locale_code = (
//	      SELECT aptf.locale_code FROM "profile_tx" aptf
//	      WHERE aptf.profile_id = ap.id
//	      ORDER BY CASE
//	        WHEN aptf.locale_code = $2 THEN 0
//	        WHEN aptf.locale_code = ap.default_locale THEN 1
//	        ELSE 2
//	      END
//	      LIMIT 1
//	    )
//	WHERE dc.thread_id = $3
//	  AND dc.parent_id IS NULL
//	  AND dc.deleted_at IS NULL
//	  AND ($4::BOOLEAN = TRUE OR dc.is_hidden = FALSE)
//	ORDER BY
//	  dc.is_pinned DESC,
//	  CASE WHEN $5::TEXT = 'hot' THEN dc.vote_score ELSE 0 END DESC,
//	  CASE WHEN $5::TEXT = 'oldest' THEN EXTRACT(EPOCH FROM dc.created_at) ELSE 0 END ASC,
//	  dc.created_at DESC
//	LIMIT $7
//	OFFSET $6
func (q *Queries) ListTopLevelDiscussionComments(ctx context.Context, arg ListTopLevelDiscussionCommentsParams) ([]*ListTopLevelDiscussionCommentsRow, error) {
	rows, err := q.db.QueryContext(ctx, listTopLevelDiscussionComments,
		arg.ViewerUserID,
		arg.LocaleCode,
		arg.ThreadID,
		arg.IncludeHidden,
		arg.SortMode,
		arg.PageOffset,
		arg.PageLimit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []*ListTopLevelDiscussionCommentsRow{}
	for rows.Next() {
		var i ListTopLevelDiscussionCommentsRow
		if err := rows.Scan(
			&i.ID,
			&i.ThreadID,
			&i.ParentID,
			&i.AuthorUserID,
			&i.Content,
			&i.Depth,
			&i.VoteScore,
			&i.UpvoteCount,
			&i.DownvoteCount,
			&i.ReplyCount,
			&i.IsPinned,
			&i.IsHidden,
			&i.IsEdited,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.AuthorProfileID,
			&i.AuthorProfileSlug,
			&i.AuthorProfileTitle,
			&i.AuthorProfilePictureURI,
			&i.ViewerVoteDirection,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteDiscussionComment = `-- name: SoftDeleteDiscussionComment :exec
UPDATE "discussion_comment"
SET
  deleted_at = NOW(),
  updated_at = NOW()
WHERE id = $1
  AND deleted_at IS NULL
`

type SoftDeleteDiscussionCommentParams struct {
	ID string `db:"id" json:"id"`
}

// SoftDeleteDiscussionComment
//
//	UPDATE "discussion_comment"
//	SET
//	  deleted_at = NOW(),
//	  updated_at = NOW()
//	WHERE id = $1
//	  AND deleted_at IS NULL
func (q *Queries) SoftDeleteDiscussionComment(ctx context.Context, arg SoftDeleteDiscussionCommentParams) error {
	_, err := q.db.ExecContext(ctx, softDeleteDiscussionComment, arg.ID)
	return err
}

const updateDiscussionCommentContent = `-- name: UpdateDiscussionCommentContent :exec
UPDATE "discussion_comment"
SET
  content = $1,
  is_edited = TRUE,
  updated_at = NOW()
WHERE id = $2
  AND deleted_at IS NULL
`

type UpdateDiscussionCommentContentParams struct {
	Content string `db:"content" json:"content"`
	ID      string `db:"id" json:"id"`
}

// UpdateDiscussionCommentContent
//
//	UPDATE "discussion_comment"
//	SET
//	  content = $1,
//	  is_edited = TRUE,
//	  updated_at = NOW()
//	WHERE id = $2
//	  AND deleted_at IS NULL
func (q *Queries) UpdateDiscussionCommentContent(ctx context.Context, arg UpdateDiscussionCommentContentParams) error {
	_, err := q.db.ExecContext(ctx, updateDiscussionCommentContent, arg.Content, arg.ID)
	return err
}

const updateDiscussionCommentHidden = `-- name: UpdateDiscussionCommentHidden :exec
UPDATE "discussion_comment"
SET
  is_hidden = $1,
  updated_at = NOW()
WHERE id = $2
  AND deleted_at IS NULL
`

type UpdateDiscussionCommentHiddenParams struct {
	IsHidden bool   `db:"is_hidden" json:"is_hidden"`
	ID       string `db:"id" json:"id"`
}

// UpdateDiscussionCommentHidden
//
//	UPDATE "discussion_comment"
//	SET
//	  is_hidden = $1,
//	  updated_at = NOW()
//	WHERE id = $2
//	  AND deleted_at IS NULL
func (q *Queries) UpdateDiscussionCommentHidden(ctx context.Context, arg UpdateDiscussionCommentHiddenParams) error {
	_, err := q.db.ExecContext(ctx, updateDiscussionCommentHidden, arg.IsHidden, arg.ID)
	return err
}

const updateDiscussionCommentPinned = `-- name: UpdateDiscussionCommentPinned :exec
UPDATE "discussion_comment"
SET
  is_pinned = $1,
  updated_at = NOW()
WHERE id = $2
  AND deleted_at IS NULL
`

type UpdateDiscussionCommentPinnedParams struct {
	IsPinned bool   `db:"is_pinned" json:"is_pinned"`
	ID       string `db:"id" json:"id"`
}

// UpdateDiscussionCommentPinned
//
//	UPDATE "discussion_comment"
//	SET
//	  is_pinned = $1,
//	  updated_at = NOW()
//	WHERE id = $2
//	  AND deleted_at IS NULL
func (q *Queries) UpdateDiscussionCommentPinned(ctx context.Context, arg UpdateDiscussionCommentPinnedParams) error {
	_, err := q.db.ExecContext(ctx, updateDiscussionCommentPinned, arg.IsPinned, arg.ID)
	return err
}

const updateDiscussionCommentVoteDirection = `-- name: UpdateDiscussionCommentVoteDirection :exec
UPDATE "discussion_comment_vote"
SET direction = $1
WHERE comment_id = $2
  AND user_id = $3
`

type UpdateDiscussionCommentVoteDirectionParams struct {
	Direction int16  `db:"direction" json:"direction"`
	CommentID string `db:"comment_id" json:"comment_id"`
	UserID    string `db:"user_id" json:"user_id"`
}

// UpdateDiscussionCommentVoteDirection
//
//	UPDATE "discussion_comment_vote"
//	SET direction = $1
//	WHERE comment_id = $2
//	  AND user_id = $3
func (q *Queries) UpdateDiscussionCommentVoteDirection(ctx context.Context, arg UpdateDiscussionCommentVoteDirectionParams) error {
	_, err := q.db.ExecContext(ctx, updateDiscussionCommentVoteDirection, arg.Direction, arg.CommentID, arg.UserID)
	return err
}

const updateDiscussionThreadLocked = `-- name: UpdateDiscussionThreadLocked :exec
UPDATE "discussion_thread"
SET
  is_locked = $1,
  updated_at = NOW()
WHERE id = $2
  AND deleted_at IS NULL
`

type UpdateDiscussionThreadLockedParams struct {
	IsLocked bool   `db:"is_locked" json:"is_locked"`
	ID       string `db:"id" json:"id"`
}

// UpdateDiscussionThreadLocked
//
//	UPDATE "discussion_thread"
//	SET
//	  is_locked = $1,
//	  updated_at = NOW()
//	WHERE id = $2
//	  AND deleted_at IS NULL
func (q *Queries) UpdateDiscussionThreadLocked(ctx context.Context, arg UpdateDiscussionThreadLockedParams) error {
	_, err := q.db.ExecContext(ctx, updateDiscussionThreadLocked, arg.IsLocked, arg.ID)
	return err
}
